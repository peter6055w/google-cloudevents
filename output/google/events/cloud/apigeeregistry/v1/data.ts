// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/apigeeregistry/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";

export const protobufPackage = "google.events.cloud.apigeeregistry.v1";

/**
 * An Instance represents the instance resources of the Registry.
 * Currently, only one instance is allowed for each project.
 */
export interface Instance {
  /**
   * Format: `projects/* /locations/* /instance`.
   * Currently only `locations/global` is supported.
   */
  name: string;
  /** Output only. Creation timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Output only. The current state of the Instance. */
  state: Instance_State;
  /** Output only. Extra information of Instance.State if the state is `FAILED`. */
  stateMessage: string;
  /** Required. Config of the Instance. */
  config?: Instance_Config | undefined;
}

/** State of the Instance. */
export enum Instance_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** INACTIVE - The Instance has not been initialized or has been deleted. */
  INACTIVE = 1,
  /** CREATING - The Instance is being created. */
  CREATING = 2,
  /** ACTIVE - The Instance has been created and is ready for use. */
  ACTIVE = 3,
  /** UPDATING - The Instance is being updated. */
  UPDATING = 4,
  /** DELETING - The Instance is being deleted. */
  DELETING = 5,
  /** FAILED - The Instance encountered an error during a state change. */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "INACTIVE":
      return Instance_State.INACTIVE;
    case 2:
    case "CREATING":
      return Instance_State.CREATING;
    case 3:
    case "ACTIVE":
      return Instance_State.ACTIVE;
    case 4:
    case "UPDATING":
      return Instance_State.UPDATING;
    case 5:
    case "DELETING":
      return Instance_State.DELETING;
    case 6:
    case "FAILED":
      return Instance_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.INACTIVE:
      return "INACTIVE";
    case Instance_State.CREATING:
      return "CREATING";
    case Instance_State.ACTIVE:
      return "ACTIVE";
    case Instance_State.UPDATING:
      return "UPDATING";
    case Instance_State.DELETING:
      return "DELETING";
    case Instance_State.FAILED:
      return "FAILED";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available configurations to provision an Instance. */
export interface Instance_Config {
  /** Output only. The GCP location where the Instance resides. */
  location: string;
  /**
   * Required. The Customer Managed Encryption Key (CMEK) used for data
   * encryption. The CMEK name should follow the format of
   * `projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)`,
   * where the `location` must match InstanceConfig.location.
   */
  cmekKeyName: string;
}

/**
 * A top-level description of an API.
 * Produced by producers and are commitments to provide services.
 */
export interface Api {
  /** Resource name. */
  name: string;
  /** Human-meaningful name. */
  displayName: string;
  /** A detailed description. */
  description: string;
  /** Output only. Creation timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /**
   * A user-definable description of the availability of this service.
   * Format: free-form, but we expect single words that describe availability,
   * e.g., "NONE", "TESTING", "PREVIEW", "GENERAL", "DEPRECATED", "SHUTDOWN".
   */
  availability: string;
  /**
   * The recommended version of the API.
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
   */
  recommendedVersion: string;
  /**
   * The recommended deployment of the API.
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}`
   */
  recommendedDeployment: string;
  /**
   * Labels attach identifying metadata to resources. Identifying metadata can
   * be used to filter list operations.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores, and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one resource (System
   * labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with
   * `apigeeregistry.googleapis.com/` and cannot be changed.
   */
  labels: { [key: string]: string };
  /**
   * Annotations attach non-identifying metadata to resources.
   *
   * Annotation keys and values are less restricted than those of labels, but
   * should be generally used for small values of broad interest. Larger, topic-
   * specific metadata should be stored in Artifacts.
   */
  annotations: { [key: string]: string };
}

export interface Api_LabelsEntry {
  key: string;
  value: string;
}

export interface Api_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Describes a particular version of an API.
 * ApiVersions are what consumers actually use.
 */
export interface ApiVersion {
  /** Resource name. */
  name: string;
  /** Human-meaningful name. */
  displayName: string;
  /** A detailed description. */
  description: string;
  /** Output only. Creation timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /**
   * A user-definable description of the lifecycle phase of this API version.
   * Format: free-form, but we expect single words that describe API maturity,
   * e.g., "CONCEPT", "DESIGN", "DEVELOPMENT", "STAGING", "PRODUCTION",
   * "DEPRECATED", "RETIRED".
   */
  state: string;
  /**
   * Labels attach identifying metadata to resources. Identifying metadata can
   * be used to filter list operations.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one resource (System
   * labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with
   * `apigeeregistry.googleapis.com/` and cannot be changed.
   */
  labels: { [key: string]: string };
  /**
   * Annotations attach non-identifying metadata to resources.
   *
   * Annotation keys and values are less restricted than those of labels, but
   * should be generally used for small values of broad interest. Larger, topic-
   * specific metadata should be stored in Artifacts.
   */
  annotations: { [key: string]: string };
}

export interface ApiVersion_LabelsEntry {
  key: string;
  value: string;
}

export interface ApiVersion_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Describes a version of an API in a structured way.
 * ApiSpecs provide formal descriptions that consumers can use to use a version.
 * ApiSpec resources are intended to be fully-resolved descriptions of an
 * ApiVersion. When specs consist of multiple files, these should be bundled
 * together (e.g., in a zip archive) and stored as a unit. Multiple specs can
 * exist to provide representations in different API description formats.
 * Synchronization of these representations would be provided by tooling and
 * background services.
 */
export interface ApiSpec {
  /** Resource name. */
  name: string;
  /** A possibly-hierarchical name used to refer to the spec from other specs. */
  filename: string;
  /** A detailed description. */
  description: string;
  /**
   * Output only. Immutable. The revision ID of the spec.
   * A new revision is committed whenever the spec contents are changed.
   * The format is an 8-character hexadecimal string.
   */
  revisionId: string;
  /** Output only. Creation timestamp; when the spec resource was created. */
  createTime?:
    | Date
    | undefined;
  /**
   * Output only. Revision creation timestamp; when the represented revision was
   * created.
   */
  revisionCreateTime?:
    | Date
    | undefined;
  /**
   * Output only. Last update timestamp: when the represented revision was last
   * modified.
   */
  revisionUpdateTime?:
    | Date
    | undefined;
  /**
   * A style (format) descriptor for this spec that is specified as a Media Type
   * (https://en.wikipedia.org/wiki/Media_type). Possible values include
   * `application/vnd.apigee.proto`, `application/vnd.apigee.openapi`, and
   * `application/vnd.apigee.graphql`, with possible suffixes representing
   * compression types. These hypothetical names are defined in the vendor tree
   * defined in RFC6838 (https://tools.ietf.org/html/rfc6838) and are not final.
   * Content types can specify compression. Currently only GZip compression is
   * supported (indicated with "+gzip").
   */
  mimeType: string;
  /**
   * Output only. The size of the spec file in bytes. If the spec is gzipped,
   * this is the size of the uncompressed spec.
   */
  sizeBytes: number;
  /**
   * Output only. A SHA-256 hash of the spec's contents. If the spec is gzipped,
   * this is the hash of the uncompressed spec.
   */
  hash: string;
  /**
   * The original source URI of the spec (if one exists).
   * This is an external location that can be used for reference purposes
   * but which may not be authoritative since this external resource may
   * change after the spec is retrieved.
   */
  sourceUri: string;
  /**
   * Labels attach identifying metadata to resources. Identifying metadata can
   * be used to filter list operations.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one resource (System
   * labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with
   * `apigeeregistry.googleapis.com/` and cannot be changed.
   */
  labels: { [key: string]: string };
  /**
   * Annotations attach non-identifying metadata to resources.
   *
   * Annotation keys and values are less restricted than those of labels, but
   * should be generally used for small values of broad interest. Larger, topic-
   * specific metadata should be stored in Artifacts.
   */
  annotations: { [key: string]: string };
}

export interface ApiSpec_LabelsEntry {
  key: string;
  value: string;
}

export interface ApiSpec_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Describes a service running at particular address that
 * provides a particular version of an API. ApiDeployments have revisions which
 * correspond to different configurations of a single deployment in time.
 * Revision identifiers should be updated whenever the served API spec or
 * endpoint address changes.
 */
export interface ApiDeployment {
  /** Resource name. */
  name: string;
  /** Human-meaningful name. */
  displayName: string;
  /** A detailed description. */
  description: string;
  /**
   * Output only. Immutable. The revision ID of the deployment.
   * A new revision is committed whenever the deployment contents are changed.
   * The format is an 8-character hexadecimal string.
   */
  revisionId: string;
  /** Output only. Creation timestamp; when the deployment resource was created. */
  createTime?:
    | Date
    | undefined;
  /**
   * Output only. Revision creation timestamp; when the represented revision was
   * created.
   */
  revisionCreateTime?:
    | Date
    | undefined;
  /**
   * Output only. Last update timestamp: when the represented revision was last
   * modified.
   */
  revisionUpdateTime?:
    | Date
    | undefined;
  /**
   * The full resource name (including revision ID) of the spec of the API being
   * served by the deployment. Changes to this value will update the revision.
   * Format: `apis/{api}/deployments/{deployment}`
   */
  apiSpecRevision: string;
  /**
   * The address where the deployment is serving. Changes to this value will
   * update the revision.
   */
  endpointUri: string;
  /**
   * The address of the external channel of the API (e.g., the Developer
   * Portal). Changes to this value will not affect the revision.
   */
  externalChannelUri: string;
  /**
   * Text briefly identifying the intended audience of the API. Changes to this
   * value will not affect the revision.
   */
  intendedAudience: string;
  /**
   * Text briefly describing how to access the endpoint. Changes to this value
   * will not affect the revision.
   */
  accessGuidance: string;
  /**
   * Labels attach identifying metadata to resources. Identifying metadata can
   * be used to filter list operations.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one resource (System
   * labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with
   * `apigeeregistry.googleapis.com/` and cannot be changed.
   */
  labels: { [key: string]: string };
  /**
   * Annotations attach non-identifying metadata to resources.
   *
   * Annotation keys and values are less restricted than those of labels, but
   * should be generally used for small values of broad interest. Larger, topic-
   * specific metadata should be stored in Artifacts.
   */
  annotations: { [key: string]: string };
}

export interface ApiDeployment_LabelsEntry {
  key: string;
  value: string;
}

export interface ApiDeployment_AnnotationsEntry {
  key: string;
  value: string;
}

/** The data within all ApiVersion events. */
export interface ApiVersionEventData {
  /** Optional. The ApiVersion event payload. Unset for deletion events. */
  payload?: ApiVersion | undefined;
}

/** The data within all Instance events. */
export interface InstanceEventData {
  /** Optional. The Instance event payload. Unset for deletion events. */
  payload?: Instance | undefined;
}

/** The data within all ApiSpec events. */
export interface ApiSpecEventData {
  /** Optional. The ApiSpec event payload. Unset for deletion events. */
  payload?: ApiSpec | undefined;
}

/** The data within all ApiDeployment events. */
export interface ApiDeploymentEventData {
  /** Optional. The ApiDeployment event payload. Unset for deletion events. */
  payload?: ApiDeployment | undefined;
}

/** The data within all Api events. */
export interface ApiEventData {
  /** Optional. The Api event payload. Unset for deletion events. */
  payload?: Api | undefined;
}

function createBaseInstance(): Instance {
  return { name: "", createTime: undefined, updateTime: undefined, state: 0, stateMessage: "", config: undefined };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.stateMessage !== "") {
      writer.uint32(42).string(message.stateMessage);
    }
    if (message.config !== undefined) {
      Instance_Config.encode(message.config, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stateMessage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.config = Instance_Config.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
      stateMessage: isSet(object.stateMessage) ? globalThis.String(object.stateMessage) : "",
      config: isSet(object.config) ? Instance_Config.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    if (message.stateMessage !== "") {
      obj.stateMessage = message.stateMessage;
    }
    if (message.config !== undefined) {
      obj.config = Instance_Config.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance>, I>>(base?: I): Instance {
    return Instance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance>, I>>(object: I): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.stateMessage = object.stateMessage ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? Instance_Config.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseInstance_Config(): Instance_Config {
  return { location: "", cmekKeyName: "" };
}

export const Instance_Config: MessageFns<Instance_Config> = {
  encode(message: Instance_Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.cmekKeyName !== "") {
      writer.uint32(18).string(message.cmekKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_Config();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cmekKeyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_Config {
    return {
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      cmekKeyName: isSet(object.cmekKeyName) ? globalThis.String(object.cmekKeyName) : "",
    };
  },

  toJSON(message: Instance_Config): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.cmekKeyName !== "") {
      obj.cmekKeyName = message.cmekKeyName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_Config>, I>>(base?: I): Instance_Config {
    return Instance_Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_Config>, I>>(object: I): Instance_Config {
    const message = createBaseInstance_Config();
    message.location = object.location ?? "";
    message.cmekKeyName = object.cmekKeyName ?? "";
    return message;
  },
};

function createBaseApi(): Api {
  return {
    name: "",
    displayName: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    availability: "",
    recommendedVersion: "",
    recommendedDeployment: "",
    labels: {},
    annotations: {},
  };
}

export const Api: MessageFns<Api> = {
  encode(message: Api, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.availability !== "") {
      writer.uint32(50).string(message.availability);
    }
    if (message.recommendedVersion !== "") {
      writer.uint32(58).string(message.recommendedVersion);
    }
    if (message.recommendedDeployment !== "") {
      writer.uint32(66).string(message.recommendedDeployment);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Api_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      Api_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.availability = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.recommendedVersion = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.recommendedDeployment = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = Api_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = Api_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.annotations[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      availability: isSet(object.availability) ? globalThis.String(object.availability) : "",
      recommendedVersion: isSet(object.recommendedVersion) ? globalThis.String(object.recommendedVersion) : "",
      recommendedDeployment: isSet(object.recommendedDeployment) ? globalThis.String(object.recommendedDeployment) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Api): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.availability !== "") {
      obj.availability = message.availability;
    }
    if (message.recommendedVersion !== "") {
      obj.recommendedVersion = message.recommendedVersion;
    }
    if (message.recommendedDeployment !== "") {
      obj.recommendedDeployment = message.recommendedDeployment;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Api>, I>>(base?: I): Api {
    return Api.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Api>, I>>(object: I): Api {
    const message = createBaseApi();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.availability = object.availability ?? "";
    message.recommendedVersion = object.recommendedVersion ?? "";
    message.recommendedDeployment = object.recommendedDeployment ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApi_LabelsEntry(): Api_LabelsEntry {
  return { key: "", value: "" };
}

export const Api_LabelsEntry: MessageFns<Api_LabelsEntry> = {
  encode(message: Api_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Api_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Api_LabelsEntry>, I>>(base?: I): Api_LabelsEntry {
    return Api_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Api_LabelsEntry>, I>>(object: I): Api_LabelsEntry {
    const message = createBaseApi_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApi_AnnotationsEntry(): Api_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Api_AnnotationsEntry: MessageFns<Api_AnnotationsEntry> = {
  encode(message: Api_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Api_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Api_AnnotationsEntry>, I>>(base?: I): Api_AnnotationsEntry {
    return Api_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Api_AnnotationsEntry>, I>>(object: I): Api_AnnotationsEntry {
    const message = createBaseApi_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiVersion(): ApiVersion {
  return {
    name: "",
    displayName: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    state: "",
    labels: {},
    annotations: {},
  };
}

export const ApiVersion: MessageFns<ApiVersion> = {
  encode(message: ApiVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.state !== "") {
      writer.uint32(50).string(message.state);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ApiVersion_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      ApiVersion_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = ApiVersion_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = ApiVersion_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.annotations[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiVersion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ApiVersion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiVersion>, I>>(base?: I): ApiVersion {
    return ApiVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiVersion>, I>>(object: I): ApiVersion {
    const message = createBaseApiVersion();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApiVersion_LabelsEntry(): ApiVersion_LabelsEntry {
  return { key: "", value: "" };
}

export const ApiVersion_LabelsEntry: MessageFns<ApiVersion_LabelsEntry> = {
  encode(message: ApiVersion_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiVersion_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiVersion_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiVersion_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiVersion_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiVersion_LabelsEntry>, I>>(base?: I): ApiVersion_LabelsEntry {
    return ApiVersion_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiVersion_LabelsEntry>, I>>(object: I): ApiVersion_LabelsEntry {
    const message = createBaseApiVersion_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiVersion_AnnotationsEntry(): ApiVersion_AnnotationsEntry {
  return { key: "", value: "" };
}

export const ApiVersion_AnnotationsEntry: MessageFns<ApiVersion_AnnotationsEntry> = {
  encode(message: ApiVersion_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiVersion_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiVersion_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiVersion_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiVersion_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiVersion_AnnotationsEntry>, I>>(base?: I): ApiVersion_AnnotationsEntry {
    return ApiVersion_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiVersion_AnnotationsEntry>, I>>(object: I): ApiVersion_AnnotationsEntry {
    const message = createBaseApiVersion_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiSpec(): ApiSpec {
  return {
    name: "",
    filename: "",
    description: "",
    revisionId: "",
    createTime: undefined,
    revisionCreateTime: undefined,
    revisionUpdateTime: undefined,
    mimeType: "",
    sizeBytes: 0,
    hash: "",
    sourceUri: "",
    labels: {},
    annotations: {},
  };
}

export const ApiSpec: MessageFns<ApiSpec> = {
  encode(message: ApiSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.revisionId !== "") {
      writer.uint32(34).string(message.revisionId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(50).fork()).join();
    }
    if (message.revisionUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionUpdateTime), writer.uint32(58).fork()).join();
    }
    if (message.mimeType !== "") {
      writer.uint32(66).string(message.mimeType);
    }
    if (message.sizeBytes !== 0) {
      writer.uint32(72).int32(message.sizeBytes);
    }
    if (message.hash !== "") {
      writer.uint32(82).string(message.hash);
    }
    if (message.sourceUri !== "") {
      writer.uint32(90).string(message.sourceUri);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ApiSpec_LabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      ApiSpec_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.revisionUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sizeBytes = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = ApiSpec_LabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.labels[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = ApiSpec_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.annotations[entry15.key] = entry15.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      revisionUpdateTime: isSet(object.revisionUpdateTime) ? fromJsonTimestamp(object.revisionUpdateTime) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      sizeBytes: isSet(object.sizeBytes) ? globalThis.Number(object.sizeBytes) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ApiSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.revisionUpdateTime !== undefined) {
      obj.revisionUpdateTime = message.revisionUpdateTime.toISOString();
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.sizeBytes !== 0) {
      obj.sizeBytes = Math.round(message.sizeBytes);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiSpec>, I>>(base?: I): ApiSpec {
    return ApiSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiSpec>, I>>(object: I): ApiSpec {
    const message = createBaseApiSpec();
    message.name = object.name ?? "";
    message.filename = object.filename ?? "";
    message.description = object.description ?? "";
    message.revisionId = object.revisionId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.revisionUpdateTime = object.revisionUpdateTime ?? undefined;
    message.mimeType = object.mimeType ?? "";
    message.sizeBytes = object.sizeBytes ?? 0;
    message.hash = object.hash ?? "";
    message.sourceUri = object.sourceUri ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApiSpec_LabelsEntry(): ApiSpec_LabelsEntry {
  return { key: "", value: "" };
}

export const ApiSpec_LabelsEntry: MessageFns<ApiSpec_LabelsEntry> = {
  encode(message: ApiSpec_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiSpec_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiSpec_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiSpec_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiSpec_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiSpec_LabelsEntry>, I>>(base?: I): ApiSpec_LabelsEntry {
    return ApiSpec_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiSpec_LabelsEntry>, I>>(object: I): ApiSpec_LabelsEntry {
    const message = createBaseApiSpec_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiSpec_AnnotationsEntry(): ApiSpec_AnnotationsEntry {
  return { key: "", value: "" };
}

export const ApiSpec_AnnotationsEntry: MessageFns<ApiSpec_AnnotationsEntry> = {
  encode(message: ApiSpec_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiSpec_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiSpec_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiSpec_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiSpec_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiSpec_AnnotationsEntry>, I>>(base?: I): ApiSpec_AnnotationsEntry {
    return ApiSpec_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiSpec_AnnotationsEntry>, I>>(object: I): ApiSpec_AnnotationsEntry {
    const message = createBaseApiSpec_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiDeployment(): ApiDeployment {
  return {
    name: "",
    displayName: "",
    description: "",
    revisionId: "",
    createTime: undefined,
    revisionCreateTime: undefined,
    revisionUpdateTime: undefined,
    apiSpecRevision: "",
    endpointUri: "",
    externalChannelUri: "",
    intendedAudience: "",
    accessGuidance: "",
    labels: {},
    annotations: {},
  };
}

export const ApiDeployment: MessageFns<ApiDeployment> = {
  encode(message: ApiDeployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.revisionId !== "") {
      writer.uint32(34).string(message.revisionId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(50).fork()).join();
    }
    if (message.revisionUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionUpdateTime), writer.uint32(58).fork()).join();
    }
    if (message.apiSpecRevision !== "") {
      writer.uint32(66).string(message.apiSpecRevision);
    }
    if (message.endpointUri !== "") {
      writer.uint32(74).string(message.endpointUri);
    }
    if (message.externalChannelUri !== "") {
      writer.uint32(82).string(message.externalChannelUri);
    }
    if (message.intendedAudience !== "") {
      writer.uint32(90).string(message.intendedAudience);
    }
    if (message.accessGuidance !== "") {
      writer.uint32(98).string(message.accessGuidance);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ApiDeployment_LabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      ApiDeployment_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiDeployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.revisionUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.apiSpecRevision = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.endpointUri = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.externalChannelUri = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.intendedAudience = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.accessGuidance = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = ApiDeployment_LabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.labels[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = ApiDeployment_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.annotations[entry15.key] = entry15.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiDeployment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      revisionUpdateTime: isSet(object.revisionUpdateTime) ? fromJsonTimestamp(object.revisionUpdateTime) : undefined,
      apiSpecRevision: isSet(object.apiSpecRevision) ? globalThis.String(object.apiSpecRevision) : "",
      endpointUri: isSet(object.endpointUri) ? globalThis.String(object.endpointUri) : "",
      externalChannelUri: isSet(object.externalChannelUri) ? globalThis.String(object.externalChannelUri) : "",
      intendedAudience: isSet(object.intendedAudience) ? globalThis.String(object.intendedAudience) : "",
      accessGuidance: isSet(object.accessGuidance) ? globalThis.String(object.accessGuidance) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ApiDeployment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.revisionUpdateTime !== undefined) {
      obj.revisionUpdateTime = message.revisionUpdateTime.toISOString();
    }
    if (message.apiSpecRevision !== "") {
      obj.apiSpecRevision = message.apiSpecRevision;
    }
    if (message.endpointUri !== "") {
      obj.endpointUri = message.endpointUri;
    }
    if (message.externalChannelUri !== "") {
      obj.externalChannelUri = message.externalChannelUri;
    }
    if (message.intendedAudience !== "") {
      obj.intendedAudience = message.intendedAudience;
    }
    if (message.accessGuidance !== "") {
      obj.accessGuidance = message.accessGuidance;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiDeployment>, I>>(base?: I): ApiDeployment {
    return ApiDeployment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiDeployment>, I>>(object: I): ApiDeployment {
    const message = createBaseApiDeployment();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.revisionId = object.revisionId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.revisionUpdateTime = object.revisionUpdateTime ?? undefined;
    message.apiSpecRevision = object.apiSpecRevision ?? "";
    message.endpointUri = object.endpointUri ?? "";
    message.externalChannelUri = object.externalChannelUri ?? "";
    message.intendedAudience = object.intendedAudience ?? "";
    message.accessGuidance = object.accessGuidance ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApiDeployment_LabelsEntry(): ApiDeployment_LabelsEntry {
  return { key: "", value: "" };
}

export const ApiDeployment_LabelsEntry: MessageFns<ApiDeployment_LabelsEntry> = {
  encode(message: ApiDeployment_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiDeployment_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiDeployment_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiDeployment_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiDeployment_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiDeployment_LabelsEntry>, I>>(base?: I): ApiDeployment_LabelsEntry {
    return ApiDeployment_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiDeployment_LabelsEntry>, I>>(object: I): ApiDeployment_LabelsEntry {
    const message = createBaseApiDeployment_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiDeployment_AnnotationsEntry(): ApiDeployment_AnnotationsEntry {
  return { key: "", value: "" };
}

export const ApiDeployment_AnnotationsEntry: MessageFns<ApiDeployment_AnnotationsEntry> = {
  encode(message: ApiDeployment_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiDeployment_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiDeployment_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiDeployment_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiDeployment_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiDeployment_AnnotationsEntry>, I>>(base?: I): ApiDeployment_AnnotationsEntry {
    return ApiDeployment_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiDeployment_AnnotationsEntry>, I>>(
    object: I,
  ): ApiDeployment_AnnotationsEntry {
    const message = createBaseApiDeployment_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiVersionEventData(): ApiVersionEventData {
  return { payload: undefined };
}

export const ApiVersionEventData: MessageFns<ApiVersionEventData> = {
  encode(message: ApiVersionEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ApiVersion.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiVersionEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiVersionEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ApiVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiVersionEventData {
    return { payload: isSet(object.payload) ? ApiVersion.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ApiVersionEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ApiVersion.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiVersionEventData>, I>>(base?: I): ApiVersionEventData {
    return ApiVersionEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiVersionEventData>, I>>(object: I): ApiVersionEventData {
    const message = createBaseApiVersionEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ApiVersion.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseInstanceEventData(): InstanceEventData {
  return { payload: undefined };
}

export const InstanceEventData: MessageFns<InstanceEventData> = {
  encode(message: InstanceEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Instance.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Instance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceEventData {
    return { payload: isSet(object.payload) ? Instance.fromJSON(object.payload) : undefined };
  },

  toJSON(message: InstanceEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Instance.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceEventData>, I>>(base?: I): InstanceEventData {
    return InstanceEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceEventData>, I>>(object: I): InstanceEventData {
    const message = createBaseInstanceEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Instance.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseApiSpecEventData(): ApiSpecEventData {
  return { payload: undefined };
}

export const ApiSpecEventData: MessageFns<ApiSpecEventData> = {
  encode(message: ApiSpecEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ApiSpec.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiSpecEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiSpecEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ApiSpec.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiSpecEventData {
    return { payload: isSet(object.payload) ? ApiSpec.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ApiSpecEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ApiSpec.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiSpecEventData>, I>>(base?: I): ApiSpecEventData {
    return ApiSpecEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiSpecEventData>, I>>(object: I): ApiSpecEventData {
    const message = createBaseApiSpecEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ApiSpec.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseApiDeploymentEventData(): ApiDeploymentEventData {
  return { payload: undefined };
}

export const ApiDeploymentEventData: MessageFns<ApiDeploymentEventData> = {
  encode(message: ApiDeploymentEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ApiDeployment.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiDeploymentEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiDeploymentEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ApiDeployment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiDeploymentEventData {
    return { payload: isSet(object.payload) ? ApiDeployment.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ApiDeploymentEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ApiDeployment.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiDeploymentEventData>, I>>(base?: I): ApiDeploymentEventData {
    return ApiDeploymentEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiDeploymentEventData>, I>>(object: I): ApiDeploymentEventData {
    const message = createBaseApiDeploymentEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ApiDeployment.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseApiEventData(): ApiEventData {
  return { payload: undefined };
}

export const ApiEventData: MessageFns<ApiEventData> = {
  encode(message: ApiEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Api.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Api.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiEventData {
    return { payload: isSet(object.payload) ? Api.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ApiEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Api.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiEventData>, I>>(base?: I): ApiEventData {
    return ApiEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiEventData>, I>>(object: I): ApiEventData {
    const message = createBaseApiEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Api.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
