// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/apihub/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";

export const protobufPackage = "google.events.cloud.apihub.v1";

/** Lint state represents success or failure for linting. */
export enum LintState {
  /** LINT_STATE_UNSPECIFIED - Lint state unspecified. */
  LINT_STATE_UNSPECIFIED = 0,
  /** LINT_STATE_SUCCESS - Linting was completed successfully. */
  LINT_STATE_SUCCESS = 1,
  /** LINT_STATE_ERROR - Linting encountered errors. */
  LINT_STATE_ERROR = 2,
  UNRECOGNIZED = -1,
}

export function lintStateFromJSON(object: any): LintState {
  switch (object) {
    case 0:
    case "LINT_STATE_UNSPECIFIED":
      return LintState.LINT_STATE_UNSPECIFIED;
    case 1:
    case "LINT_STATE_SUCCESS":
      return LintState.LINT_STATE_SUCCESS;
    case 2:
    case "LINT_STATE_ERROR":
      return LintState.LINT_STATE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LintState.UNRECOGNIZED;
  }
}

export function lintStateToJSON(object: LintState): string {
  switch (object) {
    case LintState.LINT_STATE_UNSPECIFIED:
      return "LINT_STATE_UNSPECIFIED";
    case LintState.LINT_STATE_SUCCESS:
      return "LINT_STATE_SUCCESS";
    case LintState.LINT_STATE_ERROR:
      return "LINT_STATE_ERROR";
    case LintState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enumeration of linter types. */
export enum Linter {
  /** LINTER_UNSPECIFIED - Linter type unspecified. */
  LINTER_UNSPECIFIED = 0,
  /** SPECTRAL - Linter type spectral. */
  SPECTRAL = 1,
  /** OTHER - Linter type other. */
  OTHER = 2,
  UNRECOGNIZED = -1,
}

export function linterFromJSON(object: any): Linter {
  switch (object) {
    case 0:
    case "LINTER_UNSPECIFIED":
      return Linter.LINTER_UNSPECIFIED;
    case 1:
    case "SPECTRAL":
      return Linter.SPECTRAL;
    case 2:
    case "OTHER":
      return Linter.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Linter.UNRECOGNIZED;
  }
}

export function linterToJSON(object: Linter): string {
  switch (object) {
    case Linter.LINTER_UNSPECIFIED:
      return "LINTER_UNSPECIFIED";
    case Linter.SPECTRAL:
      return "SPECTRAL";
    case Linter.OTHER:
      return "OTHER";
    case Linter.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Severity of the issue. */
export enum Severity {
  /** SEVERITY_UNSPECIFIED - Severity unspecified. */
  SEVERITY_UNSPECIFIED = 0,
  /** SEVERITY_ERROR - Severity error. */
  SEVERITY_ERROR = 1,
  /** SEVERITY_WARNING - Severity warning. */
  SEVERITY_WARNING = 2,
  /** SEVERITY_INFO - Severity info. */
  SEVERITY_INFO = 3,
  /** SEVERITY_HINT - Severity hint. */
  SEVERITY_HINT = 4,
  UNRECOGNIZED = -1,
}

export function severityFromJSON(object: any): Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "SEVERITY_ERROR":
      return Severity.SEVERITY_ERROR;
    case 2:
    case "SEVERITY_WARNING":
      return Severity.SEVERITY_WARNING;
    case 3:
    case "SEVERITY_INFO":
      return Severity.SEVERITY_INFO;
    case 4:
    case "SEVERITY_HINT":
      return Severity.SEVERITY_HINT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Severity.UNRECOGNIZED;
  }
}

export function severityToJSON(object: Severity): string {
  switch (object) {
    case Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case Severity.SEVERITY_ERROR:
      return "SEVERITY_ERROR";
    case Severity.SEVERITY_WARNING:
      return "SEVERITY_WARNING";
    case Severity.SEVERITY_INFO:
      return "SEVERITY_INFO";
    case Severity.SEVERITY_HINT:
      return "SEVERITY_HINT";
    case Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An API resource in the API Hub. */
export interface Api {
  /**
   * Identifier. The name of the API resource in the API Hub.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}`
   */
  name: string;
  /** Required. The display name of the API resource. */
  displayName: string;
  /** Optional. The description of the API resource. */
  description: string;
  /** Optional. The documentation for the API resource. */
  documentation?:
    | Documentation
    | undefined;
  /** Optional. Owner details for the API resource. */
  owner?:
    | Owner
    | undefined;
  /**
   * Output only. The list of versions present in an API resource.
   * Note: An API resource can be associated with more than 1 version.
   * Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
   */
  versions: string[];
  /** Output only. The time at which the API resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time at which the API resource was last updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. The target users for the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-target-user`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  targetUser?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The team owning the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-team`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  team?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The business unit owning the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-business-unit`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  businessUnit?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The maturity level of the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-maturity-level`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  maturityLevel?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the API
   * resource. The key is the attribute name. It will be of the format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
  /**
   * Optional. The style of the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-api-style`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  apiStyle?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The selected version for an API resource.
   * This can be used when special handling is needed on client side for
   * particular version of the API. Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
   */
  selectedVersion: string;
}

export interface Api_AttributesEntry {
  key: string;
  value?: AttributeValues | undefined;
}

/**
 * Represents a version of the API resource in API hub. This is also referred
 * to as the API version.
 */
export interface Version {
  /**
   * Identifier. The name of the version.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
   */
  name: string;
  /** Required. The display name of the version. */
  displayName: string;
  /** Optional. The description of the version. */
  description: string;
  /** Optional. The documentation of the version. */
  documentation?:
    | Documentation
    | undefined;
  /**
   * Output only. The specs associated with this version.
   * Note that an API version can be associated with multiple specs.
   * Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
   */
  specs: string[];
  /**
   * Output only. The operations contained in the API version.
   * These operations will be added to the version when a new spec is
   * added or when an existing spec is updated. Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
   */
  apiOperations: string[];
  /**
   * Output only. The definitions contained in the API version.
   * These definitions will be added to the version when a new spec is
   * added or when an existing spec is updated. Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
   */
  definitions: string[];
  /**
   * Optional. The deployments linked to this API version.
   * Note: A particular API version could be deployed to multiple deployments
   * (for dev deployment, UAT deployment, etc)
   * Format is
   * `projects/{project}/locations/{location}/deployments/{deployment}`
   */
  deployments: string[];
  /** Output only. The time at which the version was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time at which the version was last updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. The lifecycle of the API version.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-lifecycle`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  lifecycle?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The compliance associated with the API version.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-compliance`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  compliance?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The accreditations associated with the API version.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-accreditation`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  accreditation?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the Version
   * resource. The key is the attribute name. It will be of the format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
  /**
   * Optional. The selected deployment for a Version resource.
   * This can be used when special handling is needed on client side for a
   * particular deployment linked to the version.
   * Format is
   * `projects/{project}/locations/{location}/deployments/{deployment}`
   */
  selectedDeployment: string;
}

export interface Version_AttributesEntry {
  key: string;
  value?: AttributeValues | undefined;
}

/**
 * Represents a spec associated with an API version in the API
 * Hub. Note that specs of various types can be uploaded, however
 * parsing of details is supported for OpenAPI spec currently.
 */
export interface Spec {
  /**
   * Identifier. The name of the spec.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
   */
  name: string;
  /**
   * Required. The display name of the spec.
   * This can contain the file name of the spec.
   */
  displayName: string;
  /**
   * Required. The type of spec.
   * The value should be one of the allowed values defined for
   * `projects/{project}/locations/{location}/attributes/system-spec-type`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API.
   *
   * Note, this field is mandatory if content is provided.
   */
  specType?:
    | AttributeValues
    | undefined;
  /** Output only. Details parsed from the spec. */
  details?:
    | SpecDetails
    | undefined;
  /**
   * Optional. The URI of the spec source in case file is uploaded
   * from an external version control system.
   */
  sourceUri: string;
  /** Output only. The time at which the spec was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time at which the spec was last updated. */
  updateTime?:
    | Date
    | undefined;
  /** Optional. The lint response for the spec. */
  lintResponse?:
    | LintResponse
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the spec.
   * The key is the attribute name. It will be of the format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
  /**
   * Optional. The documentation of the spec.
   * For OpenAPI spec, this will be populated from `externalDocs` in OpenAPI
   * spec.
   */
  documentation?: Documentation | undefined;
}

export interface Spec_AttributesEntry {
  key: string;
  value?: AttributeValues | undefined;
}

/**
 * Details of the deployment where APIs are hosted.
 * A deployment could represent an Apigee proxy, API gateway, other Google Cloud
 * services or non-Google Cloud services as well. A deployment entity is a root
 * level entity in the API hub and exists independent of any API.
 */
export interface Deployment {
  /**
   * Identifier. The name of the deployment.
   *
   * Format:
   * `projects/{project}/locations/{location}/deployments/{deployment}`
   */
  name: string;
  /** Required. The display name of the deployment. */
  displayName: string;
  /** Optional. The description of the deployment. */
  description: string;
  /** Optional. The documentation of the deployment. */
  documentation?:
    | Documentation
    | undefined;
  /**
   * Required. The type of deployment.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-deployment-type`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  deploymentType?:
    | AttributeValues
    | undefined;
  /**
   * Required. A URI to the runtime resource. This URI can be used to manage the
   * resource. For example, if the runtime resource is of type APIGEE_PROXY,
   * then this field will contain the URI to the management UI of the proxy.
   */
  resourceUri: string;
  /**
   * Required. The endpoints at which this deployment resource is listening for
   * API requests. This could be a list of complete URIs, hostnames or an IP
   * addresses.
   */
  endpoints: string[];
  /**
   * Output only. The API versions linked to this deployment.
   * Note: A particular deployment could be linked to multiple different API
   * versions (of same or different APIs).
   */
  apiVersions: string[];
  /** Output only. The time at which the deployment was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time at which the deployment was last updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. The SLO for this deployment.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-slo`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  slo?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The environment mapping to this deployment.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-environment`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  environment?:
    | AttributeValues
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the
   * deployment resource. The key is the attribute name. It will be of the
   * format: `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
}

export interface Deployment_AttributesEntry {
  key: string;
  value?: AttributeValues | undefined;
}

/**
 * An attribute in the API Hub.
 * An attribute is a name value pair which can be attached to different
 * resources in the API hub based on the scope of the attribute. Attributes can
 * either be pre-defined by the API Hub or created by users.
 */
export interface Attribute {
  /**
   * Identifier. The name of the attribute in the API Hub.
   *
   * Format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`
   */
  name: string;
  /** Required. The display name of the attribute. */
  displayName: string;
  /** Optional. The description of the attribute. */
  description: string;
  /** Output only. The definition type of the attribute. */
  definitionType: Attribute_DefinitionType;
  /**
   * Required. The scope of the attribute. It represents the resource in the API
   * Hub to which the attribute can be linked.
   */
  scope: Attribute_Scope;
  /** Required. The type of the data of the attribute. */
  dataType: Attribute_DataType;
  /**
   * Optional. The list of allowed values when the attribute value is of type
   * enum. This is required when the data_type of the attribute is ENUM. The
   * maximum number of allowed values of an attribute will be 1000.
   */
  allowedValues: Attribute_AllowedValue[];
  /**
   * Optional. The maximum number of values that the attribute can have when
   * associated with an API Hub resource. Cardinality 1 would represent a
   * single-valued attribute. It must not be less than 1 or greater than 20. If
   * not specified, the cardinality would be set to 1 by default and represent a
   * single-valued attribute.
   */
  cardinality: number;
  /**
   * Output only. When mandatory is true, the attribute is mandatory for the
   * resource specified in the scope. Only System defined attributes can be
   * mandatory.
   */
  mandatory: boolean;
  /** Output only. The time at which the attribute was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time at which the attribute was last updated. */
  updateTime?: Date | undefined;
}

/** Enumeration of attribute definition types. */
export enum Attribute_DefinitionType {
  /** DEFINITION_TYPE_UNSPECIFIED - Attribute definition type unspecified. */
  DEFINITION_TYPE_UNSPECIFIED = 0,
  /**
   * SYSTEM_DEFINED - The attribute is predefined by the API Hub. Note that only the list of
   * allowed values can be updated in this case via UpdateAttribute method.
   */
  SYSTEM_DEFINED = 1,
  /** USER_DEFINED - The attribute is defined by the user. */
  USER_DEFINED = 2,
  UNRECOGNIZED = -1,
}

export function attribute_DefinitionTypeFromJSON(object: any): Attribute_DefinitionType {
  switch (object) {
    case 0:
    case "DEFINITION_TYPE_UNSPECIFIED":
      return Attribute_DefinitionType.DEFINITION_TYPE_UNSPECIFIED;
    case 1:
    case "SYSTEM_DEFINED":
      return Attribute_DefinitionType.SYSTEM_DEFINED;
    case 2:
    case "USER_DEFINED":
      return Attribute_DefinitionType.USER_DEFINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attribute_DefinitionType.UNRECOGNIZED;
  }
}

export function attribute_DefinitionTypeToJSON(object: Attribute_DefinitionType): string {
  switch (object) {
    case Attribute_DefinitionType.DEFINITION_TYPE_UNSPECIFIED:
      return "DEFINITION_TYPE_UNSPECIFIED";
    case Attribute_DefinitionType.SYSTEM_DEFINED:
      return "SYSTEM_DEFINED";
    case Attribute_DefinitionType.USER_DEFINED:
      return "USER_DEFINED";
    case Attribute_DefinitionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enumeration for the scope of the attribute representing the resource in the
 * API Hub to which the attribute can be linked.
 */
export enum Attribute_Scope {
  /** SCOPE_UNSPECIFIED - Scope Unspecified. */
  SCOPE_UNSPECIFIED = 0,
  /** API - Attribute can be linked to an API. */
  API = 1,
  /** VERSION - Attribute can be linked to an API version. */
  VERSION = 2,
  /** SPEC - Attribute can be linked to a Spec. */
  SPEC = 3,
  /** API_OPERATION - Attribute can be linked to an API Operation. */
  API_OPERATION = 4,
  /** DEPLOYMENT - Attribute can be linked to a Deployment. */
  DEPLOYMENT = 5,
  /** DEPENDENCY - Attribute can be linked to a Dependency. */
  DEPENDENCY = 6,
  /** DEFINITION - Attribute can be linked to a definition. */
  DEFINITION = 7,
  /** EXTERNAL_API - Attribute can be linked to a ExternalAPI. */
  EXTERNAL_API = 8,
  /** PLUGIN - Attribute can be linked to a Plugin. */
  PLUGIN = 9,
  UNRECOGNIZED = -1,
}

export function attribute_ScopeFromJSON(object: any): Attribute_Scope {
  switch (object) {
    case 0:
    case "SCOPE_UNSPECIFIED":
      return Attribute_Scope.SCOPE_UNSPECIFIED;
    case 1:
    case "API":
      return Attribute_Scope.API;
    case 2:
    case "VERSION":
      return Attribute_Scope.VERSION;
    case 3:
    case "SPEC":
      return Attribute_Scope.SPEC;
    case 4:
    case "API_OPERATION":
      return Attribute_Scope.API_OPERATION;
    case 5:
    case "DEPLOYMENT":
      return Attribute_Scope.DEPLOYMENT;
    case 6:
    case "DEPENDENCY":
      return Attribute_Scope.DEPENDENCY;
    case 7:
    case "DEFINITION":
      return Attribute_Scope.DEFINITION;
    case 8:
    case "EXTERNAL_API":
      return Attribute_Scope.EXTERNAL_API;
    case 9:
    case "PLUGIN":
      return Attribute_Scope.PLUGIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attribute_Scope.UNRECOGNIZED;
  }
}

export function attribute_ScopeToJSON(object: Attribute_Scope): string {
  switch (object) {
    case Attribute_Scope.SCOPE_UNSPECIFIED:
      return "SCOPE_UNSPECIFIED";
    case Attribute_Scope.API:
      return "API";
    case Attribute_Scope.VERSION:
      return "VERSION";
    case Attribute_Scope.SPEC:
      return "SPEC";
    case Attribute_Scope.API_OPERATION:
      return "API_OPERATION";
    case Attribute_Scope.DEPLOYMENT:
      return "DEPLOYMENT";
    case Attribute_Scope.DEPENDENCY:
      return "DEPENDENCY";
    case Attribute_Scope.DEFINITION:
      return "DEFINITION";
    case Attribute_Scope.EXTERNAL_API:
      return "EXTERNAL_API";
    case Attribute_Scope.PLUGIN:
      return "PLUGIN";
    case Attribute_Scope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enumeration of attribute's data type. */
export enum Attribute_DataType {
  /** DATA_TYPE_UNSPECIFIED - Attribute data type unspecified. */
  DATA_TYPE_UNSPECIFIED = 0,
  /** ENUM - Attribute's value is of type enum. */
  ENUM = 1,
  /** JSON - Attribute's value is of type json. */
  JSON = 2,
  /** STRING - Attribute's value is of type string. */
  STRING = 3,
  UNRECOGNIZED = -1,
}

export function attribute_DataTypeFromJSON(object: any): Attribute_DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return Attribute_DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "ENUM":
      return Attribute_DataType.ENUM;
    case 2:
    case "JSON":
      return Attribute_DataType.JSON;
    case 3:
    case "STRING":
      return Attribute_DataType.STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attribute_DataType.UNRECOGNIZED;
  }
}

export function attribute_DataTypeToJSON(object: Attribute_DataType): string {
  switch (object) {
    case Attribute_DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case Attribute_DataType.ENUM:
      return "ENUM";
    case Attribute_DataType.JSON:
      return "JSON";
    case Attribute_DataType.STRING:
      return "STRING";
    case Attribute_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The value that can be assigned to the attribute when the data type is
 * enum.
 */
export interface Attribute_AllowedValue {
  /**
   * Required. The ID of the allowed value.
   * * If provided, the same will be used. The service will throw an error if
   * the specified id is already used by another allowed value in the same
   * attribute resource.
   * * If not provided, a system generated id derived from the display name
   * will be used. In this case, the service will handle conflict resolution
   * by adding a system generated suffix in case of duplicates.
   *
   * This value should be 4-63 characters, and valid characters
   * are /[a-z][0-9]-/.
   */
  id: string;
  /** Required. The display name of the allowed value. */
  displayName: string;
  /** Optional. The detailed description of the allowed value. */
  description: string;
  /**
   * Optional. When set to true, the allowed value cannot be updated or
   * deleted by the user. It can only be true for System defined attributes.
   */
  immutable: boolean;
}

/** The spec contents. */
export interface SpecContents {
  /** Required. The contents of the spec. */
  contents: Uint8Array;
  /**
   * Required. The mime type of the content for example application/json,
   * application/yaml, application/wsdl etc.
   */
  mimeType: string;
}

/**
 * SpecDetails contains the details parsed from supported
 * spec types.
 */
export interface SpecDetails {
  /**
   * Output only. Additional details apart from `OperationDetails` parsed from
   * an OpenAPI spec. The OperationDetails parsed from the spec can be
   * obtained by using
   * [ListAPIOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
   * method.
   */
  openApiSpecDetails?:
    | OpenApiSpecDetails
    | undefined;
  /** Output only. The description of the spec. */
  description: string;
}

/**
 * OpenApiSpecDetails contains the details parsed from an OpenAPI spec in
 * addition to the fields mentioned in
 * [SpecDetails][google.cloud.apihub.v1.SpecDetails].
 */
export interface OpenApiSpecDetails {
  /** Output only. The format of the spec. */
  format: OpenApiSpecDetails_Format;
  /**
   * Output only. The version in the spec.
   * This maps to `info.version` in OpenAPI spec.
   */
  version: string;
  /**
   * Output only. Owner details for the spec.
   * This maps to `info.contact` in OpenAPI spec.
   */
  owner?: Owner | undefined;
}

/** Enumeration of spec formats. */
export enum OpenApiSpecDetails_Format {
  /** FORMAT_UNSPECIFIED - SpecFile type unspecified. */
  FORMAT_UNSPECIFIED = 0,
  /** OPEN_API_SPEC_2_0 - OpenAPI Spec v2.0. */
  OPEN_API_SPEC_2_0 = 1,
  /** OPEN_API_SPEC_3_0 - OpenAPI Spec v3.0. */
  OPEN_API_SPEC_3_0 = 2,
  /** OPEN_API_SPEC_3_1 - OpenAPI Spec v3.1. */
  OPEN_API_SPEC_3_1 = 3,
  UNRECOGNIZED = -1,
}

export function openApiSpecDetails_FormatFromJSON(object: any): OpenApiSpecDetails_Format {
  switch (object) {
    case 0:
    case "FORMAT_UNSPECIFIED":
      return OpenApiSpecDetails_Format.FORMAT_UNSPECIFIED;
    case 1:
    case "OPEN_API_SPEC_2_0":
      return OpenApiSpecDetails_Format.OPEN_API_SPEC_2_0;
    case 2:
    case "OPEN_API_SPEC_3_0":
      return OpenApiSpecDetails_Format.OPEN_API_SPEC_3_0;
    case 3:
    case "OPEN_API_SPEC_3_1":
      return OpenApiSpecDetails_Format.OPEN_API_SPEC_3_1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OpenApiSpecDetails_Format.UNRECOGNIZED;
  }
}

export function openApiSpecDetails_FormatToJSON(object: OpenApiSpecDetails_Format): string {
  switch (object) {
    case OpenApiSpecDetails_Format.FORMAT_UNSPECIFIED:
      return "FORMAT_UNSPECIFIED";
    case OpenApiSpecDetails_Format.OPEN_API_SPEC_2_0:
      return "OPEN_API_SPEC_2_0";
    case OpenApiSpecDetails_Format.OPEN_API_SPEC_3_0:
      return "OPEN_API_SPEC_3_0";
    case OpenApiSpecDetails_Format.OPEN_API_SPEC_3_1:
      return "OPEN_API_SPEC_3_1";
    case OpenApiSpecDetails_Format.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Owner details. */
export interface Owner {
  /** Optional. The name of the owner. */
  displayName: string;
  /** Required. The email of the owner. */
  email: string;
}

/** Documentation details. */
export interface Documentation {
  /** Optional. The uri of the externally hosted documentation. */
  externalUri: string;
}

/** The attribute values associated with resource. */
export interface AttributeValues {
  /**
   * The attribute values associated with a resource in case attribute data
   * type is enum.
   */
  enumValues?:
    | AttributeValues_EnumAttributeValues
    | undefined;
  /**
   * The attribute values associated with a resource in case attribute data
   * type is string.
   */
  stringValues?:
    | AttributeValues_StringAttributeValues
    | undefined;
  /**
   * The attribute values associated with a resource in case attribute data
   * type is JSON.
   */
  jsonValues?:
    | AttributeValues_StringAttributeValues
    | undefined;
  /**
   * Output only. The name of the attribute.
   * Format: projects/{project}/locations/{location}/attributes/{attribute}
   */
  attribute: string;
}

/** The attribute values of data type enum. */
export interface AttributeValues_EnumAttributeValues {
  /** Required. The attribute values in case attribute data type is enum. */
  values: Attribute_AllowedValue[];
}

/** The attribute values of data type string or JSON. */
export interface AttributeValues_StringAttributeValues {
  /**
   * Required. The attribute values in case attribute data type is string or
   * JSON.
   */
  values: string[];
}

/**
 * A dependency resource defined in the API hub describes a dependency directed
 * from a consumer to a supplier entity. A dependency can be defined between two
 * [Operations][google.cloud.apihub.v1.Operation] or between
 * an [Operation][google.cloud.apihub.v1.Operation] and [External
 * API][google.cloud.apihub.v1.ExternalApi].
 */
export interface Dependency {
  /**
   * Identifier. The name of the dependency in the API Hub.
   *
   * Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
   */
  name: string;
  /** Required. Immutable. The entity acting as the consumer in the dependency. */
  consumer?:
    | DependencyEntityReference
    | undefined;
  /** Required. Immutable. The entity acting as the supplier in the dependency. */
  supplier?:
    | DependencyEntityReference
    | undefined;
  /** Output only. State of the dependency. */
  state: Dependency_State;
  /** Optional. Human readable description corresponding of the dependency. */
  description: string;
  /** Output only. Discovery mode of the dependency. */
  discoveryMode: Dependency_DiscoveryMode;
  /**
   * Output only. Error details of a dependency if the system has detected it
   * internally.
   */
  errorDetail?:
    | DependencyErrorDetail
    | undefined;
  /** Output only. The time at which the dependency was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time at which the dependency was last updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the
   * dependency resource. The key is the attribute name. It will be of the
   * format: `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
}

/** Possible states for a dependency. */
export enum Dependency_State {
  /** STATE_UNSPECIFIED - Default value. This value is unused. */
  STATE_UNSPECIFIED = 0,
  /**
   * PROPOSED - Dependency will be in a proposed state when it is newly identified by the
   * API hub on its own.
   */
  PROPOSED = 1,
  /**
   * VALIDATED - Dependency will be in a validated state when it is validated by the
   * admin or manually created in the API hub.
   */
  VALIDATED = 2,
  UNRECOGNIZED = -1,
}

export function dependency_StateFromJSON(object: any): Dependency_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Dependency_State.STATE_UNSPECIFIED;
    case 1:
    case "PROPOSED":
      return Dependency_State.PROPOSED;
    case 2:
    case "VALIDATED":
      return Dependency_State.VALIDATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Dependency_State.UNRECOGNIZED;
  }
}

export function dependency_StateToJSON(object: Dependency_State): string {
  switch (object) {
    case Dependency_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Dependency_State.PROPOSED:
      return "PROPOSED";
    case Dependency_State.VALIDATED:
      return "VALIDATED";
    case Dependency_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible modes of discovering the dependency. */
export enum Dependency_DiscoveryMode {
  /** DISCOVERY_MODE_UNSPECIFIED - Default value. This value is unused. */
  DISCOVERY_MODE_UNSPECIFIED = 0,
  /** MANUAL - Manual mode of discovery when the dependency is defined by the user. */
  MANUAL = 1,
  UNRECOGNIZED = -1,
}

export function dependency_DiscoveryModeFromJSON(object: any): Dependency_DiscoveryMode {
  switch (object) {
    case 0:
    case "DISCOVERY_MODE_UNSPECIFIED":
      return Dependency_DiscoveryMode.DISCOVERY_MODE_UNSPECIFIED;
    case 1:
    case "MANUAL":
      return Dependency_DiscoveryMode.MANUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Dependency_DiscoveryMode.UNRECOGNIZED;
  }
}

export function dependency_DiscoveryModeToJSON(object: Dependency_DiscoveryMode): string {
  switch (object) {
    case Dependency_DiscoveryMode.DISCOVERY_MODE_UNSPECIFIED:
      return "DISCOVERY_MODE_UNSPECIFIED";
    case Dependency_DiscoveryMode.MANUAL:
      return "MANUAL";
    case Dependency_DiscoveryMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Dependency_AttributesEntry {
  key: string;
  value?: AttributeValues | undefined;
}

/** Reference to an entity participating in a dependency. */
export interface DependencyEntityReference {
  /**
   * The resource name of an operation in the API Hub.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
   */
  operationResourceName?:
    | string
    | undefined;
  /**
   * The resource name of an external API in the API Hub.
   *
   * Format:
   * `projects/{project}/locations/{location}/externalApis/{external_api}`
   */
  externalApiResourceName?:
    | string
    | undefined;
  /** Output only. Display name of the entity. */
  displayName: string;
}

/** Details describing error condition of a dependency. */
export interface DependencyErrorDetail {
  /** Optional. Error in the dependency. */
  error: DependencyErrorDetail_Error;
  /** Optional. Timestamp at which the error was found. */
  errorTime?: Date | undefined;
}

/** Possible values representing an error in the dependency. */
export enum DependencyErrorDetail_Error {
  /** ERROR_UNSPECIFIED - Default value used for no error in the dependency. */
  ERROR_UNSPECIFIED = 0,
  /** SUPPLIER_NOT_FOUND - Supplier entity has been deleted. */
  SUPPLIER_NOT_FOUND = 1,
  /** SUPPLIER_RECREATED - Supplier entity has been recreated. */
  SUPPLIER_RECREATED = 2,
  UNRECOGNIZED = -1,
}

export function dependencyErrorDetail_ErrorFromJSON(object: any): DependencyErrorDetail_Error {
  switch (object) {
    case 0:
    case "ERROR_UNSPECIFIED":
      return DependencyErrorDetail_Error.ERROR_UNSPECIFIED;
    case 1:
    case "SUPPLIER_NOT_FOUND":
      return DependencyErrorDetail_Error.SUPPLIER_NOT_FOUND;
    case 2:
    case "SUPPLIER_RECREATED":
      return DependencyErrorDetail_Error.SUPPLIER_RECREATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DependencyErrorDetail_Error.UNRECOGNIZED;
  }
}

export function dependencyErrorDetail_ErrorToJSON(object: DependencyErrorDetail_Error): string {
  switch (object) {
    case DependencyErrorDetail_Error.ERROR_UNSPECIFIED:
      return "ERROR_UNSPECIFIED";
    case DependencyErrorDetail_Error.SUPPLIER_NOT_FOUND:
      return "SUPPLIER_NOT_FOUND";
    case DependencyErrorDetail_Error.SUPPLIER_RECREATED:
      return "SUPPLIER_RECREATED";
    case DependencyErrorDetail_Error.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** LintResponse contains the response from the linter. */
export interface LintResponse {
  /** Optional. Array of issues found in the analyzed document. */
  issues: Issue[];
  /** Optional. Summary of all issue types and counts for each severity level. */
  summary: LintResponse_SummaryEntry[];
  /** Required. Lint state represents success or failure for linting. */
  state: LintState;
  /** Required. Name of the linting application. */
  source: string;
  /** Required. Name of the linter used. */
  linter: Linter;
  /** Required. Timestamp when the linting response was generated. */
  createTime?: Date | undefined;
}

/** Count of issues with a given severity. */
export interface LintResponse_SummaryEntry {
  /** Required. Severity of the issue. */
  severity: Severity;
  /** Required. Count of issues with the given severity. */
  count: number;
}

/** Issue contains the details of a single issue found by the linter. */
export interface Issue {
  /** Required. Rule code unique to each rule defined in linter. */
  code: string;
  /**
   * Required. An array of strings indicating the location in the analyzed
   * document where the rule was triggered.
   */
  path: string[];
  /** Required. Human-readable message describing the issue found by the linter. */
  message: string;
  /** Required. Severity level of the rule violation. */
  severity: Severity;
  /** Required. Object describing where in the file the issue was found. */
  range?: Range | undefined;
}

/** Object describing where in the file the issue was found. */
export interface Range {
  /** Required. Start of the issue. */
  start?:
    | Point
    | undefined;
  /** Required. End of the issue. */
  end?: Point | undefined;
}

/** Point within the file (line and character). */
export interface Point {
  /** Required. Line number (zero-indexed). */
  line: number;
  /** Required. Character position within the line (zero-indexed). */
  character: number;
}

/**
 * An ApiHubInstance represents the instance resources of the API Hub.
 * Currently, only one ApiHub instance is allowed for each project.
 */
export interface ApiHubInstance {
  /**
   * Identifier. Format:
   * `projects/{project}/locations/{location}/apiHubInstances/{apiHubInstance}`.
   */
  name: string;
  /** Output only. Creation timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Output only. The current state of the ApiHub instance. */
  state: ApiHubInstance_State;
  /**
   * Output only. Extra information about ApiHub instance state. Currently the
   * message would be populated when state is `FAILED`.
   */
  stateMessage: string;
  /** Required. Config of the ApiHub instance. */
  config?:
    | ApiHubInstance_Config
    | undefined;
  /**
   * Optional. Instance labels to represent user-provided metadata.
   * Refer to cloud documentation on labels for more details.
   * https://cloud.google.com/compute/docs/labeling-resources
   */
  labels: { [key: string]: string };
  /** Optional. Description of the ApiHub instance. */
  description: string;
}

/** State of the ApiHub Instance. */
export enum ApiHubInstance_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** INACTIVE - The ApiHub instance has not been initialized or has been deleted. */
  INACTIVE = 1,
  /** CREATING - The ApiHub instance is being created. */
  CREATING = 2,
  /** ACTIVE - The ApiHub instance has been created and is ready for use. */
  ACTIVE = 3,
  /** UPDATING - The ApiHub instance is being updated. */
  UPDATING = 4,
  /** DELETING - The ApiHub instance is being deleted. */
  DELETING = 5,
  /** FAILED - The ApiHub instance encountered an error during a state change. */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function apiHubInstance_StateFromJSON(object: any): ApiHubInstance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ApiHubInstance_State.STATE_UNSPECIFIED;
    case 1:
    case "INACTIVE":
      return ApiHubInstance_State.INACTIVE;
    case 2:
    case "CREATING":
      return ApiHubInstance_State.CREATING;
    case 3:
    case "ACTIVE":
      return ApiHubInstance_State.ACTIVE;
    case 4:
    case "UPDATING":
      return ApiHubInstance_State.UPDATING;
    case 5:
    case "DELETING":
      return ApiHubInstance_State.DELETING;
    case 6:
    case "FAILED":
      return ApiHubInstance_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ApiHubInstance_State.UNRECOGNIZED;
  }
}

export function apiHubInstance_StateToJSON(object: ApiHubInstance_State): string {
  switch (object) {
    case ApiHubInstance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ApiHubInstance_State.INACTIVE:
      return "INACTIVE";
    case ApiHubInstance_State.CREATING:
      return "CREATING";
    case ApiHubInstance_State.ACTIVE:
      return "ACTIVE";
    case ApiHubInstance_State.UPDATING:
      return "UPDATING";
    case ApiHubInstance_State.DELETING:
      return "DELETING";
    case ApiHubInstance_State.FAILED:
      return "FAILED";
    case ApiHubInstance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available configurations to provision an ApiHub Instance. */
export interface ApiHubInstance_Config {
  /**
   * Required. The Customer Managed Encryption Key (CMEK) used for data
   * encryption. The CMEK name should follow the format of
   * `projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)`,
   * where the location must match the instance location.
   */
  cmekKeyName: string;
}

export interface ApiHubInstance_LabelsEntry {
  key: string;
  value: string;
}

/**
 * An external API represents an API being provided by external sources. This
 * can be used to model third-party APIs and can be used to define dependencies.
 */
export interface ExternalApi {
  /**
   * Identifier. Format:
   * `projects/{project}/locations/{location}/externalApi/{externalApi}`.
   */
  name: string;
  /**
   * Required. Display name of the external API. Max length is 63 characters
   * (Unicode Code Points).
   */
  displayName: string;
  /**
   * Optional. Description of the external API. Max length is 2000 characters
   * (Unicode Code Points).
   */
  description: string;
  /** Optional. List of endpoints on which this API is accessible. */
  endpoints: string[];
  /** Optional. List of paths served by this API. */
  paths: string[];
  /** Optional. Documentation of the external API. */
  documentation?:
    | Documentation
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the Version
   * resource. The key is the attribute name. It will be of the format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
  /** Output only. Creation timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime?: Date | undefined;
}

export interface ExternalApi_AttributesEntry {
  key: string;
  value?: AttributeValues | undefined;
}

/**
 * Host project registration refers to the registration of a Google cloud
 * project with Api Hub as a host project. This is the project where Api Hub is
 * provisioned. It acts as the consumer project for the Api Hub instance
 * provisioned. Multiple runtime projects can be attached to the host project
 * and these attachments define the scope of Api Hub.
 */
export interface HostProjectRegistration {
  /**
   * Identifier. The name of the host project registration.
   * Format:
   * "projects/{project}/locations/{location}/hostProjectRegistrations/{host_project_registration}".
   */
  name: string;
  /**
   * Required. Immutable. Google cloud project name in the format:
   * "projects/abc" or "projects/123". As input, project name with either
   * project id or number are accepted. As output, this field will contain
   * project number.
   */
  gcpProject: string;
  /** Output only. The time at which the host project registration was created. */
  createTime?: Date | undefined;
}

/**
 * Runtime project attachment represents an attachment from the runtime project
 * to the host project. Api Hub looks for deployments in the attached runtime
 * projects and creates corresponding resources in Api Hub for the discovered
 * deployments.
 */
export interface RuntimeProjectAttachment {
  /**
   * Identifier. The resource name of a runtime project attachment. Format:
   * "projects/{project}/locations/{location}/runtimeProjectAttachments/{runtime_project_attachment}".
   */
  name: string;
  /**
   * Required. Immutable. Google cloud project name in the format:
   * "projects/abc" or "projects/123". As input, project name with either
   * project id or number are accepted. As output, this field will contain
   * project number.
   */
  runtimeProject: string;
  /** Output only. Create time. */
  createTime?: Date | undefined;
}

/** The data within all Api events. */
export interface ApiEventData {
  /** Optional. The Api event payload. Unset for deletion events. */
  payload?: Api | undefined;
}

/** The data within all Version events. */
export interface VersionEventData {
  /** Optional. The Version event payload. Unset for deletion events. */
  payload?: Version | undefined;
}

/** The data within all Spec events. */
export interface SpecEventData {
  /** Optional. The Spec event payload. Unset for deletion events. */
  payload?: Spec | undefined;
}

/** The data within all Deployment events. */
export interface DeploymentEventData {
  /** Optional. The Deployment event payload. Unset for deletion events. */
  payload?: Deployment | undefined;
}

/** The data within all Attribute events. */
export interface AttributeEventData {
  /** Optional. The Attribute event payload. Unset for deletion events. */
  payload?: Attribute | undefined;
}

/** The data within all ExternalApi events. */
export interface ExternalApiEventData {
  /** Optional. The ExternalApi event payload. Unset for deletion events. */
  payload?: ExternalApi | undefined;
}

/** The data within all Dependency events. */
export interface DependencyEventData {
  /** Optional. The Dependency event payload. Unset for deletion events. */
  payload?: Dependency | undefined;
}

/** The data within all HostProjectRegistration events. */
export interface HostProjectRegistrationEventData {
  /** The HostProjectRegistration event payload. */
  payload?: HostProjectRegistration | undefined;
}

/** The data within all ApiHubInstance events. */
export interface ApiHubInstanceEventData {
  /** The ApiHubInstance event payload. */
  payload?: ApiHubInstance | undefined;
}

/** The data within all RuntimeProjectAttachment events. */
export interface RuntimeProjectAttachmentEventData {
  /**
   * Optional. The RuntimeProjectAttachment event payload. Unset for deletion
   * events.
   */
  payload?: RuntimeProjectAttachment | undefined;
}

function createBaseApi(): Api {
  return {
    name: "",
    displayName: "",
    description: "",
    documentation: undefined,
    owner: undefined,
    versions: [],
    createTime: undefined,
    updateTime: undefined,
    targetUser: undefined,
    team: undefined,
    businessUnit: undefined,
    maturityLevel: undefined,
    attributes: {},
    apiStyle: undefined,
    selectedVersion: "",
  };
}

export const Api: MessageFns<Api> = {
  encode(message: Api, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(34).fork()).join();
    }
    if (message.owner !== undefined) {
      Owner.encode(message.owner, writer.uint32(42).fork()).join();
    }
    for (const v of message.versions) {
      writer.uint32(50).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.targetUser !== undefined) {
      AttributeValues.encode(message.targetUser, writer.uint32(74).fork()).join();
    }
    if (message.team !== undefined) {
      AttributeValues.encode(message.team, writer.uint32(82).fork()).join();
    }
    if (message.businessUnit !== undefined) {
      AttributeValues.encode(message.businessUnit, writer.uint32(90).fork()).join();
    }
    if (message.maturityLevel !== undefined) {
      AttributeValues.encode(message.maturityLevel, writer.uint32(98).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Api_AttributesEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    if (message.apiStyle !== undefined) {
      AttributeValues.encode(message.apiStyle, writer.uint32(114).fork()).join();
    }
    if (message.selectedVersion !== "") {
      writer.uint32(122).string(message.selectedVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.owner = Owner.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.versions.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetUser = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.team = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.businessUnit = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.maturityLevel = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = Api_AttributesEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.attributes[entry13.key] = entry13.value;
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.apiStyle = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.selectedVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      owner: isSet(object.owner) ? Owner.fromJSON(object.owner) : undefined,
      versions: globalThis.Array.isArray(object?.versions) ? object.versions.map((e: any) => globalThis.String(e)) : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      targetUser: isSet(object.targetUser) ? AttributeValues.fromJSON(object.targetUser) : undefined,
      team: isSet(object.team) ? AttributeValues.fromJSON(object.team) : undefined,
      businessUnit: isSet(object.businessUnit) ? AttributeValues.fromJSON(object.businessUnit) : undefined,
      maturityLevel: isSet(object.maturityLevel) ? AttributeValues.fromJSON(object.maturityLevel) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      apiStyle: isSet(object.apiStyle) ? AttributeValues.fromJSON(object.apiStyle) : undefined,
      selectedVersion: isSet(object.selectedVersion) ? globalThis.String(object.selectedVersion) : "",
    };
  },

  toJSON(message: Api): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.owner !== undefined) {
      obj.owner = Owner.toJSON(message.owner);
    }
    if (message.versions?.length) {
      obj.versions = message.versions;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.targetUser !== undefined) {
      obj.targetUser = AttributeValues.toJSON(message.targetUser);
    }
    if (message.team !== undefined) {
      obj.team = AttributeValues.toJSON(message.team);
    }
    if (message.businessUnit !== undefined) {
      obj.businessUnit = AttributeValues.toJSON(message.businessUnit);
    }
    if (message.maturityLevel !== undefined) {
      obj.maturityLevel = AttributeValues.toJSON(message.maturityLevel);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.apiStyle !== undefined) {
      obj.apiStyle = AttributeValues.toJSON(message.apiStyle);
    }
    if (message.selectedVersion !== "") {
      obj.selectedVersion = message.selectedVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Api>, I>>(base?: I): Api {
    return Api.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Api>, I>>(object: I): Api {
    const message = createBaseApi();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.owner = (object.owner !== undefined && object.owner !== null) ? Owner.fromPartial(object.owner) : undefined;
    message.versions = object.versions?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.targetUser = (object.targetUser !== undefined && object.targetUser !== null)
      ? AttributeValues.fromPartial(object.targetUser)
      : undefined;
    message.team = (object.team !== undefined && object.team !== null)
      ? AttributeValues.fromPartial(object.team)
      : undefined;
    message.businessUnit = (object.businessUnit !== undefined && object.businessUnit !== null)
      ? AttributeValues.fromPartial(object.businessUnit)
      : undefined;
    message.maturityLevel = (object.maturityLevel !== undefined && object.maturityLevel !== null)
      ? AttributeValues.fromPartial(object.maturityLevel)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.apiStyle = (object.apiStyle !== undefined && object.apiStyle !== null)
      ? AttributeValues.fromPartial(object.apiStyle)
      : undefined;
    message.selectedVersion = object.selectedVersion ?? "";
    return message;
  },
};

function createBaseApi_AttributesEntry(): Api_AttributesEntry {
  return { key: "", value: undefined };
}

export const Api_AttributesEntry: MessageFns<Api_AttributesEntry> = {
  encode(message: Api_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Api_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Api_AttributesEntry>, I>>(base?: I): Api_AttributesEntry {
    return Api_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Api_AttributesEntry>, I>>(object: I): Api_AttributesEntry {
    const message = createBaseApi_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseVersion(): Version {
  return {
    name: "",
    displayName: "",
    description: "",
    documentation: undefined,
    specs: [],
    apiOperations: [],
    definitions: [],
    deployments: [],
    createTime: undefined,
    updateTime: undefined,
    lifecycle: undefined,
    compliance: undefined,
    accreditation: undefined,
    attributes: {},
    selectedDeployment: "",
  };
}

export const Version: MessageFns<Version> = {
  encode(message: Version, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(34).fork()).join();
    }
    for (const v of message.specs) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.apiOperations) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.definitions) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.deployments) {
      writer.uint32(66).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.lifecycle !== undefined) {
      AttributeValues.encode(message.lifecycle, writer.uint32(90).fork()).join();
    }
    if (message.compliance !== undefined) {
      AttributeValues.encode(message.compliance, writer.uint32(98).fork()).join();
    }
    if (message.accreditation !== undefined) {
      AttributeValues.encode(message.accreditation, writer.uint32(106).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Version_AttributesEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    if (message.selectedDeployment !== "") {
      writer.uint32(130).string(message.selectedDeployment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.specs.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.apiOperations.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.definitions.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.deployments.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lifecycle = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.compliance = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.accreditation = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = Version_AttributesEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.attributes[entry14.key] = entry14.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.selectedDeployment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      specs: globalThis.Array.isArray(object?.specs) ? object.specs.map((e: any) => globalThis.String(e)) : [],
      apiOperations: globalThis.Array.isArray(object?.apiOperations)
        ? object.apiOperations.map((e: any) => globalThis.String(e))
        : [],
      definitions: globalThis.Array.isArray(object?.definitions)
        ? object.definitions.map((e: any) => globalThis.String(e))
        : [],
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      lifecycle: isSet(object.lifecycle) ? AttributeValues.fromJSON(object.lifecycle) : undefined,
      compliance: isSet(object.compliance) ? AttributeValues.fromJSON(object.compliance) : undefined,
      accreditation: isSet(object.accreditation) ? AttributeValues.fromJSON(object.accreditation) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      selectedDeployment: isSet(object.selectedDeployment) ? globalThis.String(object.selectedDeployment) : "",
    };
  },

  toJSON(message: Version): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.specs?.length) {
      obj.specs = message.specs;
    }
    if (message.apiOperations?.length) {
      obj.apiOperations = message.apiOperations;
    }
    if (message.definitions?.length) {
      obj.definitions = message.definitions;
    }
    if (message.deployments?.length) {
      obj.deployments = message.deployments;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.lifecycle !== undefined) {
      obj.lifecycle = AttributeValues.toJSON(message.lifecycle);
    }
    if (message.compliance !== undefined) {
      obj.compliance = AttributeValues.toJSON(message.compliance);
    }
    if (message.accreditation !== undefined) {
      obj.accreditation = AttributeValues.toJSON(message.accreditation);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.selectedDeployment !== "") {
      obj.selectedDeployment = message.selectedDeployment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Version>, I>>(base?: I): Version {
    return Version.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Version>, I>>(object: I): Version {
    const message = createBaseVersion();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.specs = object.specs?.map((e) => e) || [];
    message.apiOperations = object.apiOperations?.map((e) => e) || [];
    message.definitions = object.definitions?.map((e) => e) || [];
    message.deployments = object.deployments?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.lifecycle = (object.lifecycle !== undefined && object.lifecycle !== null)
      ? AttributeValues.fromPartial(object.lifecycle)
      : undefined;
    message.compliance = (object.compliance !== undefined && object.compliance !== null)
      ? AttributeValues.fromPartial(object.compliance)
      : undefined;
    message.accreditation = (object.accreditation !== undefined && object.accreditation !== null)
      ? AttributeValues.fromPartial(object.accreditation)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.selectedDeployment = object.selectedDeployment ?? "";
    return message;
  },
};

function createBaseVersion_AttributesEntry(): Version_AttributesEntry {
  return { key: "", value: undefined };
}

export const Version_AttributesEntry: MessageFns<Version_AttributesEntry> = {
  encode(message: Version_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Version_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Version_AttributesEntry>, I>>(base?: I): Version_AttributesEntry {
    return Version_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Version_AttributesEntry>, I>>(object: I): Version_AttributesEntry {
    const message = createBaseVersion_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSpec(): Spec {
  return {
    name: "",
    displayName: "",
    specType: undefined,
    details: undefined,
    sourceUri: "",
    createTime: undefined,
    updateTime: undefined,
    lintResponse: undefined,
    attributes: {},
    documentation: undefined,
  };
}

export const Spec: MessageFns<Spec> = {
  encode(message: Spec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.specType !== undefined) {
      AttributeValues.encode(message.specType, writer.uint32(26).fork()).join();
    }
    if (message.details !== undefined) {
      SpecDetails.encode(message.details, writer.uint32(42).fork()).join();
    }
    if (message.sourceUri !== "") {
      writer.uint32(50).string(message.sourceUri);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.lintResponse !== undefined) {
      LintResponse.encode(message.lintResponse, writer.uint32(74).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Spec_AttributesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specType = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.details = SpecDetails.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lintResponse = LintResponse.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = Spec_AttributesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.attributes[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      specType: isSet(object.specType) ? AttributeValues.fromJSON(object.specType) : undefined,
      details: isSet(object.details) ? SpecDetails.fromJSON(object.details) : undefined,
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      lintResponse: isSet(object.lintResponse) ? LintResponse.fromJSON(object.lintResponse) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
    };
  },

  toJSON(message: Spec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.specType !== undefined) {
      obj.specType = AttributeValues.toJSON(message.specType);
    }
    if (message.details !== undefined) {
      obj.details = SpecDetails.toJSON(message.details);
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.lintResponse !== undefined) {
      obj.lintResponse = LintResponse.toJSON(message.lintResponse);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spec>, I>>(base?: I): Spec {
    return Spec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spec>, I>>(object: I): Spec {
    const message = createBaseSpec();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.specType = (object.specType !== undefined && object.specType !== null)
      ? AttributeValues.fromPartial(object.specType)
      : undefined;
    message.details = (object.details !== undefined && object.details !== null)
      ? SpecDetails.fromPartial(object.details)
      : undefined;
    message.sourceUri = object.sourceUri ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.lintResponse = (object.lintResponse !== undefined && object.lintResponse !== null)
      ? LintResponse.fromPartial(object.lintResponse)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    return message;
  },
};

function createBaseSpec_AttributesEntry(): Spec_AttributesEntry {
  return { key: "", value: undefined };
}

export const Spec_AttributesEntry: MessageFns<Spec_AttributesEntry> = {
  encode(message: Spec_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spec_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpec_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spec_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Spec_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spec_AttributesEntry>, I>>(base?: I): Spec_AttributesEntry {
    return Spec_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spec_AttributesEntry>, I>>(object: I): Spec_AttributesEntry {
    const message = createBaseSpec_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDeployment(): Deployment {
  return {
    name: "",
    displayName: "",
    description: "",
    documentation: undefined,
    deploymentType: undefined,
    resourceUri: "",
    endpoints: [],
    apiVersions: [],
    createTime: undefined,
    updateTime: undefined,
    slo: undefined,
    environment: undefined,
    attributes: {},
  };
}

export const Deployment: MessageFns<Deployment> = {
  encode(message: Deployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(34).fork()).join();
    }
    if (message.deploymentType !== undefined) {
      AttributeValues.encode(message.deploymentType, writer.uint32(42).fork()).join();
    }
    if (message.resourceUri !== "") {
      writer.uint32(50).string(message.resourceUri);
    }
    for (const v of message.endpoints) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.apiVersions) {
      writer.uint32(66).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.slo !== undefined) {
      AttributeValues.encode(message.slo, writer.uint32(90).fork()).join();
    }
    if (message.environment !== undefined) {
      AttributeValues.encode(message.environment, writer.uint32(98).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Deployment_AttributesEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deploymentType = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.apiVersions.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.slo = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.environment = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = Deployment_AttributesEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.attributes[entry13.key] = entry13.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      deploymentType: isSet(object.deploymentType) ? AttributeValues.fromJSON(object.deploymentType) : undefined,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      apiVersions: globalThis.Array.isArray(object?.apiVersions)
        ? object.apiVersions.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      slo: isSet(object.slo) ? AttributeValues.fromJSON(object.slo) : undefined,
      environment: isSet(object.environment) ? AttributeValues.fromJSON(object.environment) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Deployment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.deploymentType !== undefined) {
      obj.deploymentType = AttributeValues.toJSON(message.deploymentType);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.apiVersions?.length) {
      obj.apiVersions = message.apiVersions;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.slo !== undefined) {
      obj.slo = AttributeValues.toJSON(message.slo);
    }
    if (message.environment !== undefined) {
      obj.environment = AttributeValues.toJSON(message.environment);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deployment>, I>>(base?: I): Deployment {
    return Deployment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deployment>, I>>(object: I): Deployment {
    const message = createBaseDeployment();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.deploymentType = (object.deploymentType !== undefined && object.deploymentType !== null)
      ? AttributeValues.fromPartial(object.deploymentType)
      : undefined;
    message.resourceUri = object.resourceUri ?? "";
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.apiVersions = object.apiVersions?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.slo = (object.slo !== undefined && object.slo !== null)
      ? AttributeValues.fromPartial(object.slo)
      : undefined;
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? AttributeValues.fromPartial(object.environment)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDeployment_AttributesEntry(): Deployment_AttributesEntry {
  return { key: "", value: undefined };
}

export const Deployment_AttributesEntry: MessageFns<Deployment_AttributesEntry> = {
  encode(message: Deployment_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Deployment_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deployment_AttributesEntry>, I>>(base?: I): Deployment_AttributesEntry {
    return Deployment_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deployment_AttributesEntry>, I>>(object: I): Deployment_AttributesEntry {
    const message = createBaseDeployment_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAttribute(): Attribute {
  return {
    name: "",
    displayName: "",
    description: "",
    definitionType: 0,
    scope: 0,
    dataType: 0,
    allowedValues: [],
    cardinality: 0,
    mandatory: false,
    createTime: undefined,
    updateTime: undefined,
  };
}

export const Attribute: MessageFns<Attribute> = {
  encode(message: Attribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.definitionType !== 0) {
      writer.uint32(32).int32(message.definitionType);
    }
    if (message.scope !== 0) {
      writer.uint32(40).int32(message.scope);
    }
    if (message.dataType !== 0) {
      writer.uint32(48).int32(message.dataType);
    }
    for (const v of message.allowedValues) {
      Attribute_AllowedValue.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.cardinality !== 0) {
      writer.uint32(64).int32(message.cardinality);
    }
    if (message.mandatory !== false) {
      writer.uint32(72).bool(message.mandatory);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.definitionType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.allowedValues.push(Attribute_AllowedValue.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cardinality = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.mandatory = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attribute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      definitionType: isSet(object.definitionType) ? attribute_DefinitionTypeFromJSON(object.definitionType) : 0,
      scope: isSet(object.scope) ? attribute_ScopeFromJSON(object.scope) : 0,
      dataType: isSet(object.dataType) ? attribute_DataTypeFromJSON(object.dataType) : 0,
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => Attribute_AllowedValue.fromJSON(e))
        : [],
      cardinality: isSet(object.cardinality) ? globalThis.Number(object.cardinality) : 0,
      mandatory: isSet(object.mandatory) ? globalThis.Boolean(object.mandatory) : false,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Attribute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.definitionType !== 0) {
      obj.definitionType = attribute_DefinitionTypeToJSON(message.definitionType);
    }
    if (message.scope !== 0) {
      obj.scope = attribute_ScopeToJSON(message.scope);
    }
    if (message.dataType !== 0) {
      obj.dataType = attribute_DataTypeToJSON(message.dataType);
    }
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues.map((e) => Attribute_AllowedValue.toJSON(e));
    }
    if (message.cardinality !== 0) {
      obj.cardinality = Math.round(message.cardinality);
    }
    if (message.mandatory !== false) {
      obj.mandatory = message.mandatory;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attribute>, I>>(base?: I): Attribute {
    return Attribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attribute>, I>>(object: I): Attribute {
    const message = createBaseAttribute();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.definitionType = object.definitionType ?? 0;
    message.scope = object.scope ?? 0;
    message.dataType = object.dataType ?? 0;
    message.allowedValues = object.allowedValues?.map((e) => Attribute_AllowedValue.fromPartial(e)) || [];
    message.cardinality = object.cardinality ?? 0;
    message.mandatory = object.mandatory ?? false;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseAttribute_AllowedValue(): Attribute_AllowedValue {
  return { id: "", displayName: "", description: "", immutable: false };
}

export const Attribute_AllowedValue: MessageFns<Attribute_AllowedValue> = {
  encode(message: Attribute_AllowedValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.immutable !== false) {
      writer.uint32(32).bool(message.immutable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attribute_AllowedValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttribute_AllowedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.immutable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attribute_AllowedValue {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      immutable: isSet(object.immutable) ? globalThis.Boolean(object.immutable) : false,
    };
  },

  toJSON(message: Attribute_AllowedValue): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.immutable !== false) {
      obj.immutable = message.immutable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attribute_AllowedValue>, I>>(base?: I): Attribute_AllowedValue {
    return Attribute_AllowedValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attribute_AllowedValue>, I>>(object: I): Attribute_AllowedValue {
    const message = createBaseAttribute_AllowedValue();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.immutable = object.immutable ?? false;
    return message;
  },
};

function createBaseSpecContents(): SpecContents {
  return { contents: new Uint8Array(0), mimeType: "" };
}

export const SpecContents: MessageFns<SpecContents> = {
  encode(message: SpecContents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contents.length !== 0) {
      writer.uint32(10).bytes(message.contents);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpecContents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecContents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contents = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpecContents {
    return {
      contents: isSet(object.contents) ? bytesFromBase64(object.contents) : new Uint8Array(0),
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: SpecContents): unknown {
    const obj: any = {};
    if (message.contents.length !== 0) {
      obj.contents = base64FromBytes(message.contents);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpecContents>, I>>(base?: I): SpecContents {
    return SpecContents.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpecContents>, I>>(object: I): SpecContents {
    const message = createBaseSpecContents();
    message.contents = object.contents ?? new Uint8Array(0);
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseSpecDetails(): SpecDetails {
  return { openApiSpecDetails: undefined, description: "" };
}

export const SpecDetails: MessageFns<SpecDetails> = {
  encode(message: SpecDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.openApiSpecDetails !== undefined) {
      OpenApiSpecDetails.encode(message.openApiSpecDetails, writer.uint32(18).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpecDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.openApiSpecDetails = OpenApiSpecDetails.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpecDetails {
    return {
      openApiSpecDetails: isSet(object.openApiSpecDetails)
        ? OpenApiSpecDetails.fromJSON(object.openApiSpecDetails)
        : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: SpecDetails): unknown {
    const obj: any = {};
    if (message.openApiSpecDetails !== undefined) {
      obj.openApiSpecDetails = OpenApiSpecDetails.toJSON(message.openApiSpecDetails);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpecDetails>, I>>(base?: I): SpecDetails {
    return SpecDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpecDetails>, I>>(object: I): SpecDetails {
    const message = createBaseSpecDetails();
    message.openApiSpecDetails = (object.openApiSpecDetails !== undefined && object.openApiSpecDetails !== null)
      ? OpenApiSpecDetails.fromPartial(object.openApiSpecDetails)
      : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseOpenApiSpecDetails(): OpenApiSpecDetails {
  return { format: 0, version: "", owner: undefined };
}

export const OpenApiSpecDetails: MessageFns<OpenApiSpecDetails> = {
  encode(message: OpenApiSpecDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.owner !== undefined) {
      Owner.encode(message.owner, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenApiSpecDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenApiSpecDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = Owner.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenApiSpecDetails {
    return {
      format: isSet(object.format) ? openApiSpecDetails_FormatFromJSON(object.format) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      owner: isSet(object.owner) ? Owner.fromJSON(object.owner) : undefined,
    };
  },

  toJSON(message: OpenApiSpecDetails): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = openApiSpecDetails_FormatToJSON(message.format);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.owner !== undefined) {
      obj.owner = Owner.toJSON(message.owner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenApiSpecDetails>, I>>(base?: I): OpenApiSpecDetails {
    return OpenApiSpecDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenApiSpecDetails>, I>>(object: I): OpenApiSpecDetails {
    const message = createBaseOpenApiSpecDetails();
    message.format = object.format ?? 0;
    message.version = object.version ?? "";
    message.owner = (object.owner !== undefined && object.owner !== null) ? Owner.fromPartial(object.owner) : undefined;
    return message;
  },
};

function createBaseOwner(): Owner {
  return { displayName: "", email: "" };
}

export const Owner: MessageFns<Owner> = {
  encode(message: Owner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Owner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Owner {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: Owner): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Owner>, I>>(base?: I): Owner {
    return Owner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Owner>, I>>(object: I): Owner {
    const message = createBaseOwner();
    message.displayName = object.displayName ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseDocumentation(): Documentation {
  return { externalUri: "" };
}

export const Documentation: MessageFns<Documentation> = {
  encode(message: Documentation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalUri !== "") {
      writer.uint32(10).string(message.externalUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Documentation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Documentation {
    return { externalUri: isSet(object.externalUri) ? globalThis.String(object.externalUri) : "" };
  },

  toJSON(message: Documentation): unknown {
    const obj: any = {};
    if (message.externalUri !== "") {
      obj.externalUri = message.externalUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Documentation>, I>>(base?: I): Documentation {
    return Documentation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Documentation>, I>>(object: I): Documentation {
    const message = createBaseDocumentation();
    message.externalUri = object.externalUri ?? "";
    return message;
  },
};

function createBaseAttributeValues(): AttributeValues {
  return { enumValues: undefined, stringValues: undefined, jsonValues: undefined, attribute: "" };
}

export const AttributeValues: MessageFns<AttributeValues> = {
  encode(message: AttributeValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enumValues !== undefined) {
      AttributeValues_EnumAttributeValues.encode(message.enumValues, writer.uint32(18).fork()).join();
    }
    if (message.stringValues !== undefined) {
      AttributeValues_StringAttributeValues.encode(message.stringValues, writer.uint32(26).fork()).join();
    }
    if (message.jsonValues !== undefined) {
      AttributeValues_StringAttributeValues.encode(message.jsonValues, writer.uint32(34).fork()).join();
    }
    if (message.attribute !== "") {
      writer.uint32(10).string(message.attribute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enumValues = AttributeValues_EnumAttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stringValues = AttributeValues_StringAttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jsonValues = AttributeValues_StringAttributeValues.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValues {
    return {
      enumValues: isSet(object.enumValues)
        ? AttributeValues_EnumAttributeValues.fromJSON(object.enumValues)
        : undefined,
      stringValues: isSet(object.stringValues)
        ? AttributeValues_StringAttributeValues.fromJSON(object.stringValues)
        : undefined,
      jsonValues: isSet(object.jsonValues)
        ? AttributeValues_StringAttributeValues.fromJSON(object.jsonValues)
        : undefined,
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
    };
  },

  toJSON(message: AttributeValues): unknown {
    const obj: any = {};
    if (message.enumValues !== undefined) {
      obj.enumValues = AttributeValues_EnumAttributeValues.toJSON(message.enumValues);
    }
    if (message.stringValues !== undefined) {
      obj.stringValues = AttributeValues_StringAttributeValues.toJSON(message.stringValues);
    }
    if (message.jsonValues !== undefined) {
      obj.jsonValues = AttributeValues_StringAttributeValues.toJSON(message.jsonValues);
    }
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeValues>, I>>(base?: I): AttributeValues {
    return AttributeValues.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeValues>, I>>(object: I): AttributeValues {
    const message = createBaseAttributeValues();
    message.enumValues = (object.enumValues !== undefined && object.enumValues !== null)
      ? AttributeValues_EnumAttributeValues.fromPartial(object.enumValues)
      : undefined;
    message.stringValues = (object.stringValues !== undefined && object.stringValues !== null)
      ? AttributeValues_StringAttributeValues.fromPartial(object.stringValues)
      : undefined;
    message.jsonValues = (object.jsonValues !== undefined && object.jsonValues !== null)
      ? AttributeValues_StringAttributeValues.fromPartial(object.jsonValues)
      : undefined;
    message.attribute = object.attribute ?? "";
    return message;
  },
};

function createBaseAttributeValues_EnumAttributeValues(): AttributeValues_EnumAttributeValues {
  return { values: [] };
}

export const AttributeValues_EnumAttributeValues: MessageFns<AttributeValues_EnumAttributeValues> = {
  encode(message: AttributeValues_EnumAttributeValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Attribute_AllowedValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValues_EnumAttributeValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValues_EnumAttributeValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(Attribute_AllowedValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValues_EnumAttributeValues {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => Attribute_AllowedValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AttributeValues_EnumAttributeValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Attribute_AllowedValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeValues_EnumAttributeValues>, I>>(
    base?: I,
  ): AttributeValues_EnumAttributeValues {
    return AttributeValues_EnumAttributeValues.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeValues_EnumAttributeValues>, I>>(
    object: I,
  ): AttributeValues_EnumAttributeValues {
    const message = createBaseAttributeValues_EnumAttributeValues();
    message.values = object.values?.map((e) => Attribute_AllowedValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAttributeValues_StringAttributeValues(): AttributeValues_StringAttributeValues {
  return { values: [] };
}

export const AttributeValues_StringAttributeValues: MessageFns<AttributeValues_StringAttributeValues> = {
  encode(message: AttributeValues_StringAttributeValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValues_StringAttributeValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValues_StringAttributeValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValues_StringAttributeValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AttributeValues_StringAttributeValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeValues_StringAttributeValues>, I>>(
    base?: I,
  ): AttributeValues_StringAttributeValues {
    return AttributeValues_StringAttributeValues.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeValues_StringAttributeValues>, I>>(
    object: I,
  ): AttributeValues_StringAttributeValues {
    const message = createBaseAttributeValues_StringAttributeValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseDependency(): Dependency {
  return {
    name: "",
    consumer: undefined,
    supplier: undefined,
    state: 0,
    description: "",
    discoveryMode: 0,
    errorDetail: undefined,
    createTime: undefined,
    updateTime: undefined,
    attributes: {},
  };
}

export const Dependency: MessageFns<Dependency> = {
  encode(message: Dependency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.consumer !== undefined) {
      DependencyEntityReference.encode(message.consumer, writer.uint32(18).fork()).join();
    }
    if (message.supplier !== undefined) {
      DependencyEntityReference.encode(message.supplier, writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.discoveryMode !== 0) {
      writer.uint32(48).int32(message.discoveryMode);
    }
    if (message.errorDetail !== undefined) {
      DependencyErrorDetail.encode(message.errorDetail, writer.uint32(58).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Dependency_AttributesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dependency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumer = DependencyEntityReference.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.supplier = DependencyEntityReference.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.discoveryMode = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.errorDetail = DependencyErrorDetail.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = Dependency_AttributesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.attributes[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dependency {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      consumer: isSet(object.consumer) ? DependencyEntityReference.fromJSON(object.consumer) : undefined,
      supplier: isSet(object.supplier) ? DependencyEntityReference.fromJSON(object.supplier) : undefined,
      state: isSet(object.state) ? dependency_StateFromJSON(object.state) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      discoveryMode: isSet(object.discoveryMode) ? dependency_DiscoveryModeFromJSON(object.discoveryMode) : 0,
      errorDetail: isSet(object.errorDetail) ? DependencyErrorDetail.fromJSON(object.errorDetail) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Dependency): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.consumer !== undefined) {
      obj.consumer = DependencyEntityReference.toJSON(message.consumer);
    }
    if (message.supplier !== undefined) {
      obj.supplier = DependencyEntityReference.toJSON(message.supplier);
    }
    if (message.state !== 0) {
      obj.state = dependency_StateToJSON(message.state);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.discoveryMode !== 0) {
      obj.discoveryMode = dependency_DiscoveryModeToJSON(message.discoveryMode);
    }
    if (message.errorDetail !== undefined) {
      obj.errorDetail = DependencyErrorDetail.toJSON(message.errorDetail);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dependency>, I>>(base?: I): Dependency {
    return Dependency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dependency>, I>>(object: I): Dependency {
    const message = createBaseDependency();
    message.name = object.name ?? "";
    message.consumer = (object.consumer !== undefined && object.consumer !== null)
      ? DependencyEntityReference.fromPartial(object.consumer)
      : undefined;
    message.supplier = (object.supplier !== undefined && object.supplier !== null)
      ? DependencyEntityReference.fromPartial(object.supplier)
      : undefined;
    message.state = object.state ?? 0;
    message.description = object.description ?? "";
    message.discoveryMode = object.discoveryMode ?? 0;
    message.errorDetail = (object.errorDetail !== undefined && object.errorDetail !== null)
      ? DependencyErrorDetail.fromPartial(object.errorDetail)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDependency_AttributesEntry(): Dependency_AttributesEntry {
  return { key: "", value: undefined };
}

export const Dependency_AttributesEntry: MessageFns<Dependency_AttributesEntry> = {
  encode(message: Dependency_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dependency_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependency_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dependency_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Dependency_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dependency_AttributesEntry>, I>>(base?: I): Dependency_AttributesEntry {
    return Dependency_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dependency_AttributesEntry>, I>>(object: I): Dependency_AttributesEntry {
    const message = createBaseDependency_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDependencyEntityReference(): DependencyEntityReference {
  return { operationResourceName: undefined, externalApiResourceName: undefined, displayName: "" };
}

export const DependencyEntityReference: MessageFns<DependencyEntityReference> = {
  encode(message: DependencyEntityReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationResourceName !== undefined) {
      writer.uint32(18).string(message.operationResourceName);
    }
    if (message.externalApiResourceName !== undefined) {
      writer.uint32(26).string(message.externalApiResourceName);
    }
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DependencyEntityReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependencyEntityReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operationResourceName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalApiResourceName = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependencyEntityReference {
    return {
      operationResourceName: isSet(object.operationResourceName)
        ? globalThis.String(object.operationResourceName)
        : undefined,
      externalApiResourceName: isSet(object.externalApiResourceName)
        ? globalThis.String(object.externalApiResourceName)
        : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: DependencyEntityReference): unknown {
    const obj: any = {};
    if (message.operationResourceName !== undefined) {
      obj.operationResourceName = message.operationResourceName;
    }
    if (message.externalApiResourceName !== undefined) {
      obj.externalApiResourceName = message.externalApiResourceName;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DependencyEntityReference>, I>>(base?: I): DependencyEntityReference {
    return DependencyEntityReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DependencyEntityReference>, I>>(object: I): DependencyEntityReference {
    const message = createBaseDependencyEntityReference();
    message.operationResourceName = object.operationResourceName ?? undefined;
    message.externalApiResourceName = object.externalApiResourceName ?? undefined;
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseDependencyErrorDetail(): DependencyErrorDetail {
  return { error: 0, errorTime: undefined };
}

export const DependencyErrorDetail: MessageFns<DependencyErrorDetail> = {
  encode(message: DependencyErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== 0) {
      writer.uint32(8).int32(message.error);
    }
    if (message.errorTime !== undefined) {
      Timestamp.encode(toTimestamp(message.errorTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DependencyErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependencyErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.error = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependencyErrorDetail {
    return {
      error: isSet(object.error) ? dependencyErrorDetail_ErrorFromJSON(object.error) : 0,
      errorTime: isSet(object.errorTime) ? fromJsonTimestamp(object.errorTime) : undefined,
    };
  },

  toJSON(message: DependencyErrorDetail): unknown {
    const obj: any = {};
    if (message.error !== 0) {
      obj.error = dependencyErrorDetail_ErrorToJSON(message.error);
    }
    if (message.errorTime !== undefined) {
      obj.errorTime = message.errorTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DependencyErrorDetail>, I>>(base?: I): DependencyErrorDetail {
    return DependencyErrorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DependencyErrorDetail>, I>>(object: I): DependencyErrorDetail {
    const message = createBaseDependencyErrorDetail();
    message.error = object.error ?? 0;
    message.errorTime = object.errorTime ?? undefined;
    return message;
  },
};

function createBaseLintResponse(): LintResponse {
  return { issues: [], summary: [], state: 0, source: "", linter: 0, createTime: undefined };
}

export const LintResponse: MessageFns<LintResponse> = {
  encode(message: LintResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.issues) {
      Issue.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.summary) {
      LintResponse_SummaryEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    if (message.linter !== 0) {
      writer.uint32(40).int32(message.linter);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LintResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLintResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issues.push(Issue.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary.push(LintResponse_SummaryEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.linter = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LintResponse {
    return {
      issues: globalThis.Array.isArray(object?.issues) ? object.issues.map((e: any) => Issue.fromJSON(e)) : [],
      summary: globalThis.Array.isArray(object?.summary)
        ? object.summary.map((e: any) => LintResponse_SummaryEntry.fromJSON(e))
        : [],
      state: isSet(object.state) ? lintStateFromJSON(object.state) : 0,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      linter: isSet(object.linter) ? linterFromJSON(object.linter) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: LintResponse): unknown {
    const obj: any = {};
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => Issue.toJSON(e));
    }
    if (message.summary?.length) {
      obj.summary = message.summary.map((e) => LintResponse_SummaryEntry.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = lintStateToJSON(message.state);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.linter !== 0) {
      obj.linter = linterToJSON(message.linter);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LintResponse>, I>>(base?: I): LintResponse {
    return LintResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LintResponse>, I>>(object: I): LintResponse {
    const message = createBaseLintResponse();
    message.issues = object.issues?.map((e) => Issue.fromPartial(e)) || [];
    message.summary = object.summary?.map((e) => LintResponse_SummaryEntry.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    message.source = object.source ?? "";
    message.linter = object.linter ?? 0;
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseLintResponse_SummaryEntry(): LintResponse_SummaryEntry {
  return { severity: 0, count: 0 };
}

export const LintResponse_SummaryEntry: MessageFns<LintResponse_SummaryEntry> = {
  encode(message: LintResponse_SummaryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.severity !== 0) {
      writer.uint32(8).int32(message.severity);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LintResponse_SummaryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLintResponse_SummaryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LintResponse_SummaryEntry {
    return {
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: LintResponse_SummaryEntry): unknown {
    const obj: any = {};
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LintResponse_SummaryEntry>, I>>(base?: I): LintResponse_SummaryEntry {
    return LintResponse_SummaryEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LintResponse_SummaryEntry>, I>>(object: I): LintResponse_SummaryEntry {
    const message = createBaseLintResponse_SummaryEntry();
    message.severity = object.severity ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseIssue(): Issue {
  return { code: "", path: [], message: "", severity: 0, range: undefined };
}

export const Issue: MessageFns<Issue> = {
  encode(message: Issue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    for (const v of message.path) {
      writer.uint32(18).string(v!);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.severity !== 0) {
      writer.uint32(32).int32(message.severity);
    }
    if (message.range !== undefined) {
      Range.encode(message.range, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Issue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.range = Range.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Issue {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [],
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      range: isSet(object.range) ? Range.fromJSON(object.range) : undefined,
    };
  },

  toJSON(message: Issue): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.path?.length) {
      obj.path = message.path;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.range !== undefined) {
      obj.range = Range.toJSON(message.range);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Issue>, I>>(base?: I): Issue {
    return Issue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Issue>, I>>(object: I): Issue {
    const message = createBaseIssue();
    message.code = object.code ?? "";
    message.path = object.path?.map((e) => e) || [];
    message.message = object.message ?? "";
    message.severity = object.severity ?? 0;
    message.range = (object.range !== undefined && object.range !== null) ? Range.fromPartial(object.range) : undefined;
    return message;
  },
};

function createBaseRange(): Range {
  return { start: undefined, end: undefined };
}

export const Range: MessageFns<Range> = {
  encode(message: Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      Point.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      Point.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.start = Point.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.end = Point.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Range {
    return {
      start: isSet(object.start) ? Point.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? Point.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: Range): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = Point.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = Point.toJSON(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Range>, I>>(base?: I): Range {
    return Range.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Range>, I>>(object: I): Range {
    const message = createBaseRange();
    message.start = (object.start !== undefined && object.start !== null) ? Point.fromPartial(object.start) : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? Point.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBasePoint(): Point {
  return { line: 0, character: 0 };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line !== 0) {
      writer.uint32(8).int32(message.line);
    }
    if (message.character !== 0) {
      writer.uint32(16).int32(message.character);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.line = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.character = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      character: isSet(object.character) ? globalThis.Number(object.character) : 0,
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.character !== 0) {
      obj.character = Math.round(message.character);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point>, I>>(base?: I): Point {
    return Point.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point>, I>>(object: I): Point {
    const message = createBasePoint();
    message.line = object.line ?? 0;
    message.character = object.character ?? 0;
    return message;
  },
};

function createBaseApiHubInstance(): ApiHubInstance {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    stateMessage: "",
    config: undefined,
    labels: {},
    description: "",
  };
}

export const ApiHubInstance: MessageFns<ApiHubInstance> = {
  encode(message: ApiHubInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.stateMessage !== "") {
      writer.uint32(42).string(message.stateMessage);
    }
    if (message.config !== undefined) {
      ApiHubInstance_Config.encode(message.config, writer.uint32(50).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ApiHubInstance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiHubInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiHubInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stateMessage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.config = ApiHubInstance_Config.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = ApiHubInstance_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiHubInstance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? apiHubInstance_StateFromJSON(object.state) : 0,
      stateMessage: isSet(object.stateMessage) ? globalThis.String(object.stateMessage) : "",
      config: isSet(object.config) ? ApiHubInstance_Config.fromJSON(object.config) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ApiHubInstance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = apiHubInstance_StateToJSON(message.state);
    }
    if (message.stateMessage !== "") {
      obj.stateMessage = message.stateMessage;
    }
    if (message.config !== undefined) {
      obj.config = ApiHubInstance_Config.toJSON(message.config);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiHubInstance>, I>>(base?: I): ApiHubInstance {
    return ApiHubInstance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiHubInstance>, I>>(object: I): ApiHubInstance {
    const message = createBaseApiHubInstance();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.stateMessage = object.stateMessage ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? ApiHubInstance_Config.fromPartial(object.config)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseApiHubInstance_Config(): ApiHubInstance_Config {
  return { cmekKeyName: "" };
}

export const ApiHubInstance_Config: MessageFns<ApiHubInstance_Config> = {
  encode(message: ApiHubInstance_Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cmekKeyName !== "") {
      writer.uint32(10).string(message.cmekKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiHubInstance_Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiHubInstance_Config();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cmekKeyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiHubInstance_Config {
    return { cmekKeyName: isSet(object.cmekKeyName) ? globalThis.String(object.cmekKeyName) : "" };
  },

  toJSON(message: ApiHubInstance_Config): unknown {
    const obj: any = {};
    if (message.cmekKeyName !== "") {
      obj.cmekKeyName = message.cmekKeyName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiHubInstance_Config>, I>>(base?: I): ApiHubInstance_Config {
    return ApiHubInstance_Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiHubInstance_Config>, I>>(object: I): ApiHubInstance_Config {
    const message = createBaseApiHubInstance_Config();
    message.cmekKeyName = object.cmekKeyName ?? "";
    return message;
  },
};

function createBaseApiHubInstance_LabelsEntry(): ApiHubInstance_LabelsEntry {
  return { key: "", value: "" };
}

export const ApiHubInstance_LabelsEntry: MessageFns<ApiHubInstance_LabelsEntry> = {
  encode(message: ApiHubInstance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiHubInstance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiHubInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiHubInstance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiHubInstance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiHubInstance_LabelsEntry>, I>>(base?: I): ApiHubInstance_LabelsEntry {
    return ApiHubInstance_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiHubInstance_LabelsEntry>, I>>(object: I): ApiHubInstance_LabelsEntry {
    const message = createBaseApiHubInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExternalApi(): ExternalApi {
  return {
    name: "",
    displayName: "",
    description: "",
    endpoints: [],
    paths: [],
    documentation: undefined,
    attributes: {},
    createTime: undefined,
    updateTime: undefined,
  };
}

export const ExternalApi: MessageFns<ExternalApi> = {
  encode(message: ExternalApi, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.endpoints) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.paths) {
      writer.uint32(42).string(v!);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(50).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      ExternalApi_AttributesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalApi {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalApi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paths.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = ExternalApi_AttributesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.attributes[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalApi {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [],
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: ExternalApi): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalApi>, I>>(base?: I): ExternalApi {
    return ExternalApi.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalApi>, I>>(object: I): ExternalApi {
    const message = createBaseExternalApi();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.paths = object.paths?.map((e) => e) || [];
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseExternalApi_AttributesEntry(): ExternalApi_AttributesEntry {
  return { key: "", value: undefined };
}

export const ExternalApi_AttributesEntry: MessageFns<ExternalApi_AttributesEntry> = {
  encode(message: ExternalApi_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalApi_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalApi_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalApi_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExternalApi_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalApi_AttributesEntry>, I>>(base?: I): ExternalApi_AttributesEntry {
    return ExternalApi_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalApi_AttributesEntry>, I>>(object: I): ExternalApi_AttributesEntry {
    const message = createBaseExternalApi_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseHostProjectRegistration(): HostProjectRegistration {
  return { name: "", gcpProject: "", createTime: undefined };
}

export const HostProjectRegistration: MessageFns<HostProjectRegistration> = {
  encode(message: HostProjectRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.gcpProject !== "") {
      writer.uint32(18).string(message.gcpProject);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostProjectRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostProjectRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gcpProject = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostProjectRegistration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      gcpProject: isSet(object.gcpProject) ? globalThis.String(object.gcpProject) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: HostProjectRegistration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.gcpProject !== "") {
      obj.gcpProject = message.gcpProject;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HostProjectRegistration>, I>>(base?: I): HostProjectRegistration {
    return HostProjectRegistration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HostProjectRegistration>, I>>(object: I): HostProjectRegistration {
    const message = createBaseHostProjectRegistration();
    message.name = object.name ?? "";
    message.gcpProject = object.gcpProject ?? "";
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseRuntimeProjectAttachment(): RuntimeProjectAttachment {
  return { name: "", runtimeProject: "", createTime: undefined };
}

export const RuntimeProjectAttachment: MessageFns<RuntimeProjectAttachment> = {
  encode(message: RuntimeProjectAttachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.runtimeProject !== "") {
      writer.uint32(18).string(message.runtimeProject);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeProjectAttachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeProjectAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtimeProject = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeProjectAttachment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      runtimeProject: isSet(object.runtimeProject) ? globalThis.String(object.runtimeProject) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: RuntimeProjectAttachment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.runtimeProject !== "") {
      obj.runtimeProject = message.runtimeProject;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeProjectAttachment>, I>>(base?: I): RuntimeProjectAttachment {
    return RuntimeProjectAttachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeProjectAttachment>, I>>(object: I): RuntimeProjectAttachment {
    const message = createBaseRuntimeProjectAttachment();
    message.name = object.name ?? "";
    message.runtimeProject = object.runtimeProject ?? "";
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseApiEventData(): ApiEventData {
  return { payload: undefined };
}

export const ApiEventData: MessageFns<ApiEventData> = {
  encode(message: ApiEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Api.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Api.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiEventData {
    return { payload: isSet(object.payload) ? Api.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ApiEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Api.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiEventData>, I>>(base?: I): ApiEventData {
    return ApiEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiEventData>, I>>(object: I): ApiEventData {
    const message = createBaseApiEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Api.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseVersionEventData(): VersionEventData {
  return { payload: undefined };
}

export const VersionEventData: MessageFns<VersionEventData> = {
  encode(message: VersionEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Version.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Version.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionEventData {
    return { payload: isSet(object.payload) ? Version.fromJSON(object.payload) : undefined };
  },

  toJSON(message: VersionEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Version.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionEventData>, I>>(base?: I): VersionEventData {
    return VersionEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionEventData>, I>>(object: I): VersionEventData {
    const message = createBaseVersionEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Version.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseSpecEventData(): SpecEventData {
  return { payload: undefined };
}

export const SpecEventData: MessageFns<SpecEventData> = {
  encode(message: SpecEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Spec.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpecEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Spec.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpecEventData {
    return { payload: isSet(object.payload) ? Spec.fromJSON(object.payload) : undefined };
  },

  toJSON(message: SpecEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Spec.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpecEventData>, I>>(base?: I): SpecEventData {
    return SpecEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpecEventData>, I>>(object: I): SpecEventData {
    const message = createBaseSpecEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Spec.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseDeploymentEventData(): DeploymentEventData {
  return { payload: undefined };
}

export const DeploymentEventData: MessageFns<DeploymentEventData> = {
  encode(message: DeploymentEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Deployment.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeploymentEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeploymentEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Deployment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeploymentEventData {
    return { payload: isSet(object.payload) ? Deployment.fromJSON(object.payload) : undefined };
  },

  toJSON(message: DeploymentEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Deployment.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeploymentEventData>, I>>(base?: I): DeploymentEventData {
    return DeploymentEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeploymentEventData>, I>>(object: I): DeploymentEventData {
    const message = createBaseDeploymentEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Deployment.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseAttributeEventData(): AttributeEventData {
  return { payload: undefined };
}

export const AttributeEventData: MessageFns<AttributeEventData> = {
  encode(message: AttributeEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Attribute.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Attribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeEventData {
    return { payload: isSet(object.payload) ? Attribute.fromJSON(object.payload) : undefined };
  },

  toJSON(message: AttributeEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Attribute.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeEventData>, I>>(base?: I): AttributeEventData {
    return AttributeEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeEventData>, I>>(object: I): AttributeEventData {
    const message = createBaseAttributeEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Attribute.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseExternalApiEventData(): ExternalApiEventData {
  return { payload: undefined };
}

export const ExternalApiEventData: MessageFns<ExternalApiEventData> = {
  encode(message: ExternalApiEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ExternalApi.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalApiEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalApiEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ExternalApi.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalApiEventData {
    return { payload: isSet(object.payload) ? ExternalApi.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ExternalApiEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ExternalApi.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalApiEventData>, I>>(base?: I): ExternalApiEventData {
    return ExternalApiEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalApiEventData>, I>>(object: I): ExternalApiEventData {
    const message = createBaseExternalApiEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ExternalApi.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseDependencyEventData(): DependencyEventData {
  return { payload: undefined };
}

export const DependencyEventData: MessageFns<DependencyEventData> = {
  encode(message: DependencyEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Dependency.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DependencyEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependencyEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Dependency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependencyEventData {
    return { payload: isSet(object.payload) ? Dependency.fromJSON(object.payload) : undefined };
  },

  toJSON(message: DependencyEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Dependency.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DependencyEventData>, I>>(base?: I): DependencyEventData {
    return DependencyEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DependencyEventData>, I>>(object: I): DependencyEventData {
    const message = createBaseDependencyEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Dependency.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseHostProjectRegistrationEventData(): HostProjectRegistrationEventData {
  return { payload: undefined };
}

export const HostProjectRegistrationEventData: MessageFns<HostProjectRegistrationEventData> = {
  encode(message: HostProjectRegistrationEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      HostProjectRegistration.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostProjectRegistrationEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostProjectRegistrationEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = HostProjectRegistration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostProjectRegistrationEventData {
    return { payload: isSet(object.payload) ? HostProjectRegistration.fromJSON(object.payload) : undefined };
  },

  toJSON(message: HostProjectRegistrationEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = HostProjectRegistration.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HostProjectRegistrationEventData>, I>>(
    base?: I,
  ): HostProjectRegistrationEventData {
    return HostProjectRegistrationEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HostProjectRegistrationEventData>, I>>(
    object: I,
  ): HostProjectRegistrationEventData {
    const message = createBaseHostProjectRegistrationEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? HostProjectRegistration.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseApiHubInstanceEventData(): ApiHubInstanceEventData {
  return { payload: undefined };
}

export const ApiHubInstanceEventData: MessageFns<ApiHubInstanceEventData> = {
  encode(message: ApiHubInstanceEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ApiHubInstance.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiHubInstanceEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiHubInstanceEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ApiHubInstance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiHubInstanceEventData {
    return { payload: isSet(object.payload) ? ApiHubInstance.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ApiHubInstanceEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ApiHubInstance.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiHubInstanceEventData>, I>>(base?: I): ApiHubInstanceEventData {
    return ApiHubInstanceEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiHubInstanceEventData>, I>>(object: I): ApiHubInstanceEventData {
    const message = createBaseApiHubInstanceEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ApiHubInstance.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseRuntimeProjectAttachmentEventData(): RuntimeProjectAttachmentEventData {
  return { payload: undefined };
}

export const RuntimeProjectAttachmentEventData: MessageFns<RuntimeProjectAttachmentEventData> = {
  encode(message: RuntimeProjectAttachmentEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      RuntimeProjectAttachment.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeProjectAttachmentEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeProjectAttachmentEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = RuntimeProjectAttachment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeProjectAttachmentEventData {
    return { payload: isSet(object.payload) ? RuntimeProjectAttachment.fromJSON(object.payload) : undefined };
  },

  toJSON(message: RuntimeProjectAttachmentEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = RuntimeProjectAttachment.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeProjectAttachmentEventData>, I>>(
    base?: I,
  ): RuntimeProjectAttachmentEventData {
    return RuntimeProjectAttachmentEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeProjectAttachmentEventData>, I>>(
    object: I,
  ): RuntimeProjectAttachmentEventData {
    const message = createBaseRuntimeProjectAttachmentEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? RuntimeProjectAttachment.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
