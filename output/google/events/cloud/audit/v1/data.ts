// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/audit/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { MonitoredResource } from "../../../../api/monitored_resource";
import { Struct } from "../../../../protobuf/struct";
import { Timestamp } from "../../../../protobuf/timestamp";
import {
  AttributeContext_Peer,
  AttributeContext_Request,
  AttributeContext_Resource,
} from "../../../../rpc/context/attribute_context";
import { Status } from "../../../../rpc/status";

export const protobufPackage = "google.events.cloud.audit.v1";

/**
 * The severity of the event described in a log entry, expressed as one of the
 * standard severity levels listed below.  For your reference, the levels are
 * assigned the listed numeric values. The effect of using numeric values other
 * than those listed is undefined.
 * Copied from
 * https://github.com/googleapis/googleapis/blob/master/google/logging/type/log_severity.proto
 */
export enum LogSeverity {
  /** DEFAULT - (0) The log entry has no assigned severity level. */
  DEFAULT = 0,
  /** DEBUG - (100) Debug or trace information. */
  DEBUG = 100,
  /** INFO - (200) Routine information, such as ongoing status or performance. */
  INFO = 200,
  /**
   * NOTICE - (300) Normal but significant events, such as start up, shut down, or
   * a configuration change.
   */
  NOTICE = 300,
  /** WARNING - (400) Warning events might cause problems. */
  WARNING = 400,
  /** ERROR - (500) Error events are likely to cause problems. */
  ERROR = 500,
  /** CRITICAL - (600) Critical events cause more severe problems or outages. */
  CRITICAL = 600,
  /** ALERT - (700) A person must take an action immediately. */
  ALERT = 700,
  /** EMERGENCY - (800) One or more systems are unusable. */
  EMERGENCY = 800,
  UNRECOGNIZED = -1,
}

export function logSeverityFromJSON(object: any): LogSeverity {
  switch (object) {
    case 0:
    case "DEFAULT":
      return LogSeverity.DEFAULT;
    case 100:
    case "DEBUG":
      return LogSeverity.DEBUG;
    case 200:
    case "INFO":
      return LogSeverity.INFO;
    case 300:
    case "NOTICE":
      return LogSeverity.NOTICE;
    case 400:
    case "WARNING":
      return LogSeverity.WARNING;
    case 500:
    case "ERROR":
      return LogSeverity.ERROR;
    case 600:
    case "CRITICAL":
      return LogSeverity.CRITICAL;
    case 700:
    case "ALERT":
      return LogSeverity.ALERT;
    case 800:
    case "EMERGENCY":
      return LogSeverity.EMERGENCY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogSeverity.UNRECOGNIZED;
  }
}

export function logSeverityToJSON(object: LogSeverity): string {
  switch (object) {
    case LogSeverity.DEFAULT:
      return "DEFAULT";
    case LogSeverity.DEBUG:
      return "DEBUG";
    case LogSeverity.INFO:
      return "INFO";
    case LogSeverity.NOTICE:
      return "NOTICE";
    case LogSeverity.WARNING:
      return "WARNING";
    case LogSeverity.ERROR:
      return "ERROR";
    case LogSeverity.CRITICAL:
      return "CRITICAL";
    case LogSeverity.ALERT:
      return "ALERT";
    case LogSeverity.EMERGENCY:
      return "EMERGENCY";
    case LogSeverity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The data within all Cloud Audit Logs log entry events. */
export interface LogEntryData {
  /** The resource name of the log to which this log entry belongs. */
  logName: string;
  /**
   * The monitored resource that produced this log entry.
   *
   * Example: a log entry that reports a database error would be associated with
   * the monitored resource designating the particular database that reported
   * the error.
   */
  resource?:
    | MonitoredResource
    | undefined;
  /**
   * The log entry payload, which is always an AuditLog for Cloud Audit Log
   * events.
   */
  protoPayload?:
    | AuditLog
    | undefined;
  /** A unique identifier for the log entry. */
  insertId: string;
  /**
   * A set of user-defined (key, value) data that provides additional
   * information about the log entry.
   */
  labels: { [key: string]: string };
  /**
   * Information about an operation associated with the log entry, if
   * applicable.
   */
  operation?:
    | LogEntryOperation
    | undefined;
  /** The time the event described by the log entry occurred. */
  timestamp?:
    | Date
    | undefined;
  /** The time the log entry was received by Logging. */
  receiveTimestamp?:
    | Date
    | undefined;
  /** The severity of the log entry. */
  severity: LogSeverity;
  /**
   * Resource name of the trace associated with the log entry, if any. If it
   * contains a relative resource name, the name is assumed to be relative to
   * `//tracing.googleapis.com`. Example:
   * `projects/my-projectid/traces/06796866738c859f2f19b7cfb3214824`
   */
  trace: string;
  /**
   * The span ID within the trace associated with the log entry, if any.
   *
   * For Trace spans, this is the same format that the Trace API v2 uses: a
   * 16-character hexadecimal encoding of an 8-byte array, such as
   * `000000000000004a`.
   */
  spanId: string;
  /**
   * Information indicating this LogEntry is part of a sequence of multiple logs
   * split from a single LogEntry.
   */
  split?: LogSplit | undefined;
}

export interface LogEntryData_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Additional information about a potentially long-running operation with which
 * a log entry is associated.
 */
export interface LogEntryOperation {
  /**
   * An arbitrary operation identifier. Log entries with the same
   * identifier are assumed to be part of the same operation.
   */
  id: string;
  /**
   * An arbitrary producer identifier. The combination of `id` and
   * `producer` must be globally unique. Examples for `producer`:
   * `"MyDivision.MyBigCompany.com"`, `"github.com/MyProject/MyApplication"`.
   */
  producer: string;
  /** True if this is the first log entry in the operation. */
  first: boolean;
  /** True if this is the last log entry in the operation. */
  last: boolean;
}

/**
 * Common audit log format for Google Cloud Platform API operations.
 * Copied from
 * https://github.com/googleapis/googleapis/blob/master/google/cloud/audit/audit_log.proto,
 * but changing service_data from Any to Struct.
 */
export interface AuditLog {
  /**
   * The name of the API service performing the operation. For example,
   * `"datastore.googleapis.com"`.
   */
  serviceName: string;
  /**
   * The name of the service method or operation.
   * For API calls, this should be the name of the API method.
   * For example,
   *
   *     "google.datastore.v1.Datastore.RunQuery"
   *     "google.logging.v1.LoggingService.DeleteLog"
   */
  methodName: string;
  /**
   * The resource or collection that is the target of the operation.
   * The name is a scheme-less URI, not including the API service name.
   * For example:
   *
   *     "shelves/SHELF_ID/books"
   *     "shelves/SHELF_ID/books/BOOK_ID"
   */
  resourceName: string;
  /** The resource location information. */
  resourceLocation?:
    | ResourceLocation
    | undefined;
  /**
   * The resource's original state before mutation. Present only for
   * operations which have successfully modified the targeted resource(s).
   * In general, this field should contain all changed fields, except those
   * that are already been included in `request`, `response`, `metadata` or
   * `service_data` fields.
   * When the JSON object represented here has a proto equivalent,
   * the proto name will be indicated in the `@type` property.
   */
  resourceOriginalState?:
    | { [key: string]: any }
    | undefined;
  /**
   * The number of items returned from a List or Query API method,
   * if applicable.
   */
  numResponseItems: Long;
  /** The status of the overall operation. */
  status?:
    | Status
    | undefined;
  /** Authentication information. */
  authenticationInfo?:
    | AuthenticationInfo
    | undefined;
  /**
   * Authorization information. If there are multiple
   * resources or permissions involved, then there is
   * one AuthorizationInfo element for each {resource, permission} tuple.
   */
  authorizationInfo: AuthorizationInfo[];
  /** Metadata about the operation. */
  requestMetadata?:
    | RequestMetadata
    | undefined;
  /**
   * The operation request. This may not include all request parameters,
   * such as those that are too large, privacy-sensitive, or duplicated
   * elsewhere in the log record.
   * It should never include user-generated data, such as file contents.
   * When the JSON object represented here has a proto equivalent, the proto
   * name will be indicated in the `@type` property.
   */
  request?:
    | { [key: string]: any }
    | undefined;
  /**
   * The operation response. This may not include all response elements,
   * such as those that are too large, privacy-sensitive, or duplicated
   * elsewhere in the log record.
   * It should never include user-generated data, such as file contents.
   * When the JSON object represented here has a proto equivalent, the proto
   * name will be indicated in the `@type` property.
   */
  response?:
    | { [key: string]: any }
    | undefined;
  /**
   * Other service-specific data about the request, response, and other
   * information associated with the current audited event.
   */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /**
   * Deprecated: Use `metadata` field instead.
   * Other service-specific data about the request, response, and other
   * activities.
   * When the JSON object represented here has a proto equivalent, the proto
   * name will be indicated in the `@type` property.
   */
  serviceData?: { [key: string]: any } | undefined;
}

/** Authentication information for the operation. */
export interface AuthenticationInfo {
  /**
   * The email address of the authenticated user (or service account on behalf
   * of third party principal) making the request. For third party identity
   * callers, the `principal_subject` field is populated instead of this field.
   * For privacy reasons, the principal email address is sometimes redacted.
   * For more information, see [Caller identities in audit
   * logs](https://cloud.google.com/logging/docs/audit#user-id).
   */
  principalEmail: string;
  /**
   * The authority selector specified by the requestor, if any.
   * It is not guaranteed that the principal was allowed to use this authority.
   */
  authoritySelector: string;
  /**
   * The third party identification (if any) of the authenticated user making
   * the request.
   * When the JSON object represented here has a proto equivalent, the proto
   * name will be indicated in the `@type` property.
   */
  thirdPartyPrincipal?:
    | { [key: string]: any }
    | undefined;
  /**
   * The name of the service account key used to create or exchange
   * credentials for authenticating the service account making the request.
   * This is a scheme-less URI full resource name. For example:
   *
   * "//iam.googleapis.com/projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}"
   */
  serviceAccountKeyName: string;
  /**
   * Identity delegation history of an authenticated service account that makes
   * the request. It contains information on the real authorities that try to
   * access GCP resources by delegating on a service account. When multiple
   * authorities present, they are guaranteed to be sorted based on the original
   * ordering of the identity delegation events.
   */
  serviceAccountDelegationInfo: ServiceAccountDelegationInfo[];
  /**
   * String representation of identity of requesting party.
   * Populated for both first and third party identities.
   */
  principalSubject: string;
}

/** Authorization information for the operation. */
export interface AuthorizationInfo {
  /**
   * The resource being accessed, as a REST-style string. For example:
   *
   *     bigquery.googleapis.com/projects/PROJECTID/datasets/DATASETID
   */
  resource: string;
  /** The required IAM permission. */
  permission: string;
  /**
   * Whether or not authorization for `resource` and `permission`
   * was granted.
   */
  granted: boolean;
  /**
   * Resource attributes used in IAM condition evaluation. This field contains
   * resource attributes like resource type and resource name.
   *
   * To get the whole view of the attributes used in IAM
   * condition evaluation, the user must also look into
   * `AuditLogData.request_metadata.request_attributes`.
   */
  resourceAttributes?: AttributeContext_Resource | undefined;
}

/** Metadata about the request. */
export interface RequestMetadata {
  /**
   * The IP address of the caller.
   * For caller from internet, this will be public IPv4 or IPv6 address.
   * For caller from a Compute Engine VM with external IP address, this
   * will be the VM's external IP address. For caller from a Compute
   * Engine VM without external IP address, if the VM is in the same
   * organization (or project) as the accessed resource, `caller_ip` will
   * be the VM's internal IPv4 address, otherwise the `caller_ip` will be
   * redacted to "gce-internal-ip".
   * See https://cloud.google.com/compute/docs/vpc/ for more information.
   */
  callerIp: string;
  /**
   * The user agent of the caller.
   * This information is not authenticated and should be treated accordingly.
   * For example:
   *
   * +   `google-api-python-client/1.4.0`:
   *     The request was made by the Google API client for Python.
   * +   `Cloud SDK Command Line Tool apitools-client/1.0 gcloud/0.9.62`:
   *     The request was made by the Google Cloud SDK CLI (gcloud).
   * +   `AppEngine-Google; (+http://code.google.com/appengine; appid:
   * s~my-project`:
   *     The request was made from the `my-project` App Engine app.
   */
  callerSuppliedUserAgent: string;
  /**
   * The network of the caller.
   * Set only if the network host project is part of the same GCP organization
   * (or project) as the accessed resource.
   * See https://cloud.google.com/compute/docs/vpc/ for more information.
   * This is a scheme-less URI full resource name. For example:
   *
   *     "//compute.googleapis.com/projects/PROJECT_ID/global/networks/NETWORK_ID"
   */
  callerNetwork: string;
  /**
   * Request attributes used in IAM condition evaluation. This field contains
   * request attributes like request time and access levels associated with
   * the request.
   *
   * To get the whole view of the attributes used in IAM
   * condition evaluation, the user must also look into
   * `AuditLog.authentication_info.resource_attributes`.
   */
  requestAttributes?:
    | AttributeContext_Request
    | undefined;
  /**
   * The destination of a network activity, such as accepting a TCP connection.
   * In a multi hop network activity, the destination represents the receiver of
   * the last hop. Only two fields are used in this message, Peer.port and
   * Peer.ip. These fields are optionally populated by those services utilizing
   * the IAM condition feature.
   */
  destinationAttributes?: AttributeContext_Peer | undefined;
}

/** Location information about a resource. */
export interface ResourceLocation {
  /**
   * The locations of a resource after the execution of the operation.
   * Requests to create or delete a location based resource must populate
   * the 'current_locations' field and not the 'original_locations' field.
   * For example:
   *
   *     "europe-west1-a"
   *     "us-east1"
   *     "nam3"
   */
  currentLocations: string[];
  /**
   * The locations of a resource prior to the execution of the operation.
   * Requests that mutate the resource's location must populate both the
   * 'original_locations' as well as the 'current_locations' fields.
   * For example:
   *
   *     "europe-west1-a"
   *     "us-east1"
   *     "nam3"
   */
  originalLocations: string[];
}

/** Identity delegation history of an authenticated service account. */
export interface ServiceAccountDelegationInfo {
  /** First party (Google) identity as the real authority. */
  firstPartyPrincipal?:
    | ServiceAccountDelegationInfo_FirstPartyPrincipal
    | undefined;
  /** Third party identity as the real authority. */
  thirdPartyPrincipal?: ServiceAccountDelegationInfo_ThirdPartyPrincipal | undefined;
}

/** First party identity principal. */
export interface ServiceAccountDelegationInfo_FirstPartyPrincipal {
  /** The email address of a Google account. */
  principalEmail: string;
  /** Metadata about the service that uses the service account. */
  serviceMetadata?: { [key: string]: any } | undefined;
}

/** Third party identity principal. */
export interface ServiceAccountDelegationInfo_ThirdPartyPrincipal {
  /** Metadata about third party identity. */
  thirdPartyClaims?: { [key: string]: any } | undefined;
}

/**
 * Additional information used to correlate multiple LogEntries. Used when a
 * single LogEntry would exceed the Google Cloud Logging size limit and is split
 * across multiple entries.
 */
export interface LogSplit {
  /**
   * A globally unique identifier for all LogEntries in a sequence of split
   * logs. All LogEntries with the same |LogSplit.uid| are assumed to be part of
   * the same sequence of split logs.
   */
  uid: string;
  /**
   * The index of this LogEntry in the sequence of split logs. LogEntries are
   * given |index| values 0, 1, ..., n-1 for a sequence of n entries.
   */
  index: number;
  /** The total number of logs that the original LogEntry was split into. */
  totalSplits: number;
}

function createBaseLogEntryData(): LogEntryData {
  return {
    logName: "",
    resource: undefined,
    protoPayload: undefined,
    insertId: "",
    labels: {},
    operation: undefined,
    timestamp: undefined,
    receiveTimestamp: undefined,
    severity: 0,
    trace: "",
    spanId: "",
    split: undefined,
  };
}

export const LogEntryData: MessageFns<LogEntryData> = {
  encode(message: LogEntryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.logName !== "") {
      writer.uint32(98).string(message.logName);
    }
    if (message.resource !== undefined) {
      MonitoredResource.encode(message.resource, writer.uint32(66).fork()).join();
    }
    if (message.protoPayload !== undefined) {
      AuditLog.encode(message.protoPayload, writer.uint32(18).fork()).join();
    }
    if (message.insertId !== "") {
      writer.uint32(34).string(message.insertId);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      LogEntryData_LabelsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.operation !== undefined) {
      LogEntryOperation.encode(message.operation, writer.uint32(122).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(74).fork()).join();
    }
    if (message.receiveTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.receiveTimestamp), writer.uint32(194).fork()).join();
    }
    if (message.severity !== 0) {
      writer.uint32(80).int32(message.severity);
    }
    if (message.trace !== "") {
      writer.uint32(178).string(message.trace);
    }
    if (message.spanId !== "") {
      writer.uint32(218).string(message.spanId);
    }
    if (message.split !== undefined) {
      LogSplit.encode(message.split, writer.uint32(282).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.logName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resource = MonitoredResource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.protoPayload = AuditLog.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.insertId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = LogEntryData_LabelsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.labels[entry11.key] = entry11.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.operation = LogEntryOperation.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.receiveTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.spanId = reader.string();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.split = LogSplit.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntryData {
    return {
      logName: isSet(object.logName) ? globalThis.String(object.logName) : "",
      resource: isSet(object.resource) ? MonitoredResource.fromJSON(object.resource) : undefined,
      protoPayload: isSet(object.protoPayload) ? AuditLog.fromJSON(object.protoPayload) : undefined,
      insertId: isSet(object.insertId) ? globalThis.String(object.insertId) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      operation: isSet(object.operation) ? LogEntryOperation.fromJSON(object.operation) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      receiveTimestamp: isSet(object.receiveTimestamp) ? fromJsonTimestamp(object.receiveTimestamp) : undefined,
      severity: isSet(object.severity) ? logSeverityFromJSON(object.severity) : 0,
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      split: isSet(object.split) ? LogSplit.fromJSON(object.split) : undefined,
    };
  },

  toJSON(message: LogEntryData): unknown {
    const obj: any = {};
    if (message.logName !== "") {
      obj.logName = message.logName;
    }
    if (message.resource !== undefined) {
      obj.resource = MonitoredResource.toJSON(message.resource);
    }
    if (message.protoPayload !== undefined) {
      obj.protoPayload = AuditLog.toJSON(message.protoPayload);
    }
    if (message.insertId !== "") {
      obj.insertId = message.insertId;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.operation !== undefined) {
      obj.operation = LogEntryOperation.toJSON(message.operation);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.receiveTimestamp !== undefined) {
      obj.receiveTimestamp = message.receiveTimestamp.toISOString();
    }
    if (message.severity !== 0) {
      obj.severity = logSeverityToJSON(message.severity);
    }
    if (message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.split !== undefined) {
      obj.split = LogSplit.toJSON(message.split);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEntryData>, I>>(base?: I): LogEntryData {
    return LogEntryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEntryData>, I>>(object: I): LogEntryData {
    const message = createBaseLogEntryData();
    message.logName = object.logName ?? "";
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? MonitoredResource.fromPartial(object.resource)
      : undefined;
    message.protoPayload = (object.protoPayload !== undefined && object.protoPayload !== null)
      ? AuditLog.fromPartial(object.protoPayload)
      : undefined;
    message.insertId = object.insertId ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? LogEntryOperation.fromPartial(object.operation)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.receiveTimestamp = object.receiveTimestamp ?? undefined;
    message.severity = object.severity ?? 0;
    message.trace = object.trace ?? "";
    message.spanId = object.spanId ?? "";
    message.split = (object.split !== undefined && object.split !== null)
      ? LogSplit.fromPartial(object.split)
      : undefined;
    return message;
  },
};

function createBaseLogEntryData_LabelsEntry(): LogEntryData_LabelsEntry {
  return { key: "", value: "" };
}

export const LogEntryData_LabelsEntry: MessageFns<LogEntryData_LabelsEntry> = {
  encode(message: LogEntryData_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntryData_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntryData_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntryData_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LogEntryData_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEntryData_LabelsEntry>, I>>(base?: I): LogEntryData_LabelsEntry {
    return LogEntryData_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEntryData_LabelsEntry>, I>>(object: I): LogEntryData_LabelsEntry {
    const message = createBaseLogEntryData_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLogEntryOperation(): LogEntryOperation {
  return { id: "", producer: "", first: false, last: false };
}

export const LogEntryOperation: MessageFns<LogEntryOperation> = {
  encode(message: LogEntryOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.producer !== "") {
      writer.uint32(18).string(message.producer);
    }
    if (message.first !== false) {
      writer.uint32(24).bool(message.first);
    }
    if (message.last !== false) {
      writer.uint32(32).bool(message.last);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntryOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntryOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.producer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.first = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.last = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntryOperation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      producer: isSet(object.producer) ? globalThis.String(object.producer) : "",
      first: isSet(object.first) ? globalThis.Boolean(object.first) : false,
      last: isSet(object.last) ? globalThis.Boolean(object.last) : false,
    };
  },

  toJSON(message: LogEntryOperation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.producer !== "") {
      obj.producer = message.producer;
    }
    if (message.first !== false) {
      obj.first = message.first;
    }
    if (message.last !== false) {
      obj.last = message.last;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEntryOperation>, I>>(base?: I): LogEntryOperation {
    return LogEntryOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEntryOperation>, I>>(object: I): LogEntryOperation {
    const message = createBaseLogEntryOperation();
    message.id = object.id ?? "";
    message.producer = object.producer ?? "";
    message.first = object.first ?? false;
    message.last = object.last ?? false;
    return message;
  },
};

function createBaseAuditLog(): AuditLog {
  return {
    serviceName: "",
    methodName: "",
    resourceName: "",
    resourceLocation: undefined,
    resourceOriginalState: undefined,
    numResponseItems: Long.ZERO,
    status: undefined,
    authenticationInfo: undefined,
    authorizationInfo: [],
    requestMetadata: undefined,
    request: undefined,
    response: undefined,
    metadata: undefined,
    serviceData: undefined,
  };
}

export const AuditLog: MessageFns<AuditLog> = {
  encode(message: AuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(58).string(message.serviceName);
    }
    if (message.methodName !== "") {
      writer.uint32(66).string(message.methodName);
    }
    if (message.resourceName !== "") {
      writer.uint32(90).string(message.resourceName);
    }
    if (message.resourceLocation !== undefined) {
      ResourceLocation.encode(message.resourceLocation, writer.uint32(162).fork()).join();
    }
    if (message.resourceOriginalState !== undefined) {
      Struct.encode(Struct.wrap(message.resourceOriginalState), writer.uint32(154).fork()).join();
    }
    if (!message.numResponseItems.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.numResponseItems.toString());
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    if (message.authenticationInfo !== undefined) {
      AuthenticationInfo.encode(message.authenticationInfo, writer.uint32(26).fork()).join();
    }
    for (const v of message.authorizationInfo) {
      AuthorizationInfo.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(34).fork()).join();
    }
    if (message.request !== undefined) {
      Struct.encode(Struct.wrap(message.request), writer.uint32(130).fork()).join();
    }
    if (message.response !== undefined) {
      Struct.encode(Struct.wrap(message.response), writer.uint32(138).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(146).fork()).join();
    }
    if (message.serviceData !== undefined) {
      Struct.encode(Struct.wrap(message.serviceData), writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.methodName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.resourceLocation = ResourceLocation.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.resourceOriginalState = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.numResponseItems = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticationInfo = AuthenticationInfo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.authorizationInfo.push(AuthorizationInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.request = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.response = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.serviceData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLog {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      methodName: isSet(object.methodName) ? globalThis.String(object.methodName) : "",
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      resourceLocation: isSet(object.resourceLocation) ? ResourceLocation.fromJSON(object.resourceLocation) : undefined,
      resourceOriginalState: isObject(object.resourceOriginalState) ? object.resourceOriginalState : undefined,
      numResponseItems: isSet(object.numResponseItems) ? Long.fromValue(object.numResponseItems) : Long.ZERO,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      authenticationInfo: isSet(object.authenticationInfo)
        ? AuthenticationInfo.fromJSON(object.authenticationInfo)
        : undefined,
      authorizationInfo: globalThis.Array.isArray(object?.authorizationInfo)
        ? object.authorizationInfo.map((e: any) => AuthorizationInfo.fromJSON(e))
        : [],
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
      request: isObject(object.request) ? object.request : undefined,
      response: isObject(object.response) ? object.response : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      serviceData: isObject(object.serviceData) ? object.serviceData : undefined,
    };
  },

  toJSON(message: AuditLog): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.resourceLocation !== undefined) {
      obj.resourceLocation = ResourceLocation.toJSON(message.resourceLocation);
    }
    if (message.resourceOriginalState !== undefined) {
      obj.resourceOriginalState = message.resourceOriginalState;
    }
    if (!message.numResponseItems.equals(Long.ZERO)) {
      obj.numResponseItems = (message.numResponseItems || Long.ZERO).toString();
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.authenticationInfo !== undefined) {
      obj.authenticationInfo = AuthenticationInfo.toJSON(message.authenticationInfo);
    }
    if (message.authorizationInfo?.length) {
      obj.authorizationInfo = message.authorizationInfo.map((e) => AuthorizationInfo.toJSON(e));
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    if (message.request !== undefined) {
      obj.request = message.request;
    }
    if (message.response !== undefined) {
      obj.response = message.response;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.serviceData !== undefined) {
      obj.serviceData = message.serviceData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLog>, I>>(base?: I): AuditLog {
    return AuditLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLog>, I>>(object: I): AuditLog {
    const message = createBaseAuditLog();
    message.serviceName = object.serviceName ?? "";
    message.methodName = object.methodName ?? "";
    message.resourceName = object.resourceName ?? "";
    message.resourceLocation = (object.resourceLocation !== undefined && object.resourceLocation !== null)
      ? ResourceLocation.fromPartial(object.resourceLocation)
      : undefined;
    message.resourceOriginalState = object.resourceOriginalState ?? undefined;
    message.numResponseItems = (object.numResponseItems !== undefined && object.numResponseItems !== null)
      ? Long.fromValue(object.numResponseItems)
      : Long.ZERO;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.authenticationInfo = (object.authenticationInfo !== undefined && object.authenticationInfo !== null)
      ? AuthenticationInfo.fromPartial(object.authenticationInfo)
      : undefined;
    message.authorizationInfo = object.authorizationInfo?.map((e) => AuthorizationInfo.fromPartial(e)) || [];
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    message.request = object.request ?? undefined;
    message.response = object.response ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.serviceData = object.serviceData ?? undefined;
    return message;
  },
};

function createBaseAuthenticationInfo(): AuthenticationInfo {
  return {
    principalEmail: "",
    authoritySelector: "",
    thirdPartyPrincipal: undefined,
    serviceAccountKeyName: "",
    serviceAccountDelegationInfo: [],
    principalSubject: "",
  };
}

export const AuthenticationInfo: MessageFns<AuthenticationInfo> = {
  encode(message: AuthenticationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principalEmail !== "") {
      writer.uint32(10).string(message.principalEmail);
    }
    if (message.authoritySelector !== "") {
      writer.uint32(18).string(message.authoritySelector);
    }
    if (message.thirdPartyPrincipal !== undefined) {
      Struct.encode(Struct.wrap(message.thirdPartyPrincipal), writer.uint32(34).fork()).join();
    }
    if (message.serviceAccountKeyName !== "") {
      writer.uint32(42).string(message.serviceAccountKeyName);
    }
    for (const v of message.serviceAccountDelegationInfo) {
      ServiceAccountDelegationInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.principalSubject !== "") {
      writer.uint32(66).string(message.principalSubject);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.principalEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authoritySelector = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.thirdPartyPrincipal = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.serviceAccountKeyName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.serviceAccountDelegationInfo.push(ServiceAccountDelegationInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.principalSubject = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationInfo {
    return {
      principalEmail: isSet(object.principalEmail) ? globalThis.String(object.principalEmail) : "",
      authoritySelector: isSet(object.authoritySelector) ? globalThis.String(object.authoritySelector) : "",
      thirdPartyPrincipal: isObject(object.thirdPartyPrincipal) ? object.thirdPartyPrincipal : undefined,
      serviceAccountKeyName: isSet(object.serviceAccountKeyName) ? globalThis.String(object.serviceAccountKeyName) : "",
      serviceAccountDelegationInfo: globalThis.Array.isArray(object?.serviceAccountDelegationInfo)
        ? object.serviceAccountDelegationInfo.map((e: any) => ServiceAccountDelegationInfo.fromJSON(e))
        : [],
      principalSubject: isSet(object.principalSubject) ? globalThis.String(object.principalSubject) : "",
    };
  },

  toJSON(message: AuthenticationInfo): unknown {
    const obj: any = {};
    if (message.principalEmail !== "") {
      obj.principalEmail = message.principalEmail;
    }
    if (message.authoritySelector !== "") {
      obj.authoritySelector = message.authoritySelector;
    }
    if (message.thirdPartyPrincipal !== undefined) {
      obj.thirdPartyPrincipal = message.thirdPartyPrincipal;
    }
    if (message.serviceAccountKeyName !== "") {
      obj.serviceAccountKeyName = message.serviceAccountKeyName;
    }
    if (message.serviceAccountDelegationInfo?.length) {
      obj.serviceAccountDelegationInfo = message.serviceAccountDelegationInfo.map((e) =>
        ServiceAccountDelegationInfo.toJSON(e)
      );
    }
    if (message.principalSubject !== "") {
      obj.principalSubject = message.principalSubject;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticationInfo>, I>>(base?: I): AuthenticationInfo {
    return AuthenticationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticationInfo>, I>>(object: I): AuthenticationInfo {
    const message = createBaseAuthenticationInfo();
    message.principalEmail = object.principalEmail ?? "";
    message.authoritySelector = object.authoritySelector ?? "";
    message.thirdPartyPrincipal = object.thirdPartyPrincipal ?? undefined;
    message.serviceAccountKeyName = object.serviceAccountKeyName ?? "";
    message.serviceAccountDelegationInfo =
      object.serviceAccountDelegationInfo?.map((e) => ServiceAccountDelegationInfo.fromPartial(e)) || [];
    message.principalSubject = object.principalSubject ?? "";
    return message;
  },
};

function createBaseAuthorizationInfo(): AuthorizationInfo {
  return { resource: "", permission: "", granted: false, resourceAttributes: undefined };
}

export const AuthorizationInfo: MessageFns<AuthorizationInfo> = {
  encode(message: AuthorizationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.permission !== "") {
      writer.uint32(18).string(message.permission);
    }
    if (message.granted !== false) {
      writer.uint32(24).bool(message.granted);
    }
    if (message.resourceAttributes !== undefined) {
      AttributeContext_Resource.encode(message.resourceAttributes, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permission = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.granted = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resourceAttributes = AttributeContext_Resource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationInfo {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      permission: isSet(object.permission) ? globalThis.String(object.permission) : "",
      granted: isSet(object.granted) ? globalThis.Boolean(object.granted) : false,
      resourceAttributes: isSet(object.resourceAttributes)
        ? AttributeContext_Resource.fromJSON(object.resourceAttributes)
        : undefined,
    };
  },

  toJSON(message: AuthorizationInfo): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.permission !== "") {
      obj.permission = message.permission;
    }
    if (message.granted !== false) {
      obj.granted = message.granted;
    }
    if (message.resourceAttributes !== undefined) {
      obj.resourceAttributes = AttributeContext_Resource.toJSON(message.resourceAttributes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthorizationInfo>, I>>(base?: I): AuthorizationInfo {
    return AuthorizationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthorizationInfo>, I>>(object: I): AuthorizationInfo {
    const message = createBaseAuthorizationInfo();
    message.resource = object.resource ?? "";
    message.permission = object.permission ?? "";
    message.granted = object.granted ?? false;
    message.resourceAttributes = (object.resourceAttributes !== undefined && object.resourceAttributes !== null)
      ? AttributeContext_Resource.fromPartial(object.resourceAttributes)
      : undefined;
    return message;
  },
};

function createBaseRequestMetadata(): RequestMetadata {
  return {
    callerIp: "",
    callerSuppliedUserAgent: "",
    callerNetwork: "",
    requestAttributes: undefined,
    destinationAttributes: undefined,
  };
}

export const RequestMetadata: MessageFns<RequestMetadata> = {
  encode(message: RequestMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callerIp !== "") {
      writer.uint32(10).string(message.callerIp);
    }
    if (message.callerSuppliedUserAgent !== "") {
      writer.uint32(18).string(message.callerSuppliedUserAgent);
    }
    if (message.callerNetwork !== "") {
      writer.uint32(26).string(message.callerNetwork);
    }
    if (message.requestAttributes !== undefined) {
      AttributeContext_Request.encode(message.requestAttributes, writer.uint32(58).fork()).join();
    }
    if (message.destinationAttributes !== undefined) {
      AttributeContext_Peer.encode(message.destinationAttributes, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.callerIp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.callerSuppliedUserAgent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.callerNetwork = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.requestAttributes = AttributeContext_Request.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.destinationAttributes = AttributeContext_Peer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata {
    return {
      callerIp: isSet(object.callerIp) ? globalThis.String(object.callerIp) : "",
      callerSuppliedUserAgent: isSet(object.callerSuppliedUserAgent)
        ? globalThis.String(object.callerSuppliedUserAgent)
        : "",
      callerNetwork: isSet(object.callerNetwork) ? globalThis.String(object.callerNetwork) : "",
      requestAttributes: isSet(object.requestAttributes)
        ? AttributeContext_Request.fromJSON(object.requestAttributes)
        : undefined,
      destinationAttributes: isSet(object.destinationAttributes)
        ? AttributeContext_Peer.fromJSON(object.destinationAttributes)
        : undefined,
    };
  },

  toJSON(message: RequestMetadata): unknown {
    const obj: any = {};
    if (message.callerIp !== "") {
      obj.callerIp = message.callerIp;
    }
    if (message.callerSuppliedUserAgent !== "") {
      obj.callerSuppliedUserAgent = message.callerSuppliedUserAgent;
    }
    if (message.callerNetwork !== "") {
      obj.callerNetwork = message.callerNetwork;
    }
    if (message.requestAttributes !== undefined) {
      obj.requestAttributes = AttributeContext_Request.toJSON(message.requestAttributes);
    }
    if (message.destinationAttributes !== undefined) {
      obj.destinationAttributes = AttributeContext_Peer.toJSON(message.destinationAttributes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestMetadata>, I>>(base?: I): RequestMetadata {
    return RequestMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestMetadata>, I>>(object: I): RequestMetadata {
    const message = createBaseRequestMetadata();
    message.callerIp = object.callerIp ?? "";
    message.callerSuppliedUserAgent = object.callerSuppliedUserAgent ?? "";
    message.callerNetwork = object.callerNetwork ?? "";
    message.requestAttributes = (object.requestAttributes !== undefined && object.requestAttributes !== null)
      ? AttributeContext_Request.fromPartial(object.requestAttributes)
      : undefined;
    message.destinationAttributes =
      (object.destinationAttributes !== undefined && object.destinationAttributes !== null)
        ? AttributeContext_Peer.fromPartial(object.destinationAttributes)
        : undefined;
    return message;
  },
};

function createBaseResourceLocation(): ResourceLocation {
  return { currentLocations: [], originalLocations: [] };
}

export const ResourceLocation: MessageFns<ResourceLocation> = {
  encode(message: ResourceLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.currentLocations) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.originalLocations) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currentLocations.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originalLocations.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceLocation {
    return {
      currentLocations: globalThis.Array.isArray(object?.currentLocations)
        ? object.currentLocations.map((e: any) => globalThis.String(e))
        : [],
      originalLocations: globalThis.Array.isArray(object?.originalLocations)
        ? object.originalLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ResourceLocation): unknown {
    const obj: any = {};
    if (message.currentLocations?.length) {
      obj.currentLocations = message.currentLocations;
    }
    if (message.originalLocations?.length) {
      obj.originalLocations = message.originalLocations;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceLocation>, I>>(base?: I): ResourceLocation {
    return ResourceLocation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceLocation>, I>>(object: I): ResourceLocation {
    const message = createBaseResourceLocation();
    message.currentLocations = object.currentLocations?.map((e) => e) || [];
    message.originalLocations = object.originalLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseServiceAccountDelegationInfo(): ServiceAccountDelegationInfo {
  return { firstPartyPrincipal: undefined, thirdPartyPrincipal: undefined };
}

export const ServiceAccountDelegationInfo: MessageFns<ServiceAccountDelegationInfo> = {
  encode(message: ServiceAccountDelegationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstPartyPrincipal !== undefined) {
      ServiceAccountDelegationInfo_FirstPartyPrincipal.encode(message.firstPartyPrincipal, writer.uint32(10).fork())
        .join();
    }
    if (message.thirdPartyPrincipal !== undefined) {
      ServiceAccountDelegationInfo_ThirdPartyPrincipal.encode(message.thirdPartyPrincipal, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountDelegationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountDelegationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstPartyPrincipal = ServiceAccountDelegationInfo_FirstPartyPrincipal.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.thirdPartyPrincipal = ServiceAccountDelegationInfo_ThirdPartyPrincipal.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountDelegationInfo {
    return {
      firstPartyPrincipal: isSet(object.firstPartyPrincipal)
        ? ServiceAccountDelegationInfo_FirstPartyPrincipal.fromJSON(object.firstPartyPrincipal)
        : undefined,
      thirdPartyPrincipal: isSet(object.thirdPartyPrincipal)
        ? ServiceAccountDelegationInfo_ThirdPartyPrincipal.fromJSON(object.thirdPartyPrincipal)
        : undefined,
    };
  },

  toJSON(message: ServiceAccountDelegationInfo): unknown {
    const obj: any = {};
    if (message.firstPartyPrincipal !== undefined) {
      obj.firstPartyPrincipal = ServiceAccountDelegationInfo_FirstPartyPrincipal.toJSON(message.firstPartyPrincipal);
    }
    if (message.thirdPartyPrincipal !== undefined) {
      obj.thirdPartyPrincipal = ServiceAccountDelegationInfo_ThirdPartyPrincipal.toJSON(message.thirdPartyPrincipal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceAccountDelegationInfo>, I>>(base?: I): ServiceAccountDelegationInfo {
    return ServiceAccountDelegationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceAccountDelegationInfo>, I>>(object: I): ServiceAccountDelegationInfo {
    const message = createBaseServiceAccountDelegationInfo();
    message.firstPartyPrincipal = (object.firstPartyPrincipal !== undefined && object.firstPartyPrincipal !== null)
      ? ServiceAccountDelegationInfo_FirstPartyPrincipal.fromPartial(object.firstPartyPrincipal)
      : undefined;
    message.thirdPartyPrincipal = (object.thirdPartyPrincipal !== undefined && object.thirdPartyPrincipal !== null)
      ? ServiceAccountDelegationInfo_ThirdPartyPrincipal.fromPartial(object.thirdPartyPrincipal)
      : undefined;
    return message;
  },
};

function createBaseServiceAccountDelegationInfo_FirstPartyPrincipal(): ServiceAccountDelegationInfo_FirstPartyPrincipal {
  return { principalEmail: "", serviceMetadata: undefined };
}

export const ServiceAccountDelegationInfo_FirstPartyPrincipal: MessageFns<
  ServiceAccountDelegationInfo_FirstPartyPrincipal
> = {
  encode(
    message: ServiceAccountDelegationInfo_FirstPartyPrincipal,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.principalEmail !== "") {
      writer.uint32(10).string(message.principalEmail);
    }
    if (message.serviceMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.serviceMetadata), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountDelegationInfo_FirstPartyPrincipal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountDelegationInfo_FirstPartyPrincipal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.principalEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountDelegationInfo_FirstPartyPrincipal {
    return {
      principalEmail: isSet(object.principalEmail) ? globalThis.String(object.principalEmail) : "",
      serviceMetadata: isObject(object.serviceMetadata) ? object.serviceMetadata : undefined,
    };
  },

  toJSON(message: ServiceAccountDelegationInfo_FirstPartyPrincipal): unknown {
    const obj: any = {};
    if (message.principalEmail !== "") {
      obj.principalEmail = message.principalEmail;
    }
    if (message.serviceMetadata !== undefined) {
      obj.serviceMetadata = message.serviceMetadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceAccountDelegationInfo_FirstPartyPrincipal>, I>>(
    base?: I,
  ): ServiceAccountDelegationInfo_FirstPartyPrincipal {
    return ServiceAccountDelegationInfo_FirstPartyPrincipal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceAccountDelegationInfo_FirstPartyPrincipal>, I>>(
    object: I,
  ): ServiceAccountDelegationInfo_FirstPartyPrincipal {
    const message = createBaseServiceAccountDelegationInfo_FirstPartyPrincipal();
    message.principalEmail = object.principalEmail ?? "";
    message.serviceMetadata = object.serviceMetadata ?? undefined;
    return message;
  },
};

function createBaseServiceAccountDelegationInfo_ThirdPartyPrincipal(): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
  return { thirdPartyClaims: undefined };
}

export const ServiceAccountDelegationInfo_ThirdPartyPrincipal: MessageFns<
  ServiceAccountDelegationInfo_ThirdPartyPrincipal
> = {
  encode(
    message: ServiceAccountDelegationInfo_ThirdPartyPrincipal,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.thirdPartyClaims !== undefined) {
      Struct.encode(Struct.wrap(message.thirdPartyClaims), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountDelegationInfo_ThirdPartyPrincipal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.thirdPartyClaims = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
    return { thirdPartyClaims: isObject(object.thirdPartyClaims) ? object.thirdPartyClaims : undefined };
  },

  toJSON(message: ServiceAccountDelegationInfo_ThirdPartyPrincipal): unknown {
    const obj: any = {};
    if (message.thirdPartyClaims !== undefined) {
      obj.thirdPartyClaims = message.thirdPartyClaims;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceAccountDelegationInfo_ThirdPartyPrincipal>, I>>(
    base?: I,
  ): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
    return ServiceAccountDelegationInfo_ThirdPartyPrincipal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceAccountDelegationInfo_ThirdPartyPrincipal>, I>>(
    object: I,
  ): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
    const message = createBaseServiceAccountDelegationInfo_ThirdPartyPrincipal();
    message.thirdPartyClaims = object.thirdPartyClaims ?? undefined;
    return message;
  },
};

function createBaseLogSplit(): LogSplit {
  return { uid: "", index: 0, totalSplits: 0 };
}

export const LogSplit: MessageFns<LogSplit> = {
  encode(message: LogSplit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.index !== 0) {
      writer.uint32(16).int32(message.index);
    }
    if (message.totalSplits !== 0) {
      writer.uint32(24).int32(message.totalSplits);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogSplit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogSplit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalSplits = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogSplit {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      totalSplits: isSet(object.totalSplits) ? globalThis.Number(object.totalSplits) : 0,
    };
  },

  toJSON(message: LogSplit): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.totalSplits !== 0) {
      obj.totalSplits = Math.round(message.totalSplits);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogSplit>, I>>(base?: I): LogSplit {
    return LogSplit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogSplit>, I>>(object: I): LogSplit {
    const message = createBaseLogSplit();
    message.uid = object.uid ?? "";
    message.index = object.index ?? 0;
    message.totalSplits = object.totalSplits ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
