// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/certificatemanager/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration";
import { Timestamp } from "../../../../protobuf/timestamp";

export const protobufPackage = "google.events.cloud.certificatemanager.v1";

/** Defines set of serving states associated with a resource. */
export enum ServingState {
  /** SERVING_STATE_UNSPECIFIED - The status is undefined. */
  SERVING_STATE_UNSPECIFIED = 0,
  /** ACTIVE - The configuration is serving. */
  ACTIVE = 1,
  /** PENDING - Update is in progress. Some frontends may serve this configuration. */
  PENDING = 2,
  UNRECOGNIZED = -1,
}

export function servingStateFromJSON(object: any): ServingState {
  switch (object) {
    case 0:
    case "SERVING_STATE_UNSPECIFIED":
      return ServingState.SERVING_STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ServingState.ACTIVE;
    case 2:
    case "PENDING":
      return ServingState.PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServingState.UNRECOGNIZED;
  }
}

export function servingStateToJSON(object: ServingState): string {
  switch (object) {
    case ServingState.SERVING_STATE_UNSPECIFIED:
      return "SERVING_STATE_UNSPECIFIED";
    case ServingState.ACTIVE:
      return "ACTIVE";
    case ServingState.PENDING:
      return "PENDING";
    case ServingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** CertificateIssuanceConfig specifies how to issue and manage a certificate. */
export interface CertificateIssuanceConfig {
  /**
   * A user-defined name of the certificate issuance config.
   * CertificateIssuanceConfig names must be unique globally and match pattern
   * `projects/* /locations/* /certificateIssuanceConfigs/*`.
   */
  name: string;
  /** Output only. The creation timestamp of a CertificateIssuanceConfig. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The last update timestamp of a CertificateIssuanceConfig. */
  updateTime?:
    | Date
    | undefined;
  /** Set of labels associated with a CertificateIssuanceConfig. */
  labels: { [key: string]: string };
  /** One or more paragraphs of text description of a CertificateIssuanceConfig. */
  description: string;
  /**
   * Required. The CA that issues the workload certificate. It includes the CA
   * address, type, authentication to CA service, etc.
   */
  certificateAuthorityConfig?:
    | CertificateIssuanceConfig_CertificateAuthorityConfig
    | undefined;
  /** Required. Workload certificate lifetime requested. */
  lifetime?:
    | Duration
    | undefined;
  /**
   * Required. Specifies the percentage of elapsed time of the certificate
   * lifetime to wait before renewing the certificate. Must be a number between
   * 1-99, inclusive.
   */
  rotationWindowPercentage: number;
  /** Required. The key algorithm to use when generating the private key. */
  keyAlgorithm: CertificateIssuanceConfig_KeyAlgorithm;
}

/** The type of keypair to generate. */
export enum CertificateIssuanceConfig_KeyAlgorithm {
  /** KEY_ALGORITHM_UNSPECIFIED - Unspecified key algorithm. */
  KEY_ALGORITHM_UNSPECIFIED = 0,
  /** RSA_2048 - Specifies RSA with a 2048-bit modulus. */
  RSA_2048 = 1,
  /** ECDSA_P256 - Specifies ECDSA with curve P256. */
  ECDSA_P256 = 4,
  UNRECOGNIZED = -1,
}

export function certificateIssuanceConfig_KeyAlgorithmFromJSON(object: any): CertificateIssuanceConfig_KeyAlgorithm {
  switch (object) {
    case 0:
    case "KEY_ALGORITHM_UNSPECIFIED":
      return CertificateIssuanceConfig_KeyAlgorithm.KEY_ALGORITHM_UNSPECIFIED;
    case 1:
    case "RSA_2048":
      return CertificateIssuanceConfig_KeyAlgorithm.RSA_2048;
    case 4:
    case "ECDSA_P256":
      return CertificateIssuanceConfig_KeyAlgorithm.ECDSA_P256;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateIssuanceConfig_KeyAlgorithm.UNRECOGNIZED;
  }
}

export function certificateIssuanceConfig_KeyAlgorithmToJSON(object: CertificateIssuanceConfig_KeyAlgorithm): string {
  switch (object) {
    case CertificateIssuanceConfig_KeyAlgorithm.KEY_ALGORITHM_UNSPECIFIED:
      return "KEY_ALGORITHM_UNSPECIFIED";
    case CertificateIssuanceConfig_KeyAlgorithm.RSA_2048:
      return "RSA_2048";
    case CertificateIssuanceConfig_KeyAlgorithm.ECDSA_P256:
      return "ECDSA_P256";
    case CertificateIssuanceConfig_KeyAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The CA that issues the workload certificate. It includes CA address, type,
 * authentication to CA service, etc.
 */
export interface CertificateIssuanceConfig_CertificateAuthorityConfig {
  /** Defines a CertificateAuthorityServiceConfig. */
  certificateAuthorityServiceConfig?:
    | CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig
    | undefined;
}

/** Contains information required to contact CA service. */
export interface CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig {
  /**
   * Required. A CA pool resource used to issue a certificate.
   * The CA pool string has a relative resource path following the form
   * "projects/{project}/locations/{location}/caPools/{ca_pool}".
   */
  caPool: string;
}

export interface CertificateIssuanceConfig_LabelsEntry {
  key: string;
  value: string;
}

/** Defines TLS certificate. */
export interface Certificate {
  /**
   * A user-defined name of the certificate. Certificate names must be unique
   * globally and match pattern `projects/* /locations/* /certificates/*`.
   */
  name: string;
  /** One or more paragraphs of text description of a certificate. */
  description: string;
  /** Output only. The creation timestamp of a Certificate. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The last update timestamp of a Certificate. */
  updateTime?:
    | Date
    | undefined;
  /** Set of labels associated with a Certificate. */
  labels: { [key: string]: string };
  /** If set, defines data of a self-managed certificate. */
  selfManaged?:
    | Certificate_SelfManagedCertificate
    | undefined;
  /** If set, contains configuration and state of a managed certificate. */
  managed?:
    | Certificate_ManagedCertificate
    | undefined;
  /**
   * Output only. The list of Subject Alternative Names of dnsName type defined
   * in the certificate (see RFC 5280 4.2.1.6). Managed certificates that
   * haven't been provisioned yet have this field populated with a value of the
   * managed.domains field.
   */
  sanDnsnames: string[];
  /** Output only. The PEM-encoded certificate chain. */
  pemCertificate: string;
  /** Output only. The expiry timestamp of a Certificate. */
  expireTime?:
    | Date
    | undefined;
  /** Immutable. The scope of the certificate. */
  scope: Certificate_Scope;
}

/** Certificate scope. */
export enum Certificate_Scope {
  /**
   * DEFAULT - Certificates with default scope are served from core Google data centers.
   * If unsure, choose this option.
   */
  DEFAULT = 0,
  /**
   * EDGE_CACHE - Certificates with scope EDGE_CACHE are special-purposed certificates,
   * served from non-core Google data centers.
   */
  EDGE_CACHE = 1,
  UNRECOGNIZED = -1,
}

export function certificate_ScopeFromJSON(object: any): Certificate_Scope {
  switch (object) {
    case 0:
    case "DEFAULT":
      return Certificate_Scope.DEFAULT;
    case 1:
    case "EDGE_CACHE":
      return Certificate_Scope.EDGE_CACHE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_Scope.UNRECOGNIZED;
  }
}

export function certificate_ScopeToJSON(object: Certificate_Scope): string {
  switch (object) {
    case Certificate_Scope.DEFAULT:
      return "DEFAULT";
    case Certificate_Scope.EDGE_CACHE:
      return "EDGE_CACHE";
    case Certificate_Scope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Certificate data for a SelfManaged Certificate.
 * SelfManaged Certificates are uploaded by the user. Updating such
 * certificates before they expire remains the user's responsibility.
 */
export interface Certificate_SelfManagedCertificate {
}

/**
 * Configuration and state of a Managed Certificate.
 * Certificate Manager provisions and renews Managed Certificates
 * automatically, for as long as it's authorized to do so.
 */
export interface Certificate_ManagedCertificate {
  /**
   * Immutable. The domains for which a managed SSL certificate will be
   * generated. Wildcard domains are only supported with DNS challenge
   * resolution.
   */
  domains: string[];
  /**
   * Immutable. Authorizations that will be used for performing domain
   * authorization.
   */
  dnsAuthorizations: string[];
  /**
   * Immutable. The resource name for a
   * [CertificateIssuanceConfig][google.cloud.certificatemanager.v1.CertificateIssuanceConfig]
   * used to configure private PKI certificates in the format
   * `projects/* /locations/* /certificateIssuanceConfigs/*`.
   * If this field is not set, the certificates will instead be publicly
   * signed as documented at
   * https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs#caa.
   */
  issuanceConfig: string;
  /** Output only. State of the managed certificate resource. */
  state: Certificate_ManagedCertificate_State;
  /**
   * Output only. Information about issues with provisioning a Managed
   * Certificate.
   */
  provisioningIssue?:
    | Certificate_ManagedCertificate_ProvisioningIssue
    | undefined;
  /**
   * Output only. Detailed state of the latest authorization attempt for each
   * domain specified for managed certificate resource.
   */
  authorizationAttemptInfo: Certificate_ManagedCertificate_AuthorizationAttemptInfo[];
}

export enum Certificate_ManagedCertificate_State {
  STATE_UNSPECIFIED = 0,
  /**
   * PROVISIONING - Certificate Manager attempts to provision or renew the certificate.
   * If the process takes longer than expected, consult the
   * `provisioning_issue` field.
   */
  PROVISIONING = 1,
  /**
   * FAILED - Multiple certificate provisioning attempts failed and Certificate
   * Manager gave up. To try again, delete and create a new managed
   * Certificate resource.
   * For details see the `provisioning_issue` field.
   */
  FAILED = 2,
  /**
   * ACTIVE - The certificate management is working, and a certificate has been
   * provisioned.
   */
  ACTIVE = 3,
  UNRECOGNIZED = -1,
}

export function certificate_ManagedCertificate_StateFromJSON(object: any): Certificate_ManagedCertificate_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Certificate_ManagedCertificate_State.STATE_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return Certificate_ManagedCertificate_State.PROVISIONING;
    case 2:
    case "FAILED":
      return Certificate_ManagedCertificate_State.FAILED;
    case 3:
    case "ACTIVE":
      return Certificate_ManagedCertificate_State.ACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_ManagedCertificate_State.UNRECOGNIZED;
  }
}

export function certificate_ManagedCertificate_StateToJSON(object: Certificate_ManagedCertificate_State): string {
  switch (object) {
    case Certificate_ManagedCertificate_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Certificate_ManagedCertificate_State.PROVISIONING:
      return "PROVISIONING";
    case Certificate_ManagedCertificate_State.FAILED:
      return "FAILED";
    case Certificate_ManagedCertificate_State.ACTIVE:
      return "ACTIVE";
    case Certificate_ManagedCertificate_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about issues with provisioning a Managed Certificate. */
export interface Certificate_ManagedCertificate_ProvisioningIssue {
  /** Output only. Reason for provisioning failures. */
  reason: Certificate_ManagedCertificate_ProvisioningIssue_Reason;
  /**
   * Output only. Human readable explanation about the issue. Provided to
   * help address the configuration issues. Not guaranteed to be stable. For
   * programmatic access use Reason enum.
   */
  details: string;
}

export enum Certificate_ManagedCertificate_ProvisioningIssue_Reason {
  REASON_UNSPECIFIED = 0,
  /**
   * AUTHORIZATION_ISSUE - Certificate provisioning failed due to an issue with one or more of
   * the domains on the certificate.
   * For details of which domains failed, consult the
   * `authorization_attempt_info` field.
   */
  AUTHORIZATION_ISSUE = 1,
  /**
   * RATE_LIMITED - Exceeded Certificate Authority quotas or internal rate limits of the
   * system. Provisioning may take longer to complete.
   */
  RATE_LIMITED = 2,
  UNRECOGNIZED = -1,
}

export function certificate_ManagedCertificate_ProvisioningIssue_ReasonFromJSON(
  object: any,
): Certificate_ManagedCertificate_ProvisioningIssue_Reason {
  switch (object) {
    case 0:
    case "REASON_UNSPECIFIED":
      return Certificate_ManagedCertificate_ProvisioningIssue_Reason.REASON_UNSPECIFIED;
    case 1:
    case "AUTHORIZATION_ISSUE":
      return Certificate_ManagedCertificate_ProvisioningIssue_Reason.AUTHORIZATION_ISSUE;
    case 2:
    case "RATE_LIMITED":
      return Certificate_ManagedCertificate_ProvisioningIssue_Reason.RATE_LIMITED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_ManagedCertificate_ProvisioningIssue_Reason.UNRECOGNIZED;
  }
}

export function certificate_ManagedCertificate_ProvisioningIssue_ReasonToJSON(
  object: Certificate_ManagedCertificate_ProvisioningIssue_Reason,
): string {
  switch (object) {
    case Certificate_ManagedCertificate_ProvisioningIssue_Reason.REASON_UNSPECIFIED:
      return "REASON_UNSPECIFIED";
    case Certificate_ManagedCertificate_ProvisioningIssue_Reason.AUTHORIZATION_ISSUE:
      return "AUTHORIZATION_ISSUE";
    case Certificate_ManagedCertificate_ProvisioningIssue_Reason.RATE_LIMITED:
      return "RATE_LIMITED";
    case Certificate_ManagedCertificate_ProvisioningIssue_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * State of the latest attempt to authorize a domain for certificate
 * issuance.
 */
export interface Certificate_ManagedCertificate_AuthorizationAttemptInfo {
  /** Domain name of the authorization attempt. */
  domain: string;
  /** Output only. State of the domain for managed certificate issuance. */
  state: Certificate_ManagedCertificate_AuthorizationAttemptInfo_State;
  /**
   * Output only. Reason for failure of the authorization attempt for the
   * domain.
   */
  failureReason: Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason;
  /**
   * Output only. Human readable explanation for reaching the state.
   * Provided to help address the configuration issues. Not guaranteed to be
   * stable. For programmatic access use FailureReason enum.
   */
  details: string;
}

export enum Certificate_ManagedCertificate_AuthorizationAttemptInfo_State {
  STATE_UNSPECIFIED = 0,
  /**
   * AUTHORIZING - Certificate provisioning for this domain is under way. GCP will
   * attempt to authorize the domain.
   */
  AUTHORIZING = 1,
  /** AUTHORIZED - A managed certificate can be provisioned, no issues for this domain. */
  AUTHORIZED = 6,
  /**
   * FAILED - Attempt to authorize the domain failed. This prevents the Managed
   * Certificate from being issued.
   * See `failure_reason` and `details` fields for more information.
   */
  FAILED = 7,
  UNRECOGNIZED = -1,
}

export function certificate_ManagedCertificate_AuthorizationAttemptInfo_StateFromJSON(
  object: any,
): Certificate_ManagedCertificate_AuthorizationAttemptInfo_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.STATE_UNSPECIFIED;
    case 1:
    case "AUTHORIZING":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.AUTHORIZING;
    case 6:
    case "AUTHORIZED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.AUTHORIZED;
    case 7:
    case "FAILED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.UNRECOGNIZED;
  }
}

export function certificate_ManagedCertificate_AuthorizationAttemptInfo_StateToJSON(
  object: Certificate_ManagedCertificate_AuthorizationAttemptInfo_State,
): string {
  switch (object) {
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.AUTHORIZING:
      return "AUTHORIZING";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.AUTHORIZED:
      return "AUTHORIZED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.FAILED:
      return "FAILED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason {
  FAILURE_REASON_UNSPECIFIED = 0,
  /**
   * CONFIG - There was a problem with the user's DNS or load balancer
   * configuration for this domain.
   */
  CONFIG = 1,
  /**
   * CAA - Certificate issuance forbidden by an explicit CAA record for the
   * domain or a failure to check CAA records for the domain.
   */
  CAA = 2,
  /**
   * RATE_LIMITED - Reached a CA or internal rate-limit for the domain,
   * e.g. for certificates per top-level private domain.
   */
  RATE_LIMITED = 3,
  UNRECOGNIZED = -1,
}

export function certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReasonFromJSON(
  object: any,
): Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason {
  switch (object) {
    case 0:
    case "FAILURE_REASON_UNSPECIFIED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.FAILURE_REASON_UNSPECIFIED;
    case 1:
    case "CONFIG":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.CONFIG;
    case 2:
    case "CAA":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.CAA;
    case 3:
    case "RATE_LIMITED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.RATE_LIMITED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.UNRECOGNIZED;
  }
}

export function certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReasonToJSON(
  object: Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason,
): string {
  switch (object) {
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.FAILURE_REASON_UNSPECIFIED:
      return "FAILURE_REASON_UNSPECIFIED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.CONFIG:
      return "CONFIG";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.CAA:
      return "CAA";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.RATE_LIMITED:
      return "RATE_LIMITED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Certificate_LabelsEntry {
  key: string;
  value: string;
}

/** Defines a collection of certificate configurations. */
export interface CertificateMap {
  /**
   * A user-defined name of the Certificate Map. Certificate Map names must be
   * unique globally and match pattern
   * `projects/* /locations/* /certificateMaps/*`.
   */
  name: string;
  /** One or more paragraphs of text description of a certificate map. */
  description: string;
  /** Output only. The creation timestamp of a Certificate Map. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The update timestamp of a Certificate Map. */
  updateTime?:
    | Date
    | undefined;
  /** Set of labels associated with a Certificate Map. */
  labels: { [key: string]: string };
  /**
   * Output only. A list of GCLB targets that use this Certificate Map.
   * A Target Proxy is only present on this list if it's attached to a
   * Forwarding Rule.
   */
  gclbTargets: CertificateMap_GclbTarget[];
}

/** Describes a Target Proxy that uses this Certificate Map. */
export interface CertificateMap_GclbTarget {
  /**
   * Output only. This field returns the resource name in the following
   * format:
   * `//compute.googleapis.com/projects/* /global/targetHttpsProxies/*`.
   */
  targetHttpsProxy?:
    | string
    | undefined;
  /**
   * Output only. This field returns the resource name in the following
   * format:
   * `//compute.googleapis.com/projects/* /global/targetSslProxies/*`.
   */
  targetSslProxy?:
    | string
    | undefined;
  /**
   * Output only. IP configurations for this Target Proxy where the
   * Certificate Map is serving.
   */
  ipConfigs: CertificateMap_GclbTarget_IpConfig[];
}

/** Defines IP configuration where this Certificate Map is serving. */
export interface CertificateMap_GclbTarget_IpConfig {
  /** Output only. An external IP address. */
  ipAddress: string;
  /** Output only. Ports. */
  ports: number[];
}

export interface CertificateMap_LabelsEntry {
  key: string;
  value: string;
}

/** Defines a certificate map entry. */
export interface CertificateMapEntry {
  /**
   * A user-defined name of the Certificate Map Entry. Certificate Map Entry
   * names must be unique globally and match pattern
   * `projects/* /locations/* /certificateMaps/* /certificateMapEntries/*`.
   */
  name: string;
  /** One or more paragraphs of text description of a certificate map entry. */
  description: string;
  /** Output only. The creation timestamp of a Certificate Map Entry. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The update timestamp of a Certificate Map Entry. */
  updateTime?:
    | Date
    | undefined;
  /** Set of labels associated with a Certificate Map Entry. */
  labels: { [key: string]: string };
  /**
   * A Hostname (FQDN, e.g. `example.com`) or a wildcard hostname expression
   * (`*.example.com`) for a set of hostnames with common suffix. Used as
   * Server Name Indication (SNI) for selecting a proper certificate.
   */
  hostname?:
    | string
    | undefined;
  /** A predefined matcher for particular cases, other than SNI selection. */
  matcher?:
    | CertificateMapEntry_Matcher
    | undefined;
  /**
   * A set of Certificates defines for the given `hostname`. There can be
   * defined up to fifteen certificates in each Certificate Map Entry. Each
   * certificate must match pattern `projects/* /locations/* /certificates/*`.
   */
  certificates: string[];
  /** Output only. A serving state of this Certificate Map Entry. */
  state: ServingState;
}

/**
 * Defines predefined cases other than SNI-hostname match when this
 * configuration should be applied.
 */
export enum CertificateMapEntry_Matcher {
  /** MATCHER_UNSPECIFIED - A matcher has't been recognized. */
  MATCHER_UNSPECIFIED = 0,
  /**
   * PRIMARY - A primary certificate that is served when SNI wasn't specified in the
   * request or SNI couldn't be found in the map.
   */
  PRIMARY = 1,
  UNRECOGNIZED = -1,
}

export function certificateMapEntry_MatcherFromJSON(object: any): CertificateMapEntry_Matcher {
  switch (object) {
    case 0:
    case "MATCHER_UNSPECIFIED":
      return CertificateMapEntry_Matcher.MATCHER_UNSPECIFIED;
    case 1:
    case "PRIMARY":
      return CertificateMapEntry_Matcher.PRIMARY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateMapEntry_Matcher.UNRECOGNIZED;
  }
}

export function certificateMapEntry_MatcherToJSON(object: CertificateMapEntry_Matcher): string {
  switch (object) {
    case CertificateMapEntry_Matcher.MATCHER_UNSPECIFIED:
      return "MATCHER_UNSPECIFIED";
    case CertificateMapEntry_Matcher.PRIMARY:
      return "PRIMARY";
    case CertificateMapEntry_Matcher.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CertificateMapEntry_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A DnsAuthorization resource describes a way to perform domain authorization
 * for certificate issuance.
 */
export interface DnsAuthorization {
  /**
   * A user-defined name of the dns authorization. DnsAuthorization names must
   * be unique globally and match pattern
   * `projects/* /locations/* /dnsAuthorizations/*`.
   */
  name: string;
  /** Output only. The creation timestamp of a DnsAuthorization. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The last update timestamp of a DnsAuthorization. */
  updateTime?:
    | Date
    | undefined;
  /** Set of labels associated with a DnsAuthorization. */
  labels: { [key: string]: string };
  /** One or more paragraphs of text description of a DnsAuthorization. */
  description: string;
  /**
   * Required. Immutable. A domain that is being authorized. A DnsAuthorization
   * resource covers a single domain and its wildcard, e.g. authorization for
   * `example.com` can be used to issue certificates for `example.com` and
   * `*.example.com`.
   */
  domain: string;
  /**
   * Output only. DNS Resource Record that needs to be added to DNS
   * configuration.
   */
  dnsResourceRecord?: DnsAuthorization_DnsResourceRecord | undefined;
}

/**
 * The structure describing the DNS Resource Record that needs to be added
 * to DNS configuration for the authorization to be usable by
 * certificate.
 */
export interface DnsAuthorization_DnsResourceRecord {
  /**
   * Output only. Fully qualified name of the DNS Resource Record.
   * e.g. `_acme-challenge.example.com`
   */
  name: string;
  /**
   * Output only. Type of the DNS Resource Record.
   * Currently always set to "CNAME".
   */
  type: string;
  /** Output only. Data of the DNS Resource Record. */
  data: string;
}

export interface DnsAuthorization_LabelsEntry {
  key: string;
  value: string;
}

/** The data within all DnsAuthorization events. */
export interface DnsAuthorizationEventData {
  /** Optional. The DnsAuthorization event payload. Unset for deletion events. */
  payload?: DnsAuthorization | undefined;
}

/** The data within all CertificateIssuanceConfig events. */
export interface CertificateIssuanceConfigEventData {
  /**
   * Optional. The CertificateIssuanceConfig event payload. Unset for deletion
   * events.
   */
  payload?: CertificateIssuanceConfig | undefined;
}

/** The data within all CertificateMapEntry events. */
export interface CertificateMapEntryEventData {
  /** Optional. The CertificateMapEntry event payload. Unset for deletion events. */
  payload?: CertificateMapEntry | undefined;
}

/** The data within all CertificateMap events. */
export interface CertificateMapEventData {
  /** Optional. The CertificateMap event payload. Unset for deletion events. */
  payload?: CertificateMap | undefined;
}

/** The data within all Certificate events. */
export interface CertificateEventData {
  /** Optional. The Certificate event payload. Unset for deletion events. */
  payload?: Certificate | undefined;
}

function createBaseCertificateIssuanceConfig(): CertificateIssuanceConfig {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    certificateAuthorityConfig: undefined,
    lifetime: undefined,
    rotationWindowPercentage: 0,
    keyAlgorithm: 0,
  };
}

export const CertificateIssuanceConfig: MessageFns<CertificateIssuanceConfig> = {
  encode(message: CertificateIssuanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateIssuanceConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.certificateAuthorityConfig !== undefined) {
      CertificateIssuanceConfig_CertificateAuthorityConfig.encode(
        message.certificateAuthorityConfig,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.lifetime !== undefined) {
      Duration.encode(message.lifetime, writer.uint32(58).fork()).join();
    }
    if (message.rotationWindowPercentage !== 0) {
      writer.uint32(64).int32(message.rotationWindowPercentage);
    }
    if (message.keyAlgorithm !== 0) {
      writer.uint32(72).int32(message.keyAlgorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateIssuanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateIssuanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CertificateIssuanceConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.certificateAuthorityConfig = CertificateIssuanceConfig_CertificateAuthorityConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lifetime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.rotationWindowPercentage = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.keyAlgorithm = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateIssuanceConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      certificateAuthorityConfig: isSet(object.certificateAuthorityConfig)
        ? CertificateIssuanceConfig_CertificateAuthorityConfig.fromJSON(object.certificateAuthorityConfig)
        : undefined,
      lifetime: isSet(object.lifetime) ? Duration.fromJSON(object.lifetime) : undefined,
      rotationWindowPercentage: isSet(object.rotationWindowPercentage)
        ? globalThis.Number(object.rotationWindowPercentage)
        : 0,
      keyAlgorithm: isSet(object.keyAlgorithm)
        ? certificateIssuanceConfig_KeyAlgorithmFromJSON(object.keyAlgorithm)
        : 0,
    };
  },

  toJSON(message: CertificateIssuanceConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.certificateAuthorityConfig !== undefined) {
      obj.certificateAuthorityConfig = CertificateIssuanceConfig_CertificateAuthorityConfig.toJSON(
        message.certificateAuthorityConfig,
      );
    }
    if (message.lifetime !== undefined) {
      obj.lifetime = Duration.toJSON(message.lifetime);
    }
    if (message.rotationWindowPercentage !== 0) {
      obj.rotationWindowPercentage = Math.round(message.rotationWindowPercentage);
    }
    if (message.keyAlgorithm !== 0) {
      obj.keyAlgorithm = certificateIssuanceConfig_KeyAlgorithmToJSON(message.keyAlgorithm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateIssuanceConfig>, I>>(base?: I): CertificateIssuanceConfig {
    return CertificateIssuanceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateIssuanceConfig>, I>>(object: I): CertificateIssuanceConfig {
    const message = createBaseCertificateIssuanceConfig();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.certificateAuthorityConfig =
      (object.certificateAuthorityConfig !== undefined && object.certificateAuthorityConfig !== null)
        ? CertificateIssuanceConfig_CertificateAuthorityConfig.fromPartial(object.certificateAuthorityConfig)
        : undefined;
    message.lifetime = (object.lifetime !== undefined && object.lifetime !== null)
      ? Duration.fromPartial(object.lifetime)
      : undefined;
    message.rotationWindowPercentage = object.rotationWindowPercentage ?? 0;
    message.keyAlgorithm = object.keyAlgorithm ?? 0;
    return message;
  },
};

function createBaseCertificateIssuanceConfig_CertificateAuthorityConfig(): CertificateIssuanceConfig_CertificateAuthorityConfig {
  return { certificateAuthorityServiceConfig: undefined };
}

export const CertificateIssuanceConfig_CertificateAuthorityConfig: MessageFns<
  CertificateIssuanceConfig_CertificateAuthorityConfig
> = {
  encode(
    message: CertificateIssuanceConfig_CertificateAuthorityConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.certificateAuthorityServiceConfig !== undefined) {
      CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig.encode(
        message.certificateAuthorityServiceConfig,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateIssuanceConfig_CertificateAuthorityConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateIssuanceConfig_CertificateAuthorityConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.certificateAuthorityServiceConfig =
            CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig.decode(
              reader,
              reader.uint32(),
            );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateIssuanceConfig_CertificateAuthorityConfig {
    return {
      certificateAuthorityServiceConfig: isSet(object.certificateAuthorityServiceConfig)
        ? CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig.fromJSON(
          object.certificateAuthorityServiceConfig,
        )
        : undefined,
    };
  },

  toJSON(message: CertificateIssuanceConfig_CertificateAuthorityConfig): unknown {
    const obj: any = {};
    if (message.certificateAuthorityServiceConfig !== undefined) {
      obj.certificateAuthorityServiceConfig =
        CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig.toJSON(
          message.certificateAuthorityServiceConfig,
        );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateIssuanceConfig_CertificateAuthorityConfig>, I>>(
    base?: I,
  ): CertificateIssuanceConfig_CertificateAuthorityConfig {
    return CertificateIssuanceConfig_CertificateAuthorityConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateIssuanceConfig_CertificateAuthorityConfig>, I>>(
    object: I,
  ): CertificateIssuanceConfig_CertificateAuthorityConfig {
    const message = createBaseCertificateIssuanceConfig_CertificateAuthorityConfig();
    message.certificateAuthorityServiceConfig =
      (object.certificateAuthorityServiceConfig !== undefined && object.certificateAuthorityServiceConfig !== null)
        ? CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig.fromPartial(
          object.certificateAuthorityServiceConfig,
        )
        : undefined;
    return message;
  },
};

function createBaseCertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig(): CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig {
  return { caPool: "" };
}

export const CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig: MessageFns<
  CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig
> = {
  encode(
    message: CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.caPool !== "") {
      writer.uint32(10).string(message.caPool);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caPool = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig {
    return { caPool: isSet(object.caPool) ? globalThis.String(object.caPool) : "" };
  },

  toJSON(message: CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig): unknown {
    const obj: any = {};
    if (message.caPool !== "") {
      obj.caPool = message.caPool;
    }
    return obj;
  },

  create<
    I extends Exact<
      DeepPartial<CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig>,
      I
    >,
  >(base?: I): CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig {
    return CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<
      DeepPartial<CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig>,
      I
    >,
  >(object: I): CertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig {
    const message = createBaseCertificateIssuanceConfig_CertificateAuthorityConfig_CertificateAuthorityServiceConfig();
    message.caPool = object.caPool ?? "";
    return message;
  },
};

function createBaseCertificateIssuanceConfig_LabelsEntry(): CertificateIssuanceConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateIssuanceConfig_LabelsEntry: MessageFns<CertificateIssuanceConfig_LabelsEntry> = {
  encode(message: CertificateIssuanceConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateIssuanceConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateIssuanceConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateIssuanceConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateIssuanceConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateIssuanceConfig_LabelsEntry>, I>>(
    base?: I,
  ): CertificateIssuanceConfig_LabelsEntry {
    return CertificateIssuanceConfig_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateIssuanceConfig_LabelsEntry>, I>>(
    object: I,
  ): CertificateIssuanceConfig_LabelsEntry {
    const message = createBaseCertificateIssuanceConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificate(): Certificate {
  return {
    name: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    selfManaged: undefined,
    managed: undefined,
    sanDnsnames: [],
    pemCertificate: "",
    expireTime: undefined,
    scope: 0,
  };
}

export const Certificate: MessageFns<Certificate> = {
  encode(message: Certificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Certificate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.selfManaged !== undefined) {
      Certificate_SelfManagedCertificate.encode(message.selfManaged, writer.uint32(42).fork()).join();
    }
    if (message.managed !== undefined) {
      Certificate_ManagedCertificate.encode(message.managed, writer.uint32(90).fork()).join();
    }
    for (const v of message.sanDnsnames) {
      writer.uint32(50).string(v!);
    }
    if (message.pemCertificate !== "") {
      writer.uint32(74).string(message.pemCertificate);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(58).fork()).join();
    }
    if (message.scope !== 0) {
      writer.uint32(96).int32(message.scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Certificate_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.selfManaged = Certificate_SelfManagedCertificate.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.managed = Certificate_ManagedCertificate.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sanDnsnames.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pemCertificate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      selfManaged: isSet(object.selfManaged)
        ? Certificate_SelfManagedCertificate.fromJSON(object.selfManaged)
        : undefined,
      managed: isSet(object.managed) ? Certificate_ManagedCertificate.fromJSON(object.managed) : undefined,
      sanDnsnames: globalThis.Array.isArray(object?.sanDnsnames)
        ? object.sanDnsnames.map((e: any) => globalThis.String(e))
        : [],
      pemCertificate: isSet(object.pemCertificate) ? globalThis.String(object.pemCertificate) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      scope: isSet(object.scope) ? certificate_ScopeFromJSON(object.scope) : 0,
    };
  },

  toJSON(message: Certificate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.selfManaged !== undefined) {
      obj.selfManaged = Certificate_SelfManagedCertificate.toJSON(message.selfManaged);
    }
    if (message.managed !== undefined) {
      obj.managed = Certificate_ManagedCertificate.toJSON(message.managed);
    }
    if (message.sanDnsnames?.length) {
      obj.sanDnsnames = message.sanDnsnames;
    }
    if (message.pemCertificate !== "") {
      obj.pemCertificate = message.pemCertificate;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.scope !== 0) {
      obj.scope = certificate_ScopeToJSON(message.scope);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Certificate>, I>>(base?: I): Certificate {
    return Certificate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Certificate>, I>>(object: I): Certificate {
    const message = createBaseCertificate();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.selfManaged = (object.selfManaged !== undefined && object.selfManaged !== null)
      ? Certificate_SelfManagedCertificate.fromPartial(object.selfManaged)
      : undefined;
    message.managed = (object.managed !== undefined && object.managed !== null)
      ? Certificate_ManagedCertificate.fromPartial(object.managed)
      : undefined;
    message.sanDnsnames = object.sanDnsnames?.map((e) => e) || [];
    message.pemCertificate = object.pemCertificate ?? "";
    message.expireTime = object.expireTime ?? undefined;
    message.scope = object.scope ?? 0;
    return message;
  },
};

function createBaseCertificate_SelfManagedCertificate(): Certificate_SelfManagedCertificate {
  return {};
}

export const Certificate_SelfManagedCertificate: MessageFns<Certificate_SelfManagedCertificate> = {
  encode(_: Certificate_SelfManagedCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_SelfManagedCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_SelfManagedCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Certificate_SelfManagedCertificate {
    return {};
  },

  toJSON(_: Certificate_SelfManagedCertificate): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Certificate_SelfManagedCertificate>, I>>(
    base?: I,
  ): Certificate_SelfManagedCertificate {
    return Certificate_SelfManagedCertificate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Certificate_SelfManagedCertificate>, I>>(
    _: I,
  ): Certificate_SelfManagedCertificate {
    const message = createBaseCertificate_SelfManagedCertificate();
    return message;
  },
};

function createBaseCertificate_ManagedCertificate(): Certificate_ManagedCertificate {
  return {
    domains: [],
    dnsAuthorizations: [],
    issuanceConfig: "",
    state: 0,
    provisioningIssue: undefined,
    authorizationAttemptInfo: [],
  };
}

export const Certificate_ManagedCertificate: MessageFns<Certificate_ManagedCertificate> = {
  encode(message: Certificate_ManagedCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.domains) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.dnsAuthorizations) {
      writer.uint32(18).string(v!);
    }
    if (message.issuanceConfig !== "") {
      writer.uint32(50).string(message.issuanceConfig);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.provisioningIssue !== undefined) {
      Certificate_ManagedCertificate_ProvisioningIssue.encode(message.provisioningIssue, writer.uint32(26).fork())
        .join();
    }
    for (const v of message.authorizationAttemptInfo) {
      Certificate_ManagedCertificate_AuthorizationAttemptInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_ManagedCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_ManagedCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domains.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dnsAuthorizations.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.issuanceConfig = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.provisioningIssue = Certificate_ManagedCertificate_ProvisioningIssue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authorizationAttemptInfo.push(
            Certificate_ManagedCertificate_AuthorizationAttemptInfo.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_ManagedCertificate {
    return {
      domains: globalThis.Array.isArray(object?.domains) ? object.domains.map((e: any) => globalThis.String(e)) : [],
      dnsAuthorizations: globalThis.Array.isArray(object?.dnsAuthorizations)
        ? object.dnsAuthorizations.map((e: any) => globalThis.String(e))
        : [],
      issuanceConfig: isSet(object.issuanceConfig) ? globalThis.String(object.issuanceConfig) : "",
      state: isSet(object.state) ? certificate_ManagedCertificate_StateFromJSON(object.state) : 0,
      provisioningIssue: isSet(object.provisioningIssue)
        ? Certificate_ManagedCertificate_ProvisioningIssue.fromJSON(object.provisioningIssue)
        : undefined,
      authorizationAttemptInfo: globalThis.Array.isArray(object?.authorizationAttemptInfo)
        ? object.authorizationAttemptInfo.map((e: any) =>
          Certificate_ManagedCertificate_AuthorizationAttemptInfo.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: Certificate_ManagedCertificate): unknown {
    const obj: any = {};
    if (message.domains?.length) {
      obj.domains = message.domains;
    }
    if (message.dnsAuthorizations?.length) {
      obj.dnsAuthorizations = message.dnsAuthorizations;
    }
    if (message.issuanceConfig !== "") {
      obj.issuanceConfig = message.issuanceConfig;
    }
    if (message.state !== 0) {
      obj.state = certificate_ManagedCertificate_StateToJSON(message.state);
    }
    if (message.provisioningIssue !== undefined) {
      obj.provisioningIssue = Certificate_ManagedCertificate_ProvisioningIssue.toJSON(message.provisioningIssue);
    }
    if (message.authorizationAttemptInfo?.length) {
      obj.authorizationAttemptInfo = message.authorizationAttemptInfo.map((e) =>
        Certificate_ManagedCertificate_AuthorizationAttemptInfo.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Certificate_ManagedCertificate>, I>>(base?: I): Certificate_ManagedCertificate {
    return Certificate_ManagedCertificate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Certificate_ManagedCertificate>, I>>(
    object: I,
  ): Certificate_ManagedCertificate {
    const message = createBaseCertificate_ManagedCertificate();
    message.domains = object.domains?.map((e) => e) || [];
    message.dnsAuthorizations = object.dnsAuthorizations?.map((e) => e) || [];
    message.issuanceConfig = object.issuanceConfig ?? "";
    message.state = object.state ?? 0;
    message.provisioningIssue = (object.provisioningIssue !== undefined && object.provisioningIssue !== null)
      ? Certificate_ManagedCertificate_ProvisioningIssue.fromPartial(object.provisioningIssue)
      : undefined;
    message.authorizationAttemptInfo =
      object.authorizationAttemptInfo?.map((e) =>
        Certificate_ManagedCertificate_AuthorizationAttemptInfo.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseCertificate_ManagedCertificate_ProvisioningIssue(): Certificate_ManagedCertificate_ProvisioningIssue {
  return { reason: 0, details: "" };
}

export const Certificate_ManagedCertificate_ProvisioningIssue: MessageFns<
  Certificate_ManagedCertificate_ProvisioningIssue
> = {
  encode(
    message: Certificate_ManagedCertificate_ProvisioningIssue,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    if (message.details !== "") {
      writer.uint32(18).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_ManagedCertificate_ProvisioningIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_ManagedCertificate_ProvisioningIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_ManagedCertificate_ProvisioningIssue {
    return {
      reason: isSet(object.reason) ? certificate_ManagedCertificate_ProvisioningIssue_ReasonFromJSON(object.reason) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: Certificate_ManagedCertificate_ProvisioningIssue): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = certificate_ManagedCertificate_ProvisioningIssue_ReasonToJSON(message.reason);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Certificate_ManagedCertificate_ProvisioningIssue>, I>>(
    base?: I,
  ): Certificate_ManagedCertificate_ProvisioningIssue {
    return Certificate_ManagedCertificate_ProvisioningIssue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Certificate_ManagedCertificate_ProvisioningIssue>, I>>(
    object: I,
  ): Certificate_ManagedCertificate_ProvisioningIssue {
    const message = createBaseCertificate_ManagedCertificate_ProvisioningIssue();
    message.reason = object.reason ?? 0;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseCertificate_ManagedCertificate_AuthorizationAttemptInfo(): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
  return { domain: "", state: 0, failureReason: 0, details: "" };
}

export const Certificate_ManagedCertificate_AuthorizationAttemptInfo: MessageFns<
  Certificate_ManagedCertificate_AuthorizationAttemptInfo
> = {
  encode(
    message: Certificate_ManagedCertificate_AuthorizationAttemptInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.failureReason !== 0) {
      writer.uint32(24).int32(message.failureReason);
    }
    if (message.details !== "") {
      writer.uint32(34).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_ManagedCertificate_AuthorizationAttemptInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failureReason = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      state: isSet(object.state)
        ? certificate_ManagedCertificate_AuthorizationAttemptInfo_StateFromJSON(object.state)
        : 0,
      failureReason: isSet(object.failureReason)
        ? certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReasonFromJSON(object.failureReason)
        : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: Certificate_ManagedCertificate_AuthorizationAttemptInfo): unknown {
    const obj: any = {};
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.state !== 0) {
      obj.state = certificate_ManagedCertificate_AuthorizationAttemptInfo_StateToJSON(message.state);
    }
    if (message.failureReason !== 0) {
      obj.failureReason = certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReasonToJSON(
        message.failureReason,
      );
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Certificate_ManagedCertificate_AuthorizationAttemptInfo>, I>>(
    base?: I,
  ): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
    return Certificate_ManagedCertificate_AuthorizationAttemptInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Certificate_ManagedCertificate_AuthorizationAttemptInfo>, I>>(
    object: I,
  ): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
    const message = createBaseCertificate_ManagedCertificate_AuthorizationAttemptInfo();
    message.domain = object.domain ?? "";
    message.state = object.state ?? 0;
    message.failureReason = object.failureReason ?? 0;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseCertificate_LabelsEntry(): Certificate_LabelsEntry {
  return { key: "", value: "" };
}

export const Certificate_LabelsEntry: MessageFns<Certificate_LabelsEntry> = {
  encode(message: Certificate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Certificate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Certificate_LabelsEntry>, I>>(base?: I): Certificate_LabelsEntry {
    return Certificate_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Certificate_LabelsEntry>, I>>(object: I): Certificate_LabelsEntry {
    const message = createBaseCertificate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificateMap(): CertificateMap {
  return { name: "", description: "", createTime: undefined, updateTime: undefined, labels: {}, gclbTargets: [] };
}

export const CertificateMap: MessageFns<CertificateMap> = {
  encode(message: CertificateMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateMap_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.gclbTargets) {
      CertificateMap_GclbTarget.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = CertificateMap_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gclbTargets.push(CertificateMap_GclbTarget.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMap {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      gclbTargets: globalThis.Array.isArray(object?.gclbTargets)
        ? object.gclbTargets.map((e: any) => CertificateMap_GclbTarget.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CertificateMap): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.gclbTargets?.length) {
      obj.gclbTargets = message.gclbTargets.map((e) => CertificateMap_GclbTarget.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMap>, I>>(base?: I): CertificateMap {
    return CertificateMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMap>, I>>(object: I): CertificateMap {
    const message = createBaseCertificateMap();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.gclbTargets = object.gclbTargets?.map((e) => CertificateMap_GclbTarget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCertificateMap_GclbTarget(): CertificateMap_GclbTarget {
  return { targetHttpsProxy: undefined, targetSslProxy: undefined, ipConfigs: [] };
}

export const CertificateMap_GclbTarget: MessageFns<CertificateMap_GclbTarget> = {
  encode(message: CertificateMap_GclbTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetHttpsProxy !== undefined) {
      writer.uint32(10).string(message.targetHttpsProxy);
    }
    if (message.targetSslProxy !== undefined) {
      writer.uint32(26).string(message.targetSslProxy);
    }
    for (const v of message.ipConfigs) {
      CertificateMap_GclbTarget_IpConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMap_GclbTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMap_GclbTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetHttpsProxy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetSslProxy = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipConfigs.push(CertificateMap_GclbTarget_IpConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMap_GclbTarget {
    return {
      targetHttpsProxy: isSet(object.targetHttpsProxy) ? globalThis.String(object.targetHttpsProxy) : undefined,
      targetSslProxy: isSet(object.targetSslProxy) ? globalThis.String(object.targetSslProxy) : undefined,
      ipConfigs: globalThis.Array.isArray(object?.ipConfigs)
        ? object.ipConfigs.map((e: any) => CertificateMap_GclbTarget_IpConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CertificateMap_GclbTarget): unknown {
    const obj: any = {};
    if (message.targetHttpsProxy !== undefined) {
      obj.targetHttpsProxy = message.targetHttpsProxy;
    }
    if (message.targetSslProxy !== undefined) {
      obj.targetSslProxy = message.targetSslProxy;
    }
    if (message.ipConfigs?.length) {
      obj.ipConfigs = message.ipConfigs.map((e) => CertificateMap_GclbTarget_IpConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMap_GclbTarget>, I>>(base?: I): CertificateMap_GclbTarget {
    return CertificateMap_GclbTarget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMap_GclbTarget>, I>>(object: I): CertificateMap_GclbTarget {
    const message = createBaseCertificateMap_GclbTarget();
    message.targetHttpsProxy = object.targetHttpsProxy ?? undefined;
    message.targetSslProxy = object.targetSslProxy ?? undefined;
    message.ipConfigs = object.ipConfigs?.map((e) => CertificateMap_GclbTarget_IpConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCertificateMap_GclbTarget_IpConfig(): CertificateMap_GclbTarget_IpConfig {
  return { ipAddress: "", ports: [] };
}

export const CertificateMap_GclbTarget_IpConfig: MessageFns<CertificateMap_GclbTarget_IpConfig> = {
  encode(message: CertificateMap_GclbTarget_IpConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    writer.uint32(26).fork();
    for (const v of message.ports) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMap_GclbTarget_IpConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMap_GclbTarget_IpConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.ports.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ports.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMap_GclbTarget_IpConfig {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CertificateMap_GclbTarget_IpConfig): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMap_GclbTarget_IpConfig>, I>>(
    base?: I,
  ): CertificateMap_GclbTarget_IpConfig {
    return CertificateMap_GclbTarget_IpConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMap_GclbTarget_IpConfig>, I>>(
    object: I,
  ): CertificateMap_GclbTarget_IpConfig {
    const message = createBaseCertificateMap_GclbTarget_IpConfig();
    message.ipAddress = object.ipAddress ?? "";
    message.ports = object.ports?.map((e) => e) || [];
    return message;
  },
};

function createBaseCertificateMap_LabelsEntry(): CertificateMap_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateMap_LabelsEntry: MessageFns<CertificateMap_LabelsEntry> = {
  encode(message: CertificateMap_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMap_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMap_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMap_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateMap_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMap_LabelsEntry>, I>>(base?: I): CertificateMap_LabelsEntry {
    return CertificateMap_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMap_LabelsEntry>, I>>(object: I): CertificateMap_LabelsEntry {
    const message = createBaseCertificateMap_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificateMapEntry(): CertificateMapEntry {
  return {
    name: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    hostname: undefined,
    matcher: undefined,
    certificates: [],
    state: 0,
  };
}

export const CertificateMapEntry: MessageFns<CertificateMapEntry> = {
  encode(message: CertificateMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateMapEntry_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.hostname !== undefined) {
      writer.uint32(42).string(message.hostname);
    }
    if (message.matcher !== undefined) {
      writer.uint32(80).int32(message.matcher);
    }
    for (const v of message.certificates) {
      writer.uint32(58).string(v!);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CertificateMapEntry_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.matcher = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.certificates.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMapEntry {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      matcher: isSet(object.matcher) ? certificateMapEntry_MatcherFromJSON(object.matcher) : undefined,
      certificates: globalThis.Array.isArray(object?.certificates)
        ? object.certificates.map((e: any) => globalThis.String(e))
        : [],
      state: isSet(object.state) ? servingStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: CertificateMapEntry): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.matcher !== undefined) {
      obj.matcher = certificateMapEntry_MatcherToJSON(message.matcher);
    }
    if (message.certificates?.length) {
      obj.certificates = message.certificates;
    }
    if (message.state !== 0) {
      obj.state = servingStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMapEntry>, I>>(base?: I): CertificateMapEntry {
    return CertificateMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMapEntry>, I>>(object: I): CertificateMapEntry {
    const message = createBaseCertificateMapEntry();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.hostname = object.hostname ?? undefined;
    message.matcher = object.matcher ?? undefined;
    message.certificates = object.certificates?.map((e) => e) || [];
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseCertificateMapEntry_LabelsEntry(): CertificateMapEntry_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateMapEntry_LabelsEntry: MessageFns<CertificateMapEntry_LabelsEntry> = {
  encode(message: CertificateMapEntry_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMapEntry_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMapEntry_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMapEntry_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateMapEntry_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMapEntry_LabelsEntry>, I>>(base?: I): CertificateMapEntry_LabelsEntry {
    return CertificateMapEntry_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMapEntry_LabelsEntry>, I>>(
    object: I,
  ): CertificateMapEntry_LabelsEntry {
    const message = createBaseCertificateMapEntry_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDnsAuthorization(): DnsAuthorization {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    domain: "",
    dnsResourceRecord: undefined,
  };
}

export const DnsAuthorization: MessageFns<DnsAuthorization> = {
  encode(message: DnsAuthorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      DnsAuthorization_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.domain !== "") {
      writer.uint32(50).string(message.domain);
    }
    if (message.dnsResourceRecord !== undefined) {
      DnsAuthorization_DnsResourceRecord.encode(message.dnsResourceRecord, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsAuthorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = DnsAuthorization_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dnsResourceRecord = DnsAuthorization_DnsResourceRecord.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsAuthorization {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      dnsResourceRecord: isSet(object.dnsResourceRecord)
        ? DnsAuthorization_DnsResourceRecord.fromJSON(object.dnsResourceRecord)
        : undefined,
    };
  },

  toJSON(message: DnsAuthorization): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.dnsResourceRecord !== undefined) {
      obj.dnsResourceRecord = DnsAuthorization_DnsResourceRecord.toJSON(message.dnsResourceRecord);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsAuthorization>, I>>(base?: I): DnsAuthorization {
    return DnsAuthorization.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsAuthorization>, I>>(object: I): DnsAuthorization {
    const message = createBaseDnsAuthorization();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.domain = object.domain ?? "";
    message.dnsResourceRecord = (object.dnsResourceRecord !== undefined && object.dnsResourceRecord !== null)
      ? DnsAuthorization_DnsResourceRecord.fromPartial(object.dnsResourceRecord)
      : undefined;
    return message;
  },
};

function createBaseDnsAuthorization_DnsResourceRecord(): DnsAuthorization_DnsResourceRecord {
  return { name: "", type: "", data: "" };
}

export const DnsAuthorization_DnsResourceRecord: MessageFns<DnsAuthorization_DnsResourceRecord> = {
  encode(message: DnsAuthorization_DnsResourceRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsAuthorization_DnsResourceRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsAuthorization_DnsResourceRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsAuthorization_DnsResourceRecord {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: DnsAuthorization_DnsResourceRecord): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsAuthorization_DnsResourceRecord>, I>>(
    base?: I,
  ): DnsAuthorization_DnsResourceRecord {
    return DnsAuthorization_DnsResourceRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsAuthorization_DnsResourceRecord>, I>>(
    object: I,
  ): DnsAuthorization_DnsResourceRecord {
    const message = createBaseDnsAuthorization_DnsResourceRecord();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseDnsAuthorization_LabelsEntry(): DnsAuthorization_LabelsEntry {
  return { key: "", value: "" };
}

export const DnsAuthorization_LabelsEntry: MessageFns<DnsAuthorization_LabelsEntry> = {
  encode(message: DnsAuthorization_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsAuthorization_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsAuthorization_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsAuthorization_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DnsAuthorization_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsAuthorization_LabelsEntry>, I>>(base?: I): DnsAuthorization_LabelsEntry {
    return DnsAuthorization_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsAuthorization_LabelsEntry>, I>>(object: I): DnsAuthorization_LabelsEntry {
    const message = createBaseDnsAuthorization_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDnsAuthorizationEventData(): DnsAuthorizationEventData {
  return { payload: undefined };
}

export const DnsAuthorizationEventData: MessageFns<DnsAuthorizationEventData> = {
  encode(message: DnsAuthorizationEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      DnsAuthorization.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsAuthorizationEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsAuthorizationEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = DnsAuthorization.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsAuthorizationEventData {
    return { payload: isSet(object.payload) ? DnsAuthorization.fromJSON(object.payload) : undefined };
  },

  toJSON(message: DnsAuthorizationEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = DnsAuthorization.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsAuthorizationEventData>, I>>(base?: I): DnsAuthorizationEventData {
    return DnsAuthorizationEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsAuthorizationEventData>, I>>(object: I): DnsAuthorizationEventData {
    const message = createBaseDnsAuthorizationEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? DnsAuthorization.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseCertificateIssuanceConfigEventData(): CertificateIssuanceConfigEventData {
  return { payload: undefined };
}

export const CertificateIssuanceConfigEventData: MessageFns<CertificateIssuanceConfigEventData> = {
  encode(message: CertificateIssuanceConfigEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      CertificateIssuanceConfig.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateIssuanceConfigEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateIssuanceConfigEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = CertificateIssuanceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateIssuanceConfigEventData {
    return { payload: isSet(object.payload) ? CertificateIssuanceConfig.fromJSON(object.payload) : undefined };
  },

  toJSON(message: CertificateIssuanceConfigEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = CertificateIssuanceConfig.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateIssuanceConfigEventData>, I>>(
    base?: I,
  ): CertificateIssuanceConfigEventData {
    return CertificateIssuanceConfigEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateIssuanceConfigEventData>, I>>(
    object: I,
  ): CertificateIssuanceConfigEventData {
    const message = createBaseCertificateIssuanceConfigEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? CertificateIssuanceConfig.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseCertificateMapEntryEventData(): CertificateMapEntryEventData {
  return { payload: undefined };
}

export const CertificateMapEntryEventData: MessageFns<CertificateMapEntryEventData> = {
  encode(message: CertificateMapEntryEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      CertificateMapEntry.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMapEntryEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMapEntryEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = CertificateMapEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMapEntryEventData {
    return { payload: isSet(object.payload) ? CertificateMapEntry.fromJSON(object.payload) : undefined };
  },

  toJSON(message: CertificateMapEntryEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = CertificateMapEntry.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMapEntryEventData>, I>>(base?: I): CertificateMapEntryEventData {
    return CertificateMapEntryEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMapEntryEventData>, I>>(object: I): CertificateMapEntryEventData {
    const message = createBaseCertificateMapEntryEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? CertificateMapEntry.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseCertificateMapEventData(): CertificateMapEventData {
  return { payload: undefined };
}

export const CertificateMapEventData: MessageFns<CertificateMapEventData> = {
  encode(message: CertificateMapEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      CertificateMap.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMapEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMapEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = CertificateMap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMapEventData {
    return { payload: isSet(object.payload) ? CertificateMap.fromJSON(object.payload) : undefined };
  },

  toJSON(message: CertificateMapEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = CertificateMap.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMapEventData>, I>>(base?: I): CertificateMapEventData {
    return CertificateMapEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMapEventData>, I>>(object: I): CertificateMapEventData {
    const message = createBaseCertificateMapEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? CertificateMap.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseCertificateEventData(): CertificateEventData {
  return { payload: undefined };
}

export const CertificateEventData: MessageFns<CertificateEventData> = {
  encode(message: CertificateEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Certificate.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Certificate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateEventData {
    return { payload: isSet(object.payload) ? Certificate.fromJSON(object.payload) : undefined };
  },

  toJSON(message: CertificateEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Certificate.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateEventData>, I>>(base?: I): CertificateEventData {
    return CertificateEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateEventData>, I>>(object: I): CertificateEventData {
    const message = createBaseCertificateEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Certificate.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
