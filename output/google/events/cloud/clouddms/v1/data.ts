// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/clouddms/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration";
import { Timestamp } from "../../../../protobuf/timestamp";
import { BoolValue, Int64Value } from "../../../../protobuf/wrappers";
import { Status } from "../../../../rpc/status";

export const protobufPackage = "google.events.cloud.clouddms.v1";

export enum NetworkArchitecture {
  NETWORK_ARCHITECTURE_UNSPECIFIED = 0,
  /** NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER - Instance is in Cloud SQL's old producer network architecture. */
  NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER = 1,
  /** NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER - Instance is in Cloud SQL's new producer network architecture. */
  NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER = 2,
  UNRECOGNIZED = -1,
}

export function networkArchitectureFromJSON(object: any): NetworkArchitecture {
  switch (object) {
    case 0:
    case "NETWORK_ARCHITECTURE_UNSPECIFIED":
      return NetworkArchitecture.NETWORK_ARCHITECTURE_UNSPECIFIED;
    case 1:
    case "NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER":
      return NetworkArchitecture.NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER;
    case 2:
    case "NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER":
      return NetworkArchitecture.NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkArchitecture.UNRECOGNIZED;
  }
}

export function networkArchitectureToJSON(object: NetworkArchitecture): string {
  switch (object) {
    case NetworkArchitecture.NETWORK_ARCHITECTURE_UNSPECIFIED:
      return "NETWORK_ARCHITECTURE_UNSPECIFIED";
    case NetworkArchitecture.NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER:
      return "NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER";
    case NetworkArchitecture.NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER:
      return "NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER";
    case NetworkArchitecture.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The database engine types. */
export enum DatabaseEngine {
  /** DATABASE_ENGINE_UNSPECIFIED - The source database engine of the migration job is unknown. */
  DATABASE_ENGINE_UNSPECIFIED = 0,
  /** MYSQL - The source engine is MySQL. */
  MYSQL = 1,
  /** POSTGRESQL - The source engine is PostgreSQL. */
  POSTGRESQL = 2,
  UNRECOGNIZED = -1,
}

export function databaseEngineFromJSON(object: any): DatabaseEngine {
  switch (object) {
    case 0:
    case "DATABASE_ENGINE_UNSPECIFIED":
      return DatabaseEngine.DATABASE_ENGINE_UNSPECIFIED;
    case 1:
    case "MYSQL":
      return DatabaseEngine.MYSQL;
    case 2:
    case "POSTGRESQL":
      return DatabaseEngine.POSTGRESQL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseEngine.UNRECOGNIZED;
  }
}

export function databaseEngineToJSON(object: DatabaseEngine): string {
  switch (object) {
    case DatabaseEngine.DATABASE_ENGINE_UNSPECIFIED:
      return "DATABASE_ENGINE_UNSPECIFIED";
    case DatabaseEngine.MYSQL:
      return "MYSQL";
    case DatabaseEngine.POSTGRESQL:
      return "POSTGRESQL";
    case DatabaseEngine.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The database providers. */
export enum DatabaseProvider {
  /** DATABASE_PROVIDER_UNSPECIFIED - The database provider is unknown. */
  DATABASE_PROVIDER_UNSPECIFIED = 0,
  /** CLOUDSQL - CloudSQL runs the database. */
  CLOUDSQL = 1,
  /** RDS - RDS runs the database. */
  RDS = 2,
  /** AURORA - Amazon Aurora. */
  AURORA = 3,
  /** ALLOYDB - AlloyDB. */
  ALLOYDB = 4,
  UNRECOGNIZED = -1,
}

export function databaseProviderFromJSON(object: any): DatabaseProvider {
  switch (object) {
    case 0:
    case "DATABASE_PROVIDER_UNSPECIFIED":
      return DatabaseProvider.DATABASE_PROVIDER_UNSPECIFIED;
    case 1:
    case "CLOUDSQL":
      return DatabaseProvider.CLOUDSQL;
    case 2:
    case "RDS":
      return DatabaseProvider.RDS;
    case 3:
    case "AURORA":
      return DatabaseProvider.AURORA;
    case 4:
    case "ALLOYDB":
      return DatabaseProvider.ALLOYDB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseProvider.UNRECOGNIZED;
  }
}

export function databaseProviderToJSON(object: DatabaseProvider): string {
  switch (object) {
    case DatabaseProvider.DATABASE_PROVIDER_UNSPECIFIED:
      return "DATABASE_PROVIDER_UNSPECIFIED";
    case DatabaseProvider.CLOUDSQL:
      return "CLOUDSQL";
    case DatabaseProvider.RDS:
      return "RDS";
    case DatabaseProvider.AURORA:
      return "AURORA";
    case DatabaseProvider.ALLOYDB:
      return "ALLOYDB";
    case DatabaseProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** SSL configuration information. */
export interface SslConfig {
  /**
   * Output only. The ssl config type according to 'client_key',
   * 'client_certificate' and 'ca_certificate'.
   */
  type: SslConfig_SslType;
}

/** Specifies The kind of ssl configuration used. */
export enum SslConfig_SslType {
  /** SSL_TYPE_UNSPECIFIED - Unspecified. */
  SSL_TYPE_UNSPECIFIED = 0,
  /** SERVER_ONLY - Only 'ca_certificate' specified. */
  SERVER_ONLY = 1,
  /**
   * SERVER_CLIENT - Both server ('ca_certificate'), and client ('client_key',
   * 'client_certificate') specified.
   */
  SERVER_CLIENT = 2,
  UNRECOGNIZED = -1,
}

export function sslConfig_SslTypeFromJSON(object: any): SslConfig_SslType {
  switch (object) {
    case 0:
    case "SSL_TYPE_UNSPECIFIED":
      return SslConfig_SslType.SSL_TYPE_UNSPECIFIED;
    case 1:
    case "SERVER_ONLY":
      return SslConfig_SslType.SERVER_ONLY;
    case 2:
    case "SERVER_CLIENT":
      return SslConfig_SslType.SERVER_CLIENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SslConfig_SslType.UNRECOGNIZED;
  }
}

export function sslConfig_SslTypeToJSON(object: SslConfig_SslType): string {
  switch (object) {
    case SslConfig_SslType.SSL_TYPE_UNSPECIFIED:
      return "SSL_TYPE_UNSPECIFIED";
    case SslConfig_SslType.SERVER_ONLY:
      return "SERVER_ONLY";
    case SslConfig_SslType.SERVER_CLIENT:
      return "SERVER_CLIENT";
    case SslConfig_SslType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies connection parameters required specifically for MySQL databases. */
export interface MySqlConnectionProfile {
  /** Required. The IP or hostname of the source MySQL database. */
  host: string;
  /** Required. The network port of the source MySQL database. */
  port: number;
  /**
   * Required. The username that Database Migration Service will use to connect
   * to the database. The value is encrypted when stored in Database Migration
   * Service.
   */
  username: string;
  /** Output only. Indicates If this connection profile password is stored. */
  passwordSet: boolean;
  /** SSL configuration for the destination to connect to the source database. */
  ssl?:
    | SslConfig
    | undefined;
  /**
   * If the source is a Cloud SQL database, use this field to
   * provide the Cloud SQL instance ID of the source.
   */
  cloudSqlId: string;
}

/**
 * Specifies connection parameters required specifically for PostgreSQL
 * databases.
 */
export interface PostgreSqlConnectionProfile {
  /** Required. The IP or hostname of the source PostgreSQL database. */
  host: string;
  /** Required. The network port of the source PostgreSQL database. */
  port: number;
  /**
   * Required. The username that Database Migration Service will use to connect
   * to the database. The value is encrypted when stored in Database Migration
   * Service.
   */
  username: string;
  /** Output only. Indicates If this connection profile password is stored. */
  passwordSet: boolean;
  /** SSL configuration for the destination to connect to the source database. */
  ssl?:
    | SslConfig
    | undefined;
  /**
   * If the source is a Cloud SQL database, use this field to
   * provide the Cloud SQL instance ID of the source.
   */
  cloudSqlId: string;
  /**
   * Output only. If the source is a Cloud SQL database, this field indicates
   * the network architecture it's associated with.
   */
  networkArchitecture: NetworkArchitecture;
}

/**
 * Specifies required connection parameters, and, optionally, the parameters
 * required to create a Cloud SQL destination database instance.
 */
export interface CloudSqlConnectionProfile {
  /**
   * Output only. The Cloud SQL instance ID that this connection profile is
   * associated with.
   */
  cloudSqlId: string;
  /** Immutable. Metadata used to create the destination Cloud SQL database. */
  settings?:
    | CloudSqlSettings
    | undefined;
  /** Output only. The Cloud SQL database instance's private IP. */
  privateIp: string;
  /** Output only. The Cloud SQL database instance's public IP. */
  publicIp: string;
  /**
   * Output only. The Cloud SQL database instance's additional (outgoing) public
   * IP. Used when the Cloud SQL database availability type is REGIONAL (i.e.
   * multiple zones / highly available).
   */
  additionalPublicIp: string;
}

/**
 * Specifies required connection parameters, and the parameters
 * required to create an AlloyDB destination cluster.
 */
export interface AlloyDbConnectionProfile {
  /**
   * Required. The AlloyDB cluster ID that this connection profile is associated
   * with.
   */
  clusterId: string;
  /** Immutable. Metadata used to create the destination AlloyDB cluster. */
  settings?: AlloyDbSettings | undefined;
}

/** An entry for an Access Control list. */
export interface SqlAclEntry {
  /** The allowlisted value for the access control list. */
  value: string;
  /**
   * The time when this access control entry expires in
   * [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example:
   * `2012-11-15T16:19:00.094Z`.
   */
  expireTime?:
    | Date
    | undefined;
  /** A label to identify this entry. */
  label: string;
}

/** IP Management configuration. */
export interface SqlIpConfig {
  /** Whether the instance should be assigned an IPv4 address or not. */
  enableIpv4?:
    | boolean
    | undefined;
  /**
   * The resource link for the VPC network from which the Cloud SQL instance is
   * accessible for private IP. For example,
   * `projects/myProject/global/networks/default`. This setting can
   * be updated, but it cannot be removed after it is set.
   */
  privateNetwork: string;
  /** Whether SSL connections over IP should be enforced or not. */
  requireSsl?:
    | boolean
    | undefined;
  /**
   * The list of external networks that are allowed to connect to the instance
   * using the IP. See
   * https://en.wikipedia.org/wiki/CIDR_notation#CIDR_notation, also known as
   * 'slash' notation (e.g. `192.168.100.0/24`).
   */
  authorizedNetworks: SqlAclEntry[];
}

/** Settings for creating a Cloud SQL database instance. */
export interface CloudSqlSettings {
  /** The database engine type and version. */
  databaseVersion: CloudSqlSettings_SqlDatabaseVersion;
  /**
   * The resource labels for a Cloud SQL instance to use to annotate any related
   * underlying resources such as Compute Engine VMs.
   * An object containing a list of "key": "value" pairs.
   *
   * Example: `{ "name": "wrench", "mass": "18kg", "count": "3" }`.
   */
  userLabels: { [key: string]: string };
  /**
   * The tier (or machine type) for this instance, for example:
   * `db-n1-standard-1` (MySQL instances) or
   * `db-custom-1-3840` (PostgreSQL instances).
   * For more information, see
   * [Cloud SQL Instance
   * Settings](https://cloud.google.com/sql/docs/mysql/instance-settings).
   */
  tier: string;
  /**
   * The maximum size to which storage capacity can be automatically increased.
   * The default value is 0, which specifies that there is no limit.
   */
  storageAutoResizeLimit?:
    | Long
    | undefined;
  /**
   * The activation policy specifies when the instance is activated; it is
   * applicable only when the instance state is 'RUNNABLE'. Valid values:
   *
   * 'ALWAYS': The instance is on, and remains so even in
   * the absence of connection requests.
   *
   * `NEVER`: The instance is off; it is not activated, even if a
   * connection request arrives.
   */
  activationPolicy: CloudSqlSettings_SqlActivationPolicy;
  /**
   * The settings for IP Management. This allows to enable or disable the
   * instance IP and manage which external networks can connect to the instance.
   * The IPv4 address cannot be disabled.
   */
  ipConfig?:
    | SqlIpConfig
    | undefined;
  /**
   * [default: ON] If you enable this setting, Cloud SQL checks your available
   * storage every 30 seconds. If the available storage falls below a threshold
   * size, Cloud SQL automatically adds additional storage capacity. If the
   * available storage repeatedly falls below the threshold size, Cloud SQL
   * continues to add storage until it reaches the maximum of 30 TB.
   */
  autoStorageIncrease?:
    | boolean
    | undefined;
  /**
   * The database flags passed to the Cloud SQL instance at startup.
   * An object containing a list of "key": value pairs.
   * Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   */
  databaseFlags: { [key: string]: string };
  /** The type of storage: `PD_SSD` (default) or `PD_HDD`. */
  dataDiskType: CloudSqlSettings_SqlDataDiskType;
  /**
   * The storage capacity available to the database, in GB.
   * The minimum (and default) size is 10GB.
   */
  dataDiskSizeGb?:
    | Long
    | undefined;
  /**
   * The Google Cloud Platform zone where your Cloud SQL database instance is
   * located.
   */
  zone: string;
  /**
   * Optional. The Google Cloud Platform zone where the failover Cloud SQL
   * database instance is located. Used when the Cloud SQL database availability
   * type is REGIONAL (i.e. multiple zones / highly available).
   */
  secondaryZone: string;
  /**
   * The Database Migration Service source connection profile ID,
   * in the format:
   * `projects/my_project_name/locations/us-central1/connectionProfiles/connection_profile_ID`
   */
  sourceId: string;
  /** Output only. Indicates If this connection profile root password is stored. */
  rootPasswordSet: boolean;
  /** The Cloud SQL default instance level collation. */
  collation: string;
  /** The KMS key name used for the csql instance. */
  cmekKeyName: string;
  /**
   * Optional. Availability type. Potential values:
   * *  `ZONAL`: The instance serves data from only one zone. Outages in that
   * zone affect data availability.
   * *  `REGIONAL`: The instance can serve data from more than one zone in a
   * region (it is highly available).
   */
  availabilityType: CloudSqlSettings_SqlAvailabilityType;
}

/** Specifies when the instance should be activated. */
export enum CloudSqlSettings_SqlActivationPolicy {
  /** SQL_ACTIVATION_POLICY_UNSPECIFIED - unspecified policy. */
  SQL_ACTIVATION_POLICY_UNSPECIFIED = 0,
  /** ALWAYS - The instance is always up and running. */
  ALWAYS = 1,
  /** NEVER - The instance should never spin up. */
  NEVER = 2,
  UNRECOGNIZED = -1,
}

export function cloudSqlSettings_SqlActivationPolicyFromJSON(object: any): CloudSqlSettings_SqlActivationPolicy {
  switch (object) {
    case 0:
    case "SQL_ACTIVATION_POLICY_UNSPECIFIED":
      return CloudSqlSettings_SqlActivationPolicy.SQL_ACTIVATION_POLICY_UNSPECIFIED;
    case 1:
    case "ALWAYS":
      return CloudSqlSettings_SqlActivationPolicy.ALWAYS;
    case 2:
    case "NEVER":
      return CloudSqlSettings_SqlActivationPolicy.NEVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudSqlSettings_SqlActivationPolicy.UNRECOGNIZED;
  }
}

export function cloudSqlSettings_SqlActivationPolicyToJSON(object: CloudSqlSettings_SqlActivationPolicy): string {
  switch (object) {
    case CloudSqlSettings_SqlActivationPolicy.SQL_ACTIVATION_POLICY_UNSPECIFIED:
      return "SQL_ACTIVATION_POLICY_UNSPECIFIED";
    case CloudSqlSettings_SqlActivationPolicy.ALWAYS:
      return "ALWAYS";
    case CloudSqlSettings_SqlActivationPolicy.NEVER:
      return "NEVER";
    case CloudSqlSettings_SqlActivationPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The storage options for Cloud SQL databases. */
export enum CloudSqlSettings_SqlDataDiskType {
  /** SQL_DATA_DISK_TYPE_UNSPECIFIED - Unspecified. */
  SQL_DATA_DISK_TYPE_UNSPECIFIED = 0,
  /** PD_SSD - SSD disk. */
  PD_SSD = 1,
  /** PD_HDD - HDD disk. */
  PD_HDD = 2,
  UNRECOGNIZED = -1,
}

export function cloudSqlSettings_SqlDataDiskTypeFromJSON(object: any): CloudSqlSettings_SqlDataDiskType {
  switch (object) {
    case 0:
    case "SQL_DATA_DISK_TYPE_UNSPECIFIED":
      return CloudSqlSettings_SqlDataDiskType.SQL_DATA_DISK_TYPE_UNSPECIFIED;
    case 1:
    case "PD_SSD":
      return CloudSqlSettings_SqlDataDiskType.PD_SSD;
    case 2:
    case "PD_HDD":
      return CloudSqlSettings_SqlDataDiskType.PD_HDD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudSqlSettings_SqlDataDiskType.UNRECOGNIZED;
  }
}

export function cloudSqlSettings_SqlDataDiskTypeToJSON(object: CloudSqlSettings_SqlDataDiskType): string {
  switch (object) {
    case CloudSqlSettings_SqlDataDiskType.SQL_DATA_DISK_TYPE_UNSPECIFIED:
      return "SQL_DATA_DISK_TYPE_UNSPECIFIED";
    case CloudSqlSettings_SqlDataDiskType.PD_SSD:
      return "PD_SSD";
    case CloudSqlSettings_SqlDataDiskType.PD_HDD:
      return "PD_HDD";
    case CloudSqlSettings_SqlDataDiskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The database engine type and version. */
export enum CloudSqlSettings_SqlDatabaseVersion {
  /** SQL_DATABASE_VERSION_UNSPECIFIED - Unspecified version. */
  SQL_DATABASE_VERSION_UNSPECIFIED = 0,
  /** MYSQL_5_6 - MySQL 5.6. */
  MYSQL_5_6 = 1,
  /** MYSQL_5_7 - MySQL 5.7. */
  MYSQL_5_7 = 2,
  /** POSTGRES_9_6 - PostgreSQL 9.6. */
  POSTGRES_9_6 = 3,
  /** POSTGRES_11 - PostgreSQL 11. */
  POSTGRES_11 = 4,
  /** POSTGRES_10 - PostgreSQL 10. */
  POSTGRES_10 = 5,
  /** MYSQL_8_0 - MySQL 8.0. */
  MYSQL_8_0 = 6,
  /** POSTGRES_12 - PostgreSQL 12. */
  POSTGRES_12 = 7,
  /** POSTGRES_13 - PostgreSQL 13. */
  POSTGRES_13 = 8,
  /** POSTGRES_14 - PostgreSQL 14. */
  POSTGRES_14 = 17,
  UNRECOGNIZED = -1,
}

export function cloudSqlSettings_SqlDatabaseVersionFromJSON(object: any): CloudSqlSettings_SqlDatabaseVersion {
  switch (object) {
    case 0:
    case "SQL_DATABASE_VERSION_UNSPECIFIED":
      return CloudSqlSettings_SqlDatabaseVersion.SQL_DATABASE_VERSION_UNSPECIFIED;
    case 1:
    case "MYSQL_5_6":
      return CloudSqlSettings_SqlDatabaseVersion.MYSQL_5_6;
    case 2:
    case "MYSQL_5_7":
      return CloudSqlSettings_SqlDatabaseVersion.MYSQL_5_7;
    case 3:
    case "POSTGRES_9_6":
      return CloudSqlSettings_SqlDatabaseVersion.POSTGRES_9_6;
    case 4:
    case "POSTGRES_11":
      return CloudSqlSettings_SqlDatabaseVersion.POSTGRES_11;
    case 5:
    case "POSTGRES_10":
      return CloudSqlSettings_SqlDatabaseVersion.POSTGRES_10;
    case 6:
    case "MYSQL_8_0":
      return CloudSqlSettings_SqlDatabaseVersion.MYSQL_8_0;
    case 7:
    case "POSTGRES_12":
      return CloudSqlSettings_SqlDatabaseVersion.POSTGRES_12;
    case 8:
    case "POSTGRES_13":
      return CloudSqlSettings_SqlDatabaseVersion.POSTGRES_13;
    case 17:
    case "POSTGRES_14":
      return CloudSqlSettings_SqlDatabaseVersion.POSTGRES_14;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudSqlSettings_SqlDatabaseVersion.UNRECOGNIZED;
  }
}

export function cloudSqlSettings_SqlDatabaseVersionToJSON(object: CloudSqlSettings_SqlDatabaseVersion): string {
  switch (object) {
    case CloudSqlSettings_SqlDatabaseVersion.SQL_DATABASE_VERSION_UNSPECIFIED:
      return "SQL_DATABASE_VERSION_UNSPECIFIED";
    case CloudSqlSettings_SqlDatabaseVersion.MYSQL_5_6:
      return "MYSQL_5_6";
    case CloudSqlSettings_SqlDatabaseVersion.MYSQL_5_7:
      return "MYSQL_5_7";
    case CloudSqlSettings_SqlDatabaseVersion.POSTGRES_9_6:
      return "POSTGRES_9_6";
    case CloudSqlSettings_SqlDatabaseVersion.POSTGRES_11:
      return "POSTGRES_11";
    case CloudSqlSettings_SqlDatabaseVersion.POSTGRES_10:
      return "POSTGRES_10";
    case CloudSqlSettings_SqlDatabaseVersion.MYSQL_8_0:
      return "MYSQL_8_0";
    case CloudSqlSettings_SqlDatabaseVersion.POSTGRES_12:
      return "POSTGRES_12";
    case CloudSqlSettings_SqlDatabaseVersion.POSTGRES_13:
      return "POSTGRES_13";
    case CloudSqlSettings_SqlDatabaseVersion.POSTGRES_14:
      return "POSTGRES_14";
    case CloudSqlSettings_SqlDatabaseVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The availability type of the given Cloud SQL instance. */
export enum CloudSqlSettings_SqlAvailabilityType {
  /** SQL_AVAILABILITY_TYPE_UNSPECIFIED - This is an unknown Availability type. */
  SQL_AVAILABILITY_TYPE_UNSPECIFIED = 0,
  /** ZONAL - Zonal availablility instance. */
  ZONAL = 1,
  /** REGIONAL - Regional availability instance. */
  REGIONAL = 2,
  UNRECOGNIZED = -1,
}

export function cloudSqlSettings_SqlAvailabilityTypeFromJSON(object: any): CloudSqlSettings_SqlAvailabilityType {
  switch (object) {
    case 0:
    case "SQL_AVAILABILITY_TYPE_UNSPECIFIED":
      return CloudSqlSettings_SqlAvailabilityType.SQL_AVAILABILITY_TYPE_UNSPECIFIED;
    case 1:
    case "ZONAL":
      return CloudSqlSettings_SqlAvailabilityType.ZONAL;
    case 2:
    case "REGIONAL":
      return CloudSqlSettings_SqlAvailabilityType.REGIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudSqlSettings_SqlAvailabilityType.UNRECOGNIZED;
  }
}

export function cloudSqlSettings_SqlAvailabilityTypeToJSON(object: CloudSqlSettings_SqlAvailabilityType): string {
  switch (object) {
    case CloudSqlSettings_SqlAvailabilityType.SQL_AVAILABILITY_TYPE_UNSPECIFIED:
      return "SQL_AVAILABILITY_TYPE_UNSPECIFIED";
    case CloudSqlSettings_SqlAvailabilityType.ZONAL:
      return "ZONAL";
    case CloudSqlSettings_SqlAvailabilityType.REGIONAL:
      return "REGIONAL";
    case CloudSqlSettings_SqlAvailabilityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CloudSqlSettings_UserLabelsEntry {
  key: string;
  value: string;
}

export interface CloudSqlSettings_DatabaseFlagsEntry {
  key: string;
  value: string;
}

/** Settings for creating an AlloyDB cluster. */
export interface AlloyDbSettings {
  /**
   * Required. The resource link for the VPC network in which cluster resources
   * are created and from which they are accessible via Private IP. The network
   * must belong to the same project as the cluster. It is specified in the
   * form: "projects/{project_number}/global/networks/{network_id}". This is
   * required to create a cluster.
   */
  vpcNetwork: string;
  /**
   * Labels for the AlloyDB cluster created by DMS. An object containing a list
   * of 'key', 'value' pairs.
   */
  labels: { [key: string]: string };
  primaryInstanceSettings?: AlloyDbSettings_PrimaryInstanceSettings | undefined;
}

/**
 * The username/password for a database user. Used for specifying initial
 * users at cluster creation time.
 */
export interface AlloyDbSettings_UserPassword {
  /** The database username. */
  user: string;
  /** Output only. Indicates if the initial_user.password field has been set. */
  passwordSet: boolean;
}

/** Settings for the cluster's primary instance */
export interface AlloyDbSettings_PrimaryInstanceSettings {
  /**
   * Required. The ID of the AlloyDB primary instance. The ID must satisfy the
   * regex expression "[a-z0-9-]+".
   */
  id: string;
  /**
   * Configuration for the machines that host the underlying
   * database engine.
   */
  machineConfig?:
    | AlloyDbSettings_PrimaryInstanceSettings_MachineConfig
    | undefined;
  /**
   * Database flags to pass to AlloyDB when DMS is creating the AlloyDB
   * cluster and instances. See the AlloyDB documentation for how these can be
   * used.
   */
  databaseFlags: { [key: string]: string };
  /**
   * Labels for the AlloyDB primary instance created by DMS. An object
   * containing a list of 'key', 'value' pairs.
   */
  labels: { [key: string]: string };
  /**
   * Output only. The private IP address for the Instance.
   * This is the connection endpoint for an end-user application.
   */
  privateIp: string;
}

/** MachineConfig describes the configuration of a machine. */
export interface AlloyDbSettings_PrimaryInstanceSettings_MachineConfig {
  /** The number of CPU's in the VM instance. */
  cpuCount: number;
}

export interface AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry {
  key: string;
  value: string;
}

export interface AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry {
  key: string;
  value: string;
}

export interface AlloyDbSettings_LabelsEntry {
  key: string;
  value: string;
}

/**
 * The source database will allow incoming connections from the destination
 * database's public IP. You can retrieve the Cloud SQL instance's public IP
 * from the Cloud SQL console or using Cloud SQL APIs. No additional
 * configuration is required.
 */
export interface StaticIpConnectivity {
}

/**
 * The details needed to configure a reverse SSH tunnel between the source and
 * destination databases. These details will be used when calling the
 * generateSshScript method (see
 * https://cloud.google.com/database-migration/docs/reference/rest/v1/projects.locations.migrationJobs/generateSshScript)
 * to produce the script that will help set up the reverse SSH tunnel, and to
 * set up the VPC peering between the Cloud SQL private network and the VPC.
 */
export interface ReverseSshConnectivity {
  /**
   * Required. The IP of the virtual machine (Compute Engine) used as the
   * bastion server for the SSH tunnel.
   */
  vmIp: string;
  /**
   * Required. The forwarding port of the virtual machine (Compute Engine) used
   * as the bastion server for the SSH tunnel.
   */
  vmPort: number;
  /**
   * The name of the virtual machine (Compute Engine) used as the bastion server
   * for the SSH tunnel.
   */
  vm: string;
  /** The name of the VPC to peer with the Cloud SQL private network. */
  vpc: string;
}

/**
 * The details of the VPC where the source database is located in Google Cloud.
 * We will use this information to set up the VPC peering connection between
 * Cloud SQL and this VPC.
 */
export interface VpcPeeringConnectivity {
  /** The name of the VPC network to peer with the Cloud SQL private network. */
  vpc: string;
}

/** A message defining the database engine and provider. */
export interface DatabaseType {
  /** The database provider. */
  provider: DatabaseProvider;
  /** The database engine. */
  engine: DatabaseEngine;
}

/** Represents a Database Migration Service migration job object. */
export interface MigrationJob {
  /**
   * The name (URI) of this migration job resource, in the form of:
   * projects/{project}/locations/{location}/migrationJobs/{migrationJob}.
   */
  name: string;
  /**
   * Output only. The timestamp when the migration job resource was created.
   * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
   * Example: "2014-10-02T15:01:23.045123456Z".
   */
  createTime?:
    | Date
    | undefined;
  /**
   * Output only. The timestamp when the migration job resource was last
   * updated. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
   * Example: "2014-10-02T15:01:23.045123456Z".
   */
  updateTime?:
    | Date
    | undefined;
  /**
   * The resource labels for migration job to use to annotate any related
   * underlying resources such as Compute Engine VMs. An object containing a
   * list of "key": "value" pairs.
   *
   * Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
   */
  labels: { [key: string]: string };
  /** The migration job display name. */
  displayName: string;
  /** The current migration job state. */
  state: MigrationJob_State;
  /** Output only. The current migration job phase. */
  phase: MigrationJob_Phase;
  /** Required. The migration job type. */
  type: MigrationJob_Type;
  /**
   * The path to the dump file in Google Cloud Storage,
   * in the format: (gs://[BUCKET_NAME]/[OBJECT_NAME]).
   * This field and the "dump_flags" field are mutually exclusive.
   */
  dumpPath: string;
  /**
   * The initial dump flags.
   * This field and the "dump_path" field are mutually exclusive.
   */
  dumpFlags?:
    | MigrationJob_DumpFlags
    | undefined;
  /** Required. The resource name (URI) of the source connection profile. */
  source: string;
  /** Required. The resource name (URI) of the destination connection profile. */
  destination: string;
  /**
   * The details needed to communicate to the source over Reverse SSH
   * tunnel connectivity.
   */
  reverseSshConnectivity?:
    | ReverseSshConnectivity
    | undefined;
  /** The details of the VPC network that the source database is located in. */
  vpcPeeringConnectivity?:
    | VpcPeeringConnectivity
    | undefined;
  /** static ip connectivity data (default, no additional details needed). */
  staticIpConnectivity?:
    | StaticIpConnectivity
    | undefined;
  /**
   * Output only. The duration of the migration job (in seconds). A duration in
   * seconds with up to nine fractional digits, terminated by 's'. Example:
   * "3.5s".
   */
  duration?:
    | Duration
    | undefined;
  /** Output only. The error details in case of state FAILED. */
  error?:
    | Status
    | undefined;
  /** The database engine type and provider of the source. */
  sourceDatabase?:
    | DatabaseType
    | undefined;
  /** The database engine type and provider of the destination. */
  destinationDatabase?:
    | DatabaseType
    | undefined;
  /**
   * Output only. If the migration job is completed, the time when it was
   * completed.
   */
  endTime?: Date | undefined;
}

/** The current migration job states. */
export enum MigrationJob_State {
  /** STATE_UNSPECIFIED - The state of the migration job is unknown. */
  STATE_UNSPECIFIED = 0,
  /** MAINTENANCE - The migration job is down for maintenance. */
  MAINTENANCE = 1,
  /** DRAFT - The migration job is in draft mode and no resources are created. */
  DRAFT = 2,
  /** CREATING - The migration job is being created. */
  CREATING = 3,
  /** NOT_STARTED - The migration job is created and not started. */
  NOT_STARTED = 4,
  /** RUNNING - The migration job is running. */
  RUNNING = 5,
  /** FAILED - The migration job failed. */
  FAILED = 6,
  /** COMPLETED - The migration job has been completed. */
  COMPLETED = 7,
  /** DELETING - The migration job is being deleted. */
  DELETING = 8,
  /** STOPPING - The migration job is being stopped. */
  STOPPING = 9,
  /** STOPPED - The migration job is currently stopped. */
  STOPPED = 10,
  /** DELETED - The migration job has been deleted. */
  DELETED = 11,
  /** UPDATING - The migration job is being updated. */
  UPDATING = 12,
  /** STARTING - The migration job is starting. */
  STARTING = 13,
  /** RESTARTING - The migration job is restarting. */
  RESTARTING = 14,
  /** RESUMING - The migration job is resuming. */
  RESUMING = 15,
  UNRECOGNIZED = -1,
}

export function migrationJob_StateFromJSON(object: any): MigrationJob_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return MigrationJob_State.STATE_UNSPECIFIED;
    case 1:
    case "MAINTENANCE":
      return MigrationJob_State.MAINTENANCE;
    case 2:
    case "DRAFT":
      return MigrationJob_State.DRAFT;
    case 3:
    case "CREATING":
      return MigrationJob_State.CREATING;
    case 4:
    case "NOT_STARTED":
      return MigrationJob_State.NOT_STARTED;
    case 5:
    case "RUNNING":
      return MigrationJob_State.RUNNING;
    case 6:
    case "FAILED":
      return MigrationJob_State.FAILED;
    case 7:
    case "COMPLETED":
      return MigrationJob_State.COMPLETED;
    case 8:
    case "DELETING":
      return MigrationJob_State.DELETING;
    case 9:
    case "STOPPING":
      return MigrationJob_State.STOPPING;
    case 10:
    case "STOPPED":
      return MigrationJob_State.STOPPED;
    case 11:
    case "DELETED":
      return MigrationJob_State.DELETED;
    case 12:
    case "UPDATING":
      return MigrationJob_State.UPDATING;
    case 13:
    case "STARTING":
      return MigrationJob_State.STARTING;
    case 14:
    case "RESTARTING":
      return MigrationJob_State.RESTARTING;
    case 15:
    case "RESUMING":
      return MigrationJob_State.RESUMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigrationJob_State.UNRECOGNIZED;
  }
}

export function migrationJob_StateToJSON(object: MigrationJob_State): string {
  switch (object) {
    case MigrationJob_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case MigrationJob_State.MAINTENANCE:
      return "MAINTENANCE";
    case MigrationJob_State.DRAFT:
      return "DRAFT";
    case MigrationJob_State.CREATING:
      return "CREATING";
    case MigrationJob_State.NOT_STARTED:
      return "NOT_STARTED";
    case MigrationJob_State.RUNNING:
      return "RUNNING";
    case MigrationJob_State.FAILED:
      return "FAILED";
    case MigrationJob_State.COMPLETED:
      return "COMPLETED";
    case MigrationJob_State.DELETING:
      return "DELETING";
    case MigrationJob_State.STOPPING:
      return "STOPPING";
    case MigrationJob_State.STOPPED:
      return "STOPPED";
    case MigrationJob_State.DELETED:
      return "DELETED";
    case MigrationJob_State.UPDATING:
      return "UPDATING";
    case MigrationJob_State.STARTING:
      return "STARTING";
    case MigrationJob_State.RESTARTING:
      return "RESTARTING";
    case MigrationJob_State.RESUMING:
      return "RESUMING";
    case MigrationJob_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The current migration job phase. */
export enum MigrationJob_Phase {
  /** PHASE_UNSPECIFIED - The phase of the migration job is unknown. */
  PHASE_UNSPECIFIED = 0,
  /** FULL_DUMP - The migration job is in the full dump phase. */
  FULL_DUMP = 1,
  /** CDC - The migration job is CDC phase. */
  CDC = 2,
  /** PROMOTE_IN_PROGRESS - The migration job is running the promote phase. */
  PROMOTE_IN_PROGRESS = 3,
  /** WAITING_FOR_SOURCE_WRITES_TO_STOP - Only RDS flow - waiting for source writes to stop */
  WAITING_FOR_SOURCE_WRITES_TO_STOP = 4,
  /** PREPARING_THE_DUMP - Only RDS flow - the sources writes stopped, waiting for dump to begin */
  PREPARING_THE_DUMP = 5,
  UNRECOGNIZED = -1,
}

export function migrationJob_PhaseFromJSON(object: any): MigrationJob_Phase {
  switch (object) {
    case 0:
    case "PHASE_UNSPECIFIED":
      return MigrationJob_Phase.PHASE_UNSPECIFIED;
    case 1:
    case "FULL_DUMP":
      return MigrationJob_Phase.FULL_DUMP;
    case 2:
    case "CDC":
      return MigrationJob_Phase.CDC;
    case 3:
    case "PROMOTE_IN_PROGRESS":
      return MigrationJob_Phase.PROMOTE_IN_PROGRESS;
    case 4:
    case "WAITING_FOR_SOURCE_WRITES_TO_STOP":
      return MigrationJob_Phase.WAITING_FOR_SOURCE_WRITES_TO_STOP;
    case 5:
    case "PREPARING_THE_DUMP":
      return MigrationJob_Phase.PREPARING_THE_DUMP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigrationJob_Phase.UNRECOGNIZED;
  }
}

export function migrationJob_PhaseToJSON(object: MigrationJob_Phase): string {
  switch (object) {
    case MigrationJob_Phase.PHASE_UNSPECIFIED:
      return "PHASE_UNSPECIFIED";
    case MigrationJob_Phase.FULL_DUMP:
      return "FULL_DUMP";
    case MigrationJob_Phase.CDC:
      return "CDC";
    case MigrationJob_Phase.PROMOTE_IN_PROGRESS:
      return "PROMOTE_IN_PROGRESS";
    case MigrationJob_Phase.WAITING_FOR_SOURCE_WRITES_TO_STOP:
      return "WAITING_FOR_SOURCE_WRITES_TO_STOP";
    case MigrationJob_Phase.PREPARING_THE_DUMP:
      return "PREPARING_THE_DUMP";
    case MigrationJob_Phase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of migration job (one-time or continuous). */
export enum MigrationJob_Type {
  /** TYPE_UNSPECIFIED - The type of the migration job is unknown. */
  TYPE_UNSPECIFIED = 0,
  /** ONE_TIME - The migration job is a one time migration. */
  ONE_TIME = 1,
  /** CONTINUOUS - The migration job is a continuous migration. */
  CONTINUOUS = 2,
  UNRECOGNIZED = -1,
}

export function migrationJob_TypeFromJSON(object: any): MigrationJob_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return MigrationJob_Type.TYPE_UNSPECIFIED;
    case 1:
    case "ONE_TIME":
      return MigrationJob_Type.ONE_TIME;
    case 2:
    case "CONTINUOUS":
      return MigrationJob_Type.CONTINUOUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigrationJob_Type.UNRECOGNIZED;
  }
}

export function migrationJob_TypeToJSON(object: MigrationJob_Type): string {
  switch (object) {
    case MigrationJob_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case MigrationJob_Type.ONE_TIME:
      return "ONE_TIME";
    case MigrationJob_Type.CONTINUOUS:
      return "CONTINUOUS";
    case MigrationJob_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Dump flag definition. */
export interface MigrationJob_DumpFlag {
  /** The name of the flag */
  name: string;
  /** The value of the flag. */
  value: string;
}

/** Dump flags definition. */
export interface MigrationJob_DumpFlags {
  /** The flags for the initial dump. */
  dumpFlags: MigrationJob_DumpFlag[];
}

export interface MigrationJob_LabelsEntry {
  key: string;
  value: string;
}

/** A connection profile definition. */
export interface ConnectionProfile {
  /**
   * The name of this connection profile resource in the form of
   * projects/{project}/locations/{location}/connectionProfiles/{connectionProfile}.
   */
  name: string;
  /**
   * Output only. The timestamp when the resource was created.
   * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
   * Example: "2014-10-02T15:01:23.045123456Z".
   */
  createTime?:
    | Date
    | undefined;
  /**
   * Output only. The timestamp when the resource was last updated.
   * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
   * Example: "2014-10-02T15:01:23.045123456Z".
   */
  updateTime?:
    | Date
    | undefined;
  /**
   * The resource labels for connection profile to use to annotate any related
   * underlying resources such as Compute Engine VMs. An object containing a
   * list of "key": "value" pairs.
   *
   * Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
   */
  labels: { [key: string]: string };
  /** The current connection profile state (e.g. DRAFT, READY, or FAILED). */
  state: ConnectionProfile_State;
  /** The connection profile display name. */
  displayName: string;
  /** A MySQL database connection profile. */
  mysql?:
    | MySqlConnectionProfile
    | undefined;
  /** A PostgreSQL database connection profile. */
  postgresql?:
    | PostgreSqlConnectionProfile
    | undefined;
  /** A CloudSQL database connection profile. */
  cloudsql?:
    | CloudSqlConnectionProfile
    | undefined;
  /** An AlloyDB cluster connection profile. */
  alloydb?:
    | AlloyDbConnectionProfile
    | undefined;
  /** Output only. The error details in case of state FAILED. */
  error?:
    | Status
    | undefined;
  /** The database provider. */
  provider: DatabaseProvider;
}

/** The current connection profile state (e.g. DRAFT, READY, or FAILED). */
export enum ConnectionProfile_State {
  /** STATE_UNSPECIFIED - The state of the connection profile is unknown. */
  STATE_UNSPECIFIED = 0,
  /** DRAFT - The connection profile is in draft mode and fully editable. */
  DRAFT = 1,
  /** CREATING - The connection profile is being created. */
  CREATING = 2,
  /** READY - The connection profile is ready. */
  READY = 3,
  /** UPDATING - The connection profile is being updated. */
  UPDATING = 4,
  /** DELETING - The connection profile is being deleted. */
  DELETING = 5,
  /** DELETED - The connection profile has been deleted. */
  DELETED = 6,
  /** FAILED - The last action on the connection profile failed. */
  FAILED = 7,
  UNRECOGNIZED = -1,
}

export function connectionProfile_StateFromJSON(object: any): ConnectionProfile_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ConnectionProfile_State.STATE_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return ConnectionProfile_State.DRAFT;
    case 2:
    case "CREATING":
      return ConnectionProfile_State.CREATING;
    case 3:
    case "READY":
      return ConnectionProfile_State.READY;
    case 4:
    case "UPDATING":
      return ConnectionProfile_State.UPDATING;
    case 5:
    case "DELETING":
      return ConnectionProfile_State.DELETING;
    case 6:
    case "DELETED":
      return ConnectionProfile_State.DELETED;
    case 7:
    case "FAILED":
      return ConnectionProfile_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionProfile_State.UNRECOGNIZED;
  }
}

export function connectionProfile_StateToJSON(object: ConnectionProfile_State): string {
  switch (object) {
    case ConnectionProfile_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ConnectionProfile_State.DRAFT:
      return "DRAFT";
    case ConnectionProfile_State.CREATING:
      return "CREATING";
    case ConnectionProfile_State.READY:
      return "READY";
    case ConnectionProfile_State.UPDATING:
      return "UPDATING";
    case ConnectionProfile_State.DELETING:
      return "DELETING";
    case ConnectionProfile_State.DELETED:
      return "DELETED";
    case ConnectionProfile_State.FAILED:
      return "FAILED";
    case ConnectionProfile_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ConnectionProfile_LabelsEntry {
  key: string;
  value: string;
}

/** The data within all ConnectionProfile events. */
export interface ConnectionProfileEventData {
  /** Optional. The ConnectionProfile event payload. Unset for deletion events. */
  payload?: ConnectionProfile | undefined;
}

/** The data within all MigrationJob events. */
export interface MigrationJobEventData {
  /** Optional. The MigrationJob event payload. Unset for deletion events. */
  payload?: MigrationJob | undefined;
}

function createBaseSslConfig(): SslConfig {
  return { type: 0 };
}

export const SslConfig: MessageFns<SslConfig> = {
  encode(message: SslConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SslConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSslConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SslConfig {
    return { type: isSet(object.type) ? sslConfig_SslTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: SslConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = sslConfig_SslTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SslConfig>, I>>(base?: I): SslConfig {
    return SslConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SslConfig>, I>>(object: I): SslConfig {
    const message = createBaseSslConfig();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseMySqlConnectionProfile(): MySqlConnectionProfile {
  return { host: "", port: 0, username: "", passwordSet: false, ssl: undefined, cloudSqlId: "" };
}

export const MySqlConnectionProfile: MessageFns<MySqlConnectionProfile> = {
  encode(message: MySqlConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.passwordSet !== false) {
      writer.uint32(40).bool(message.passwordSet);
    }
    if (message.ssl !== undefined) {
      SslConfig.encode(message.ssl, writer.uint32(50).fork()).join();
    }
    if (message.cloudSqlId !== "") {
      writer.uint32(58).string(message.cloudSqlId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MySqlConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySqlConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.passwordSet = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ssl = SslConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cloudSqlId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MySqlConnectionProfile {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      passwordSet: isSet(object.passwordSet) ? globalThis.Boolean(object.passwordSet) : false,
      ssl: isSet(object.ssl) ? SslConfig.fromJSON(object.ssl) : undefined,
      cloudSqlId: isSet(object.cloudSqlId) ? globalThis.String(object.cloudSqlId) : "",
    };
  },

  toJSON(message: MySqlConnectionProfile): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.passwordSet !== false) {
      obj.passwordSet = message.passwordSet;
    }
    if (message.ssl !== undefined) {
      obj.ssl = SslConfig.toJSON(message.ssl);
    }
    if (message.cloudSqlId !== "") {
      obj.cloudSqlId = message.cloudSqlId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MySqlConnectionProfile>, I>>(base?: I): MySqlConnectionProfile {
    return MySqlConnectionProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MySqlConnectionProfile>, I>>(object: I): MySqlConnectionProfile {
    const message = createBaseMySqlConnectionProfile();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.username = object.username ?? "";
    message.passwordSet = object.passwordSet ?? false;
    message.ssl = (object.ssl !== undefined && object.ssl !== null) ? SslConfig.fromPartial(object.ssl) : undefined;
    message.cloudSqlId = object.cloudSqlId ?? "";
    return message;
  },
};

function createBasePostgreSqlConnectionProfile(): PostgreSqlConnectionProfile {
  return {
    host: "",
    port: 0,
    username: "",
    passwordSet: false,
    ssl: undefined,
    cloudSqlId: "",
    networkArchitecture: 0,
  };
}

export const PostgreSqlConnectionProfile: MessageFns<PostgreSqlConnectionProfile> = {
  encode(message: PostgreSqlConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.passwordSet !== false) {
      writer.uint32(40).bool(message.passwordSet);
    }
    if (message.ssl !== undefined) {
      SslConfig.encode(message.ssl, writer.uint32(50).fork()).join();
    }
    if (message.cloudSqlId !== "") {
      writer.uint32(58).string(message.cloudSqlId);
    }
    if (message.networkArchitecture !== 0) {
      writer.uint32(64).int32(message.networkArchitecture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostgreSqlConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostgreSqlConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.passwordSet = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ssl = SslConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cloudSqlId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.networkArchitecture = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostgreSqlConnectionProfile {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      passwordSet: isSet(object.passwordSet) ? globalThis.Boolean(object.passwordSet) : false,
      ssl: isSet(object.ssl) ? SslConfig.fromJSON(object.ssl) : undefined,
      cloudSqlId: isSet(object.cloudSqlId) ? globalThis.String(object.cloudSqlId) : "",
      networkArchitecture: isSet(object.networkArchitecture)
        ? networkArchitectureFromJSON(object.networkArchitecture)
        : 0,
    };
  },

  toJSON(message: PostgreSqlConnectionProfile): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.passwordSet !== false) {
      obj.passwordSet = message.passwordSet;
    }
    if (message.ssl !== undefined) {
      obj.ssl = SslConfig.toJSON(message.ssl);
    }
    if (message.cloudSqlId !== "") {
      obj.cloudSqlId = message.cloudSqlId;
    }
    if (message.networkArchitecture !== 0) {
      obj.networkArchitecture = networkArchitectureToJSON(message.networkArchitecture);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostgreSqlConnectionProfile>, I>>(base?: I): PostgreSqlConnectionProfile {
    return PostgreSqlConnectionProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostgreSqlConnectionProfile>, I>>(object: I): PostgreSqlConnectionProfile {
    const message = createBasePostgreSqlConnectionProfile();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.username = object.username ?? "";
    message.passwordSet = object.passwordSet ?? false;
    message.ssl = (object.ssl !== undefined && object.ssl !== null) ? SslConfig.fromPartial(object.ssl) : undefined;
    message.cloudSqlId = object.cloudSqlId ?? "";
    message.networkArchitecture = object.networkArchitecture ?? 0;
    return message;
  },
};

function createBaseCloudSqlConnectionProfile(): CloudSqlConnectionProfile {
  return { cloudSqlId: "", settings: undefined, privateIp: "", publicIp: "", additionalPublicIp: "" };
}

export const CloudSqlConnectionProfile: MessageFns<CloudSqlConnectionProfile> = {
  encode(message: CloudSqlConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudSqlId !== "") {
      writer.uint32(10).string(message.cloudSqlId);
    }
    if (message.settings !== undefined) {
      CloudSqlSettings.encode(message.settings, writer.uint32(18).fork()).join();
    }
    if (message.privateIp !== "") {
      writer.uint32(26).string(message.privateIp);
    }
    if (message.publicIp !== "") {
      writer.uint32(34).string(message.publicIp);
    }
    if (message.additionalPublicIp !== "") {
      writer.uint32(42).string(message.additionalPublicIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cloudSqlId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.settings = CloudSqlSettings.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.privateIp = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.publicIp = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.additionalPublicIp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlConnectionProfile {
    return {
      cloudSqlId: isSet(object.cloudSqlId) ? globalThis.String(object.cloudSqlId) : "",
      settings: isSet(object.settings) ? CloudSqlSettings.fromJSON(object.settings) : undefined,
      privateIp: isSet(object.privateIp) ? globalThis.String(object.privateIp) : "",
      publicIp: isSet(object.publicIp) ? globalThis.String(object.publicIp) : "",
      additionalPublicIp: isSet(object.additionalPublicIp) ? globalThis.String(object.additionalPublicIp) : "",
    };
  },

  toJSON(message: CloudSqlConnectionProfile): unknown {
    const obj: any = {};
    if (message.cloudSqlId !== "") {
      obj.cloudSqlId = message.cloudSqlId;
    }
    if (message.settings !== undefined) {
      obj.settings = CloudSqlSettings.toJSON(message.settings);
    }
    if (message.privateIp !== "") {
      obj.privateIp = message.privateIp;
    }
    if (message.publicIp !== "") {
      obj.publicIp = message.publicIp;
    }
    if (message.additionalPublicIp !== "") {
      obj.additionalPublicIp = message.additionalPublicIp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudSqlConnectionProfile>, I>>(base?: I): CloudSqlConnectionProfile {
    return CloudSqlConnectionProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudSqlConnectionProfile>, I>>(object: I): CloudSqlConnectionProfile {
    const message = createBaseCloudSqlConnectionProfile();
    message.cloudSqlId = object.cloudSqlId ?? "";
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? CloudSqlSettings.fromPartial(object.settings)
      : undefined;
    message.privateIp = object.privateIp ?? "";
    message.publicIp = object.publicIp ?? "";
    message.additionalPublicIp = object.additionalPublicIp ?? "";
    return message;
  },
};

function createBaseAlloyDbConnectionProfile(): AlloyDbConnectionProfile {
  return { clusterId: "", settings: undefined };
}

export const AlloyDbConnectionProfile: MessageFns<AlloyDbConnectionProfile> = {
  encode(message: AlloyDbConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterId !== "") {
      writer.uint32(10).string(message.clusterId);
    }
    if (message.settings !== undefined) {
      AlloyDbSettings.encode(message.settings, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlloyDbConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlloyDbConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.settings = AlloyDbSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlloyDbConnectionProfile {
    return {
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      settings: isSet(object.settings) ? AlloyDbSettings.fromJSON(object.settings) : undefined,
    };
  },

  toJSON(message: AlloyDbConnectionProfile): unknown {
    const obj: any = {};
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.settings !== undefined) {
      obj.settings = AlloyDbSettings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlloyDbConnectionProfile>, I>>(base?: I): AlloyDbConnectionProfile {
    return AlloyDbConnectionProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlloyDbConnectionProfile>, I>>(object: I): AlloyDbConnectionProfile {
    const message = createBaseAlloyDbConnectionProfile();
    message.clusterId = object.clusterId ?? "";
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? AlloyDbSettings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseSqlAclEntry(): SqlAclEntry {
  return { value: "", expireTime: undefined, label: "" };
}

export const SqlAclEntry: MessageFns<SqlAclEntry> = {
  encode(message: SqlAclEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(82).fork()).join();
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlAclEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlAclEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlAclEntry {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: SqlAclEntry): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SqlAclEntry>, I>>(base?: I): SqlAclEntry {
    return SqlAclEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SqlAclEntry>, I>>(object: I): SqlAclEntry {
    const message = createBaseSqlAclEntry();
    message.value = object.value ?? "";
    message.expireTime = object.expireTime ?? undefined;
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseSqlIpConfig(): SqlIpConfig {
  return { enableIpv4: undefined, privateNetwork: "", requireSsl: undefined, authorizedNetworks: [] };
}

export const SqlIpConfig: MessageFns<SqlIpConfig> = {
  encode(message: SqlIpConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableIpv4 !== undefined) {
      BoolValue.encode({ value: message.enableIpv4! }, writer.uint32(10).fork()).join();
    }
    if (message.privateNetwork !== "") {
      writer.uint32(18).string(message.privateNetwork);
    }
    if (message.requireSsl !== undefined) {
      BoolValue.encode({ value: message.requireSsl! }, writer.uint32(26).fork()).join();
    }
    for (const v of message.authorizedNetworks) {
      SqlAclEntry.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlIpConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlIpConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enableIpv4 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.privateNetwork = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requireSsl = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authorizedNetworks.push(SqlAclEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlIpConfig {
    return {
      enableIpv4: isSet(object.enableIpv4) ? Boolean(object.enableIpv4) : undefined,
      privateNetwork: isSet(object.privateNetwork) ? globalThis.String(object.privateNetwork) : "",
      requireSsl: isSet(object.requireSsl) ? Boolean(object.requireSsl) : undefined,
      authorizedNetworks: globalThis.Array.isArray(object?.authorizedNetworks)
        ? object.authorizedNetworks.map((e: any) => SqlAclEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SqlIpConfig): unknown {
    const obj: any = {};
    if (message.enableIpv4 !== undefined) {
      obj.enableIpv4 = message.enableIpv4;
    }
    if (message.privateNetwork !== "") {
      obj.privateNetwork = message.privateNetwork;
    }
    if (message.requireSsl !== undefined) {
      obj.requireSsl = message.requireSsl;
    }
    if (message.authorizedNetworks?.length) {
      obj.authorizedNetworks = message.authorizedNetworks.map((e) => SqlAclEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SqlIpConfig>, I>>(base?: I): SqlIpConfig {
    return SqlIpConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SqlIpConfig>, I>>(object: I): SqlIpConfig {
    const message = createBaseSqlIpConfig();
    message.enableIpv4 = object.enableIpv4 ?? undefined;
    message.privateNetwork = object.privateNetwork ?? "";
    message.requireSsl = object.requireSsl ?? undefined;
    message.authorizedNetworks = object.authorizedNetworks?.map((e) => SqlAclEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCloudSqlSettings(): CloudSqlSettings {
  return {
    databaseVersion: 0,
    userLabels: {},
    tier: "",
    storageAutoResizeLimit: undefined,
    activationPolicy: 0,
    ipConfig: undefined,
    autoStorageIncrease: undefined,
    databaseFlags: {},
    dataDiskType: 0,
    dataDiskSizeGb: undefined,
    zone: "",
    secondaryZone: "",
    sourceId: "",
    rootPasswordSet: false,
    collation: "",
    cmekKeyName: "",
    availabilityType: 0,
  };
}

export const CloudSqlSettings: MessageFns<CloudSqlSettings> = {
  encode(message: CloudSqlSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.databaseVersion !== 0) {
      writer.uint32(8).int32(message.databaseVersion);
    }
    Object.entries(message.userLabels).forEach(([key, value]) => {
      CloudSqlSettings_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.tier !== "") {
      writer.uint32(26).string(message.tier);
    }
    if (message.storageAutoResizeLimit !== undefined) {
      Int64Value.encode({ value: message.storageAutoResizeLimit! }, writer.uint32(34).fork()).join();
    }
    if (message.activationPolicy !== 0) {
      writer.uint32(40).int32(message.activationPolicy);
    }
    if (message.ipConfig !== undefined) {
      SqlIpConfig.encode(message.ipConfig, writer.uint32(50).fork()).join();
    }
    if (message.autoStorageIncrease !== undefined) {
      BoolValue.encode({ value: message.autoStorageIncrease! }, writer.uint32(58).fork()).join();
    }
    Object.entries(message.databaseFlags).forEach(([key, value]) => {
      CloudSqlSettings_DatabaseFlagsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.dataDiskType !== 0) {
      writer.uint32(72).int32(message.dataDiskType);
    }
    if (message.dataDiskSizeGb !== undefined) {
      Int64Value.encode({ value: message.dataDiskSizeGb! }, writer.uint32(82).fork()).join();
    }
    if (message.zone !== "") {
      writer.uint32(90).string(message.zone);
    }
    if (message.secondaryZone !== "") {
      writer.uint32(146).string(message.secondaryZone);
    }
    if (message.sourceId !== "") {
      writer.uint32(98).string(message.sourceId);
    }
    if (message.rootPasswordSet !== false) {
      writer.uint32(112).bool(message.rootPasswordSet);
    }
    if (message.collation !== "") {
      writer.uint32(122).string(message.collation);
    }
    if (message.cmekKeyName !== "") {
      writer.uint32(130).string(message.cmekKeyName);
    }
    if (message.availabilityType !== 0) {
      writer.uint32(136).int32(message.availabilityType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.databaseVersion = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = CloudSqlSettings_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.userLabels[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storageAutoResizeLimit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.activationPolicy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ipConfig = SqlIpConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.autoStorageIncrease = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = CloudSqlSettings_DatabaseFlagsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.databaseFlags[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.dataDiskType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dataDiskSizeGb = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.secondaryZone = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.sourceId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.rootPasswordSet = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.collation = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.cmekKeyName = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.availabilityType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlSettings {
    return {
      databaseVersion: isSet(object.databaseVersion)
        ? cloudSqlSettings_SqlDatabaseVersionFromJSON(object.databaseVersion)
        : 0,
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tier: isSet(object.tier) ? globalThis.String(object.tier) : "",
      storageAutoResizeLimit: isSet(object.storageAutoResizeLimit)
        ? Long.fromValue(object.storageAutoResizeLimit)
        : undefined,
      activationPolicy: isSet(object.activationPolicy)
        ? cloudSqlSettings_SqlActivationPolicyFromJSON(object.activationPolicy)
        : 0,
      ipConfig: isSet(object.ipConfig) ? SqlIpConfig.fromJSON(object.ipConfig) : undefined,
      autoStorageIncrease: isSet(object.autoStorageIncrease) ? Boolean(object.autoStorageIncrease) : undefined,
      databaseFlags: isObject(object.databaseFlags)
        ? Object.entries(object.databaseFlags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      dataDiskType: isSet(object.dataDiskType) ? cloudSqlSettings_SqlDataDiskTypeFromJSON(object.dataDiskType) : 0,
      dataDiskSizeGb: isSet(object.dataDiskSizeGb) ? Long.fromValue(object.dataDiskSizeGb) : undefined,
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      secondaryZone: isSet(object.secondaryZone) ? globalThis.String(object.secondaryZone) : "",
      sourceId: isSet(object.sourceId) ? globalThis.String(object.sourceId) : "",
      rootPasswordSet: isSet(object.rootPasswordSet) ? globalThis.Boolean(object.rootPasswordSet) : false,
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      cmekKeyName: isSet(object.cmekKeyName) ? globalThis.String(object.cmekKeyName) : "",
      availabilityType: isSet(object.availabilityType)
        ? cloudSqlSettings_SqlAvailabilityTypeFromJSON(object.availabilityType)
        : 0,
    };
  },

  toJSON(message: CloudSqlSettings): unknown {
    const obj: any = {};
    if (message.databaseVersion !== 0) {
      obj.databaseVersion = cloudSqlSettings_SqlDatabaseVersionToJSON(message.databaseVersion);
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    if (message.tier !== "") {
      obj.tier = message.tier;
    }
    if (message.storageAutoResizeLimit !== undefined) {
      obj.storageAutoResizeLimit = message.storageAutoResizeLimit;
    }
    if (message.activationPolicy !== 0) {
      obj.activationPolicy = cloudSqlSettings_SqlActivationPolicyToJSON(message.activationPolicy);
    }
    if (message.ipConfig !== undefined) {
      obj.ipConfig = SqlIpConfig.toJSON(message.ipConfig);
    }
    if (message.autoStorageIncrease !== undefined) {
      obj.autoStorageIncrease = message.autoStorageIncrease;
    }
    if (message.databaseFlags) {
      const entries = Object.entries(message.databaseFlags);
      if (entries.length > 0) {
        obj.databaseFlags = {};
        entries.forEach(([k, v]) => {
          obj.databaseFlags[k] = v;
        });
      }
    }
    if (message.dataDiskType !== 0) {
      obj.dataDiskType = cloudSqlSettings_SqlDataDiskTypeToJSON(message.dataDiskType);
    }
    if (message.dataDiskSizeGb !== undefined) {
      obj.dataDiskSizeGb = message.dataDiskSizeGb;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.secondaryZone !== "") {
      obj.secondaryZone = message.secondaryZone;
    }
    if (message.sourceId !== "") {
      obj.sourceId = message.sourceId;
    }
    if (message.rootPasswordSet !== false) {
      obj.rootPasswordSet = message.rootPasswordSet;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.cmekKeyName !== "") {
      obj.cmekKeyName = message.cmekKeyName;
    }
    if (message.availabilityType !== 0) {
      obj.availabilityType = cloudSqlSettings_SqlAvailabilityTypeToJSON(message.availabilityType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudSqlSettings>, I>>(base?: I): CloudSqlSettings {
    return CloudSqlSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudSqlSettings>, I>>(object: I): CloudSqlSettings {
    const message = createBaseCloudSqlSettings();
    message.databaseVersion = object.databaseVersion ?? 0;
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.tier = object.tier ?? "";
    message.storageAutoResizeLimit =
      (object.storageAutoResizeLimit !== undefined && object.storageAutoResizeLimit !== null)
        ? Long.fromValue(object.storageAutoResizeLimit)
        : undefined;
    message.activationPolicy = object.activationPolicy ?? 0;
    message.ipConfig = (object.ipConfig !== undefined && object.ipConfig !== null)
      ? SqlIpConfig.fromPartial(object.ipConfig)
      : undefined;
    message.autoStorageIncrease = object.autoStorageIncrease ?? undefined;
    message.databaseFlags = Object.entries(object.databaseFlags ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.dataDiskType = object.dataDiskType ?? 0;
    message.dataDiskSizeGb = (object.dataDiskSizeGb !== undefined && object.dataDiskSizeGb !== null)
      ? Long.fromValue(object.dataDiskSizeGb)
      : undefined;
    message.zone = object.zone ?? "";
    message.secondaryZone = object.secondaryZone ?? "";
    message.sourceId = object.sourceId ?? "";
    message.rootPasswordSet = object.rootPasswordSet ?? false;
    message.collation = object.collation ?? "";
    message.cmekKeyName = object.cmekKeyName ?? "";
    message.availabilityType = object.availabilityType ?? 0;
    return message;
  },
};

function createBaseCloudSqlSettings_UserLabelsEntry(): CloudSqlSettings_UserLabelsEntry {
  return { key: "", value: "" };
}

export const CloudSqlSettings_UserLabelsEntry: MessageFns<CloudSqlSettings_UserLabelsEntry> = {
  encode(message: CloudSqlSettings_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlSettings_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlSettings_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlSettings_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CloudSqlSettings_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudSqlSettings_UserLabelsEntry>, I>>(
    base?: I,
  ): CloudSqlSettings_UserLabelsEntry {
    return CloudSqlSettings_UserLabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudSqlSettings_UserLabelsEntry>, I>>(
    object: I,
  ): CloudSqlSettings_UserLabelsEntry {
    const message = createBaseCloudSqlSettings_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCloudSqlSettings_DatabaseFlagsEntry(): CloudSqlSettings_DatabaseFlagsEntry {
  return { key: "", value: "" };
}

export const CloudSqlSettings_DatabaseFlagsEntry: MessageFns<CloudSqlSettings_DatabaseFlagsEntry> = {
  encode(message: CloudSqlSettings_DatabaseFlagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlSettings_DatabaseFlagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlSettings_DatabaseFlagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlSettings_DatabaseFlagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CloudSqlSettings_DatabaseFlagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudSqlSettings_DatabaseFlagsEntry>, I>>(
    base?: I,
  ): CloudSqlSettings_DatabaseFlagsEntry {
    return CloudSqlSettings_DatabaseFlagsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudSqlSettings_DatabaseFlagsEntry>, I>>(
    object: I,
  ): CloudSqlSettings_DatabaseFlagsEntry {
    const message = createBaseCloudSqlSettings_DatabaseFlagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAlloyDbSettings(): AlloyDbSettings {
  return { vpcNetwork: "", labels: {}, primaryInstanceSettings: undefined };
}

export const AlloyDbSettings: MessageFns<AlloyDbSettings> = {
  encode(message: AlloyDbSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vpcNetwork !== "") {
      writer.uint32(18).string(message.vpcNetwork);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      AlloyDbSettings_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.primaryInstanceSettings !== undefined) {
      AlloyDbSettings_PrimaryInstanceSettings.encode(message.primaryInstanceSettings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlloyDbSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlloyDbSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vpcNetwork = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = AlloyDbSettings_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.primaryInstanceSettings = AlloyDbSettings_PrimaryInstanceSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlloyDbSettings {
    return {
      vpcNetwork: isSet(object.vpcNetwork) ? globalThis.String(object.vpcNetwork) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      primaryInstanceSettings: isSet(object.primaryInstanceSettings)
        ? AlloyDbSettings_PrimaryInstanceSettings.fromJSON(object.primaryInstanceSettings)
        : undefined,
    };
  },

  toJSON(message: AlloyDbSettings): unknown {
    const obj: any = {};
    if (message.vpcNetwork !== "") {
      obj.vpcNetwork = message.vpcNetwork;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.primaryInstanceSettings !== undefined) {
      obj.primaryInstanceSettings = AlloyDbSettings_PrimaryInstanceSettings.toJSON(message.primaryInstanceSettings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlloyDbSettings>, I>>(base?: I): AlloyDbSettings {
    return AlloyDbSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlloyDbSettings>, I>>(object: I): AlloyDbSettings {
    const message = createBaseAlloyDbSettings();
    message.vpcNetwork = object.vpcNetwork ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.primaryInstanceSettings =
      (object.primaryInstanceSettings !== undefined && object.primaryInstanceSettings !== null)
        ? AlloyDbSettings_PrimaryInstanceSettings.fromPartial(object.primaryInstanceSettings)
        : undefined;
    return message;
  },
};

function createBaseAlloyDbSettings_UserPassword(): AlloyDbSettings_UserPassword {
  return { user: "", passwordSet: false };
}

export const AlloyDbSettings_UserPassword: MessageFns<AlloyDbSettings_UserPassword> = {
  encode(message: AlloyDbSettings_UserPassword, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.passwordSet !== false) {
      writer.uint32(24).bool(message.passwordSet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlloyDbSettings_UserPassword {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlloyDbSettings_UserPassword();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.passwordSet = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlloyDbSettings_UserPassword {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      passwordSet: isSet(object.passwordSet) ? globalThis.Boolean(object.passwordSet) : false,
    };
  },

  toJSON(message: AlloyDbSettings_UserPassword): unknown {
    const obj: any = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.passwordSet !== false) {
      obj.passwordSet = message.passwordSet;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlloyDbSettings_UserPassword>, I>>(base?: I): AlloyDbSettings_UserPassword {
    return AlloyDbSettings_UserPassword.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlloyDbSettings_UserPassword>, I>>(object: I): AlloyDbSettings_UserPassword {
    const message = createBaseAlloyDbSettings_UserPassword();
    message.user = object.user ?? "";
    message.passwordSet = object.passwordSet ?? false;
    return message;
  },
};

function createBaseAlloyDbSettings_PrimaryInstanceSettings(): AlloyDbSettings_PrimaryInstanceSettings {
  return { id: "", machineConfig: undefined, databaseFlags: {}, labels: {}, privateIp: "" };
}

export const AlloyDbSettings_PrimaryInstanceSettings: MessageFns<AlloyDbSettings_PrimaryInstanceSettings> = {
  encode(message: AlloyDbSettings_PrimaryInstanceSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.machineConfig !== undefined) {
      AlloyDbSettings_PrimaryInstanceSettings_MachineConfig.encode(message.machineConfig, writer.uint32(18).fork())
        .join();
    }
    Object.entries(message.databaseFlags).forEach(([key, value]) => {
      AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry.encode(
        { key: key as any, value },
        writer.uint32(50).fork(),
      ).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork())
        .join();
    });
    if (message.privateIp !== "") {
      writer.uint32(66).string(message.privateIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlloyDbSettings_PrimaryInstanceSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlloyDbSettings_PrimaryInstanceSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.machineConfig = AlloyDbSettings_PrimaryInstanceSettings_MachineConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.databaseFlags[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.privateIp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlloyDbSettings_PrimaryInstanceSettings {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      machineConfig: isSet(object.machineConfig)
        ? AlloyDbSettings_PrimaryInstanceSettings_MachineConfig.fromJSON(object.machineConfig)
        : undefined,
      databaseFlags: isObject(object.databaseFlags)
        ? Object.entries(object.databaseFlags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      privateIp: isSet(object.privateIp) ? globalThis.String(object.privateIp) : "",
    };
  },

  toJSON(message: AlloyDbSettings_PrimaryInstanceSettings): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.machineConfig !== undefined) {
      obj.machineConfig = AlloyDbSettings_PrimaryInstanceSettings_MachineConfig.toJSON(message.machineConfig);
    }
    if (message.databaseFlags) {
      const entries = Object.entries(message.databaseFlags);
      if (entries.length > 0) {
        obj.databaseFlags = {};
        entries.forEach(([k, v]) => {
          obj.databaseFlags[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.privateIp !== "") {
      obj.privateIp = message.privateIp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlloyDbSettings_PrimaryInstanceSettings>, I>>(
    base?: I,
  ): AlloyDbSettings_PrimaryInstanceSettings {
    return AlloyDbSettings_PrimaryInstanceSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlloyDbSettings_PrimaryInstanceSettings>, I>>(
    object: I,
  ): AlloyDbSettings_PrimaryInstanceSettings {
    const message = createBaseAlloyDbSettings_PrimaryInstanceSettings();
    message.id = object.id ?? "";
    message.machineConfig = (object.machineConfig !== undefined && object.machineConfig !== null)
      ? AlloyDbSettings_PrimaryInstanceSettings_MachineConfig.fromPartial(object.machineConfig)
      : undefined;
    message.databaseFlags = Object.entries(object.databaseFlags ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.privateIp = object.privateIp ?? "";
    return message;
  },
};

function createBaseAlloyDbSettings_PrimaryInstanceSettings_MachineConfig(): AlloyDbSettings_PrimaryInstanceSettings_MachineConfig {
  return { cpuCount: 0 };
}

export const AlloyDbSettings_PrimaryInstanceSettings_MachineConfig: MessageFns<
  AlloyDbSettings_PrimaryInstanceSettings_MachineConfig
> = {
  encode(
    message: AlloyDbSettings_PrimaryInstanceSettings_MachineConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cpuCount !== 0) {
      writer.uint32(8).int32(message.cpuCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlloyDbSettings_PrimaryInstanceSettings_MachineConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlloyDbSettings_PrimaryInstanceSettings_MachineConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cpuCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlloyDbSettings_PrimaryInstanceSettings_MachineConfig {
    return { cpuCount: isSet(object.cpuCount) ? globalThis.Number(object.cpuCount) : 0 };
  },

  toJSON(message: AlloyDbSettings_PrimaryInstanceSettings_MachineConfig): unknown {
    const obj: any = {};
    if (message.cpuCount !== 0) {
      obj.cpuCount = Math.round(message.cpuCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlloyDbSettings_PrimaryInstanceSettings_MachineConfig>, I>>(
    base?: I,
  ): AlloyDbSettings_PrimaryInstanceSettings_MachineConfig {
    return AlloyDbSettings_PrimaryInstanceSettings_MachineConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlloyDbSettings_PrimaryInstanceSettings_MachineConfig>, I>>(
    object: I,
  ): AlloyDbSettings_PrimaryInstanceSettings_MachineConfig {
    const message = createBaseAlloyDbSettings_PrimaryInstanceSettings_MachineConfig();
    message.cpuCount = object.cpuCount ?? 0;
    return message;
  },
};

function createBaseAlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry(): AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry {
  return { key: "", value: "" };
}

export const AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry: MessageFns<
  AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry
> = {
  encode(
    message: AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry>, I>>(
    base?: I,
  ): AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry {
    return AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry>, I>>(
    object: I,
  ): AlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry {
    const message = createBaseAlloyDbSettings_PrimaryInstanceSettings_DatabaseFlagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAlloyDbSettings_PrimaryInstanceSettings_LabelsEntry(): AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry {
  return { key: "", value: "" };
}

export const AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry: MessageFns<
  AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry
> = {
  encode(
    message: AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlloyDbSettings_PrimaryInstanceSettings_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry>, I>>(
    base?: I,
  ): AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry {
    return AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry>, I>>(
    object: I,
  ): AlloyDbSettings_PrimaryInstanceSettings_LabelsEntry {
    const message = createBaseAlloyDbSettings_PrimaryInstanceSettings_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAlloyDbSettings_LabelsEntry(): AlloyDbSettings_LabelsEntry {
  return { key: "", value: "" };
}

export const AlloyDbSettings_LabelsEntry: MessageFns<AlloyDbSettings_LabelsEntry> = {
  encode(message: AlloyDbSettings_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlloyDbSettings_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlloyDbSettings_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlloyDbSettings_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AlloyDbSettings_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlloyDbSettings_LabelsEntry>, I>>(base?: I): AlloyDbSettings_LabelsEntry {
    return AlloyDbSettings_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlloyDbSettings_LabelsEntry>, I>>(object: I): AlloyDbSettings_LabelsEntry {
    const message = createBaseAlloyDbSettings_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStaticIpConnectivity(): StaticIpConnectivity {
  return {};
}

export const StaticIpConnectivity: MessageFns<StaticIpConnectivity> = {
  encode(_: StaticIpConnectivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StaticIpConnectivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaticIpConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StaticIpConnectivity {
    return {};
  },

  toJSON(_: StaticIpConnectivity): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StaticIpConnectivity>, I>>(base?: I): StaticIpConnectivity {
    return StaticIpConnectivity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StaticIpConnectivity>, I>>(_: I): StaticIpConnectivity {
    const message = createBaseStaticIpConnectivity();
    return message;
  },
};

function createBaseReverseSshConnectivity(): ReverseSshConnectivity {
  return { vmIp: "", vmPort: 0, vm: "", vpc: "" };
}

export const ReverseSshConnectivity: MessageFns<ReverseSshConnectivity> = {
  encode(message: ReverseSshConnectivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmIp !== "") {
      writer.uint32(10).string(message.vmIp);
    }
    if (message.vmPort !== 0) {
      writer.uint32(16).int32(message.vmPort);
    }
    if (message.vm !== "") {
      writer.uint32(26).string(message.vm);
    }
    if (message.vpc !== "") {
      writer.uint32(34).string(message.vpc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReverseSshConnectivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReverseSshConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vmIp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vmPort = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vpc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReverseSshConnectivity {
    return {
      vmIp: isSet(object.vmIp) ? globalThis.String(object.vmIp) : "",
      vmPort: isSet(object.vmPort) ? globalThis.Number(object.vmPort) : 0,
      vm: isSet(object.vm) ? globalThis.String(object.vm) : "",
      vpc: isSet(object.vpc) ? globalThis.String(object.vpc) : "",
    };
  },

  toJSON(message: ReverseSshConnectivity): unknown {
    const obj: any = {};
    if (message.vmIp !== "") {
      obj.vmIp = message.vmIp;
    }
    if (message.vmPort !== 0) {
      obj.vmPort = Math.round(message.vmPort);
    }
    if (message.vm !== "") {
      obj.vm = message.vm;
    }
    if (message.vpc !== "") {
      obj.vpc = message.vpc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReverseSshConnectivity>, I>>(base?: I): ReverseSshConnectivity {
    return ReverseSshConnectivity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReverseSshConnectivity>, I>>(object: I): ReverseSshConnectivity {
    const message = createBaseReverseSshConnectivity();
    message.vmIp = object.vmIp ?? "";
    message.vmPort = object.vmPort ?? 0;
    message.vm = object.vm ?? "";
    message.vpc = object.vpc ?? "";
    return message;
  },
};

function createBaseVpcPeeringConnectivity(): VpcPeeringConnectivity {
  return { vpc: "" };
}

export const VpcPeeringConnectivity: MessageFns<VpcPeeringConnectivity> = {
  encode(message: VpcPeeringConnectivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vpc !== "") {
      writer.uint32(10).string(message.vpc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpcPeeringConnectivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpcPeeringConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vpc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpcPeeringConnectivity {
    return { vpc: isSet(object.vpc) ? globalThis.String(object.vpc) : "" };
  },

  toJSON(message: VpcPeeringConnectivity): unknown {
    const obj: any = {};
    if (message.vpc !== "") {
      obj.vpc = message.vpc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VpcPeeringConnectivity>, I>>(base?: I): VpcPeeringConnectivity {
    return VpcPeeringConnectivity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VpcPeeringConnectivity>, I>>(object: I): VpcPeeringConnectivity {
    const message = createBaseVpcPeeringConnectivity();
    message.vpc = object.vpc ?? "";
    return message;
  },
};

function createBaseDatabaseType(): DatabaseType {
  return { provider: 0, engine: 0 };
}

export const DatabaseType: MessageFns<DatabaseType> = {
  encode(message: DatabaseType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.engine !== 0) {
      writer.uint32(16).int32(message.engine);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.engine = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseType {
    return {
      provider: isSet(object.provider) ? databaseProviderFromJSON(object.provider) : 0,
      engine: isSet(object.engine) ? databaseEngineFromJSON(object.engine) : 0,
    };
  },

  toJSON(message: DatabaseType): unknown {
    const obj: any = {};
    if (message.provider !== 0) {
      obj.provider = databaseProviderToJSON(message.provider);
    }
    if (message.engine !== 0) {
      obj.engine = databaseEngineToJSON(message.engine);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabaseType>, I>>(base?: I): DatabaseType {
    return DatabaseType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabaseType>, I>>(object: I): DatabaseType {
    const message = createBaseDatabaseType();
    message.provider = object.provider ?? 0;
    message.engine = object.engine ?? 0;
    return message;
  },
};

function createBaseMigrationJob(): MigrationJob {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    state: 0,
    phase: 0,
    type: 0,
    dumpPath: "",
    dumpFlags: undefined,
    source: "",
    destination: "",
    reverseSshConnectivity: undefined,
    vpcPeeringConnectivity: undefined,
    staticIpConnectivity: undefined,
    duration: undefined,
    error: undefined,
    sourceDatabase: undefined,
    destinationDatabase: undefined,
    endTime: undefined,
  };
}

export const MigrationJob: MessageFns<MigrationJob> = {
  encode(message: MigrationJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      MigrationJob_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.phase !== 0) {
      writer.uint32(56).int32(message.phase);
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    if (message.dumpPath !== "") {
      writer.uint32(74).string(message.dumpPath);
    }
    if (message.dumpFlags !== undefined) {
      MigrationJob_DumpFlags.encode(message.dumpFlags, writer.uint32(138).fork()).join();
    }
    if (message.source !== "") {
      writer.uint32(82).string(message.source);
    }
    if (message.destination !== "") {
      writer.uint32(90).string(message.destination);
    }
    if (message.reverseSshConnectivity !== undefined) {
      ReverseSshConnectivity.encode(message.reverseSshConnectivity, writer.uint32(810).fork()).join();
    }
    if (message.vpcPeeringConnectivity !== undefined) {
      VpcPeeringConnectivity.encode(message.vpcPeeringConnectivity, writer.uint32(818).fork()).join();
    }
    if (message.staticIpConnectivity !== undefined) {
      StaticIpConnectivity.encode(message.staticIpConnectivity, writer.uint32(826).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(98).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(106).fork()).join();
    }
    if (message.sourceDatabase !== undefined) {
      DatabaseType.encode(message.sourceDatabase, writer.uint32(114).fork()).join();
    }
    if (message.destinationDatabase !== undefined) {
      DatabaseType.encode(message.destinationDatabase, writer.uint32(122).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = MigrationJob_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dumpPath = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.dumpFlags = MigrationJob_DumpFlags.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.destination = reader.string();
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.reverseSshConnectivity = ReverseSshConnectivity.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.vpcPeeringConnectivity = VpcPeeringConnectivity.decode(reader, reader.uint32());
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.staticIpConnectivity = StaticIpConnectivity.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.sourceDatabase = DatabaseType.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.destinationDatabase = DatabaseType.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationJob {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? migrationJob_StateFromJSON(object.state) : 0,
      phase: isSet(object.phase) ? migrationJob_PhaseFromJSON(object.phase) : 0,
      type: isSet(object.type) ? migrationJob_TypeFromJSON(object.type) : 0,
      dumpPath: isSet(object.dumpPath) ? globalThis.String(object.dumpPath) : "",
      dumpFlags: isSet(object.dumpFlags) ? MigrationJob_DumpFlags.fromJSON(object.dumpFlags) : undefined,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      reverseSshConnectivity: isSet(object.reverseSshConnectivity)
        ? ReverseSshConnectivity.fromJSON(object.reverseSshConnectivity)
        : undefined,
      vpcPeeringConnectivity: isSet(object.vpcPeeringConnectivity)
        ? VpcPeeringConnectivity.fromJSON(object.vpcPeeringConnectivity)
        : undefined,
      staticIpConnectivity: isSet(object.staticIpConnectivity)
        ? StaticIpConnectivity.fromJSON(object.staticIpConnectivity)
        : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      sourceDatabase: isSet(object.sourceDatabase) ? DatabaseType.fromJSON(object.sourceDatabase) : undefined,
      destinationDatabase: isSet(object.destinationDatabase)
        ? DatabaseType.fromJSON(object.destinationDatabase)
        : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: MigrationJob): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = migrationJob_StateToJSON(message.state);
    }
    if (message.phase !== 0) {
      obj.phase = migrationJob_PhaseToJSON(message.phase);
    }
    if (message.type !== 0) {
      obj.type = migrationJob_TypeToJSON(message.type);
    }
    if (message.dumpPath !== "") {
      obj.dumpPath = message.dumpPath;
    }
    if (message.dumpFlags !== undefined) {
      obj.dumpFlags = MigrationJob_DumpFlags.toJSON(message.dumpFlags);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.reverseSshConnectivity !== undefined) {
      obj.reverseSshConnectivity = ReverseSshConnectivity.toJSON(message.reverseSshConnectivity);
    }
    if (message.vpcPeeringConnectivity !== undefined) {
      obj.vpcPeeringConnectivity = VpcPeeringConnectivity.toJSON(message.vpcPeeringConnectivity);
    }
    if (message.staticIpConnectivity !== undefined) {
      obj.staticIpConnectivity = StaticIpConnectivity.toJSON(message.staticIpConnectivity);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.sourceDatabase !== undefined) {
      obj.sourceDatabase = DatabaseType.toJSON(message.sourceDatabase);
    }
    if (message.destinationDatabase !== undefined) {
      obj.destinationDatabase = DatabaseType.toJSON(message.destinationDatabase);
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MigrationJob>, I>>(base?: I): MigrationJob {
    return MigrationJob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MigrationJob>, I>>(object: I): MigrationJob {
    const message = createBaseMigrationJob();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.phase = object.phase ?? 0;
    message.type = object.type ?? 0;
    message.dumpPath = object.dumpPath ?? "";
    message.dumpFlags = (object.dumpFlags !== undefined && object.dumpFlags !== null)
      ? MigrationJob_DumpFlags.fromPartial(object.dumpFlags)
      : undefined;
    message.source = object.source ?? "";
    message.destination = object.destination ?? "";
    message.reverseSshConnectivity =
      (object.reverseSshConnectivity !== undefined && object.reverseSshConnectivity !== null)
        ? ReverseSshConnectivity.fromPartial(object.reverseSshConnectivity)
        : undefined;
    message.vpcPeeringConnectivity =
      (object.vpcPeeringConnectivity !== undefined && object.vpcPeeringConnectivity !== null)
        ? VpcPeeringConnectivity.fromPartial(object.vpcPeeringConnectivity)
        : undefined;
    message.staticIpConnectivity = (object.staticIpConnectivity !== undefined && object.staticIpConnectivity !== null)
      ? StaticIpConnectivity.fromPartial(object.staticIpConnectivity)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.sourceDatabase = (object.sourceDatabase !== undefined && object.sourceDatabase !== null)
      ? DatabaseType.fromPartial(object.sourceDatabase)
      : undefined;
    message.destinationDatabase = (object.destinationDatabase !== undefined && object.destinationDatabase !== null)
      ? DatabaseType.fromPartial(object.destinationDatabase)
      : undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseMigrationJob_DumpFlag(): MigrationJob_DumpFlag {
  return { name: "", value: "" };
}

export const MigrationJob_DumpFlag: MessageFns<MigrationJob_DumpFlag> = {
  encode(message: MigrationJob_DumpFlag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationJob_DumpFlag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationJob_DumpFlag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationJob_DumpFlag {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MigrationJob_DumpFlag): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MigrationJob_DumpFlag>, I>>(base?: I): MigrationJob_DumpFlag {
    return MigrationJob_DumpFlag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MigrationJob_DumpFlag>, I>>(object: I): MigrationJob_DumpFlag {
    const message = createBaseMigrationJob_DumpFlag();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMigrationJob_DumpFlags(): MigrationJob_DumpFlags {
  return { dumpFlags: [] };
}

export const MigrationJob_DumpFlags: MessageFns<MigrationJob_DumpFlags> = {
  encode(message: MigrationJob_DumpFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dumpFlags) {
      MigrationJob_DumpFlag.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationJob_DumpFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationJob_DumpFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dumpFlags.push(MigrationJob_DumpFlag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationJob_DumpFlags {
    return {
      dumpFlags: globalThis.Array.isArray(object?.dumpFlags)
        ? object.dumpFlags.map((e: any) => MigrationJob_DumpFlag.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MigrationJob_DumpFlags): unknown {
    const obj: any = {};
    if (message.dumpFlags?.length) {
      obj.dumpFlags = message.dumpFlags.map((e) => MigrationJob_DumpFlag.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MigrationJob_DumpFlags>, I>>(base?: I): MigrationJob_DumpFlags {
    return MigrationJob_DumpFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MigrationJob_DumpFlags>, I>>(object: I): MigrationJob_DumpFlags {
    const message = createBaseMigrationJob_DumpFlags();
    message.dumpFlags = object.dumpFlags?.map((e) => MigrationJob_DumpFlag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMigrationJob_LabelsEntry(): MigrationJob_LabelsEntry {
  return { key: "", value: "" };
}

export const MigrationJob_LabelsEntry: MessageFns<MigrationJob_LabelsEntry> = {
  encode(message: MigrationJob_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationJob_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationJob_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationJob_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MigrationJob_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MigrationJob_LabelsEntry>, I>>(base?: I): MigrationJob_LabelsEntry {
    return MigrationJob_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MigrationJob_LabelsEntry>, I>>(object: I): MigrationJob_LabelsEntry {
    const message = createBaseMigrationJob_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConnectionProfile(): ConnectionProfile {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    state: 0,
    displayName: "",
    mysql: undefined,
    postgresql: undefined,
    cloudsql: undefined,
    alloydb: undefined,
    error: undefined,
    provider: 0,
  };
}

export const ConnectionProfile: MessageFns<ConnectionProfile> = {
  encode(message: ConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ConnectionProfile_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    if (message.mysql !== undefined) {
      MySqlConnectionProfile.encode(message.mysql, writer.uint32(802).fork()).join();
    }
    if (message.postgresql !== undefined) {
      PostgreSqlConnectionProfile.encode(message.postgresql, writer.uint32(810).fork()).join();
    }
    if (message.cloudsql !== undefined) {
      CloudSqlConnectionProfile.encode(message.cloudsql, writer.uint32(818).fork()).join();
    }
    if (message.alloydb !== undefined) {
      AlloyDbConnectionProfile.encode(message.alloydb, writer.uint32(842).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(58).fork()).join();
    }
    if (message.provider !== 0) {
      writer.uint32(64).int32(message.provider);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ConnectionProfile_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.mysql = MySqlConnectionProfile.decode(reader, reader.uint32());
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.postgresql = PostgreSqlConnectionProfile.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.cloudsql = CloudSqlConnectionProfile.decode(reader, reader.uint32());
          continue;
        }
        case 105: {
          if (tag !== 842) {
            break;
          }

          message.alloydb = AlloyDbConnectionProfile.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionProfile {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      state: isSet(object.state) ? connectionProfile_StateFromJSON(object.state) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      mysql: isSet(object.mysql) ? MySqlConnectionProfile.fromJSON(object.mysql) : undefined,
      postgresql: isSet(object.postgresql) ? PostgreSqlConnectionProfile.fromJSON(object.postgresql) : undefined,
      cloudsql: isSet(object.cloudsql) ? CloudSqlConnectionProfile.fromJSON(object.cloudsql) : undefined,
      alloydb: isSet(object.alloydb) ? AlloyDbConnectionProfile.fromJSON(object.alloydb) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      provider: isSet(object.provider) ? databaseProviderFromJSON(object.provider) : 0,
    };
  },

  toJSON(message: ConnectionProfile): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.state !== 0) {
      obj.state = connectionProfile_StateToJSON(message.state);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.mysql !== undefined) {
      obj.mysql = MySqlConnectionProfile.toJSON(message.mysql);
    }
    if (message.postgresql !== undefined) {
      obj.postgresql = PostgreSqlConnectionProfile.toJSON(message.postgresql);
    }
    if (message.cloudsql !== undefined) {
      obj.cloudsql = CloudSqlConnectionProfile.toJSON(message.cloudsql);
    }
    if (message.alloydb !== undefined) {
      obj.alloydb = AlloyDbConnectionProfile.toJSON(message.alloydb);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.provider !== 0) {
      obj.provider = databaseProviderToJSON(message.provider);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionProfile>, I>>(base?: I): ConnectionProfile {
    return ConnectionProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionProfile>, I>>(object: I): ConnectionProfile {
    const message = createBaseConnectionProfile();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.displayName = object.displayName ?? "";
    message.mysql = (object.mysql !== undefined && object.mysql !== null)
      ? MySqlConnectionProfile.fromPartial(object.mysql)
      : undefined;
    message.postgresql = (object.postgresql !== undefined && object.postgresql !== null)
      ? PostgreSqlConnectionProfile.fromPartial(object.postgresql)
      : undefined;
    message.cloudsql = (object.cloudsql !== undefined && object.cloudsql !== null)
      ? CloudSqlConnectionProfile.fromPartial(object.cloudsql)
      : undefined;
    message.alloydb = (object.alloydb !== undefined && object.alloydb !== null)
      ? AlloyDbConnectionProfile.fromPartial(object.alloydb)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.provider = object.provider ?? 0;
    return message;
  },
};

function createBaseConnectionProfile_LabelsEntry(): ConnectionProfile_LabelsEntry {
  return { key: "", value: "" };
}

export const ConnectionProfile_LabelsEntry: MessageFns<ConnectionProfile_LabelsEntry> = {
  encode(message: ConnectionProfile_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionProfile_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionProfile_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionProfile_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConnectionProfile_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionProfile_LabelsEntry>, I>>(base?: I): ConnectionProfile_LabelsEntry {
    return ConnectionProfile_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionProfile_LabelsEntry>, I>>(
    object: I,
  ): ConnectionProfile_LabelsEntry {
    const message = createBaseConnectionProfile_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConnectionProfileEventData(): ConnectionProfileEventData {
  return { payload: undefined };
}

export const ConnectionProfileEventData: MessageFns<ConnectionProfileEventData> = {
  encode(message: ConnectionProfileEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ConnectionProfile.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionProfileEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionProfileEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ConnectionProfile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionProfileEventData {
    return { payload: isSet(object.payload) ? ConnectionProfile.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ConnectionProfileEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ConnectionProfile.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionProfileEventData>, I>>(base?: I): ConnectionProfileEventData {
    return ConnectionProfileEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionProfileEventData>, I>>(object: I): ConnectionProfileEventData {
    const message = createBaseConnectionProfileEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ConnectionProfile.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseMigrationJobEventData(): MigrationJobEventData {
  return { payload: undefined };
}

export const MigrationJobEventData: MessageFns<MigrationJobEventData> = {
  encode(message: MigrationJobEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      MigrationJob.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationJobEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationJobEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = MigrationJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationJobEventData {
    return { payload: isSet(object.payload) ? MigrationJob.fromJSON(object.payload) : undefined };
  },

  toJSON(message: MigrationJobEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = MigrationJob.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MigrationJobEventData>, I>>(base?: I): MigrationJobEventData {
    return MigrationJobEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MigrationJobEventData>, I>>(object: I): MigrationJobEventData {
    const message = createBaseMigrationJobEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? MigrationJob.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
