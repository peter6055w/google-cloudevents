// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/eventarc/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";
import { Code, codeFromJSON, codeToJSON } from "../../../../rpc/code";

export const protobufPackage = "google.events.cloud.eventarc.v1";

/**
 * A representation of the Channel resource.
 * A Channel is a resource on which event providers publish their events.
 * The published events are delivered through the transport associated with the
 * channel. Note that a channel is associated with exactly one event provider.
 */
export interface Channel {
  /**
   * Required. The resource name of the channel. Must be unique within the
   * location on the project and must be in
   * `projects/{project}/locations/{location}/channels/{channel_id}` format.
   */
  name: string;
  /**
   * Output only. Server assigned unique identifier for the channel. The value
   * is a UUID4 string and guaranteed to remain unchanged until the resource is
   * deleted.
   */
  uid: string;
  /** Output only. The creation time. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The last-modified time. */
  updateTime?:
    | Date
    | undefined;
  /**
   * The name of the event provider (e.g. Eventarc SaaS partner) associated
   * with the channel. This provider will be granted permissions to publish
   * events to the channel. Format:
   * `projects/{project}/locations/{location}/providers/{provider_id}`.
   */
  provider: string;
  /**
   * Output only. The name of the Pub/Sub topic created and managed by
   * Eventarc system as a transport for the event delivery. Format:
   * `projects/{project}/topics/{topic_id}`.
   */
  pubsubTopic?:
    | string
    | undefined;
  /** Output only. The state of a Channel. */
  state: Channel_State;
  /**
   * Output only. The activation token for the channel. The token must be used
   * by the provider to register the channel for publishing.
   */
  activationToken: string;
  /**
   * Resource name of a KMS crypto key (managed by the user) used to
   * encrypt/decrypt their event data.
   *
   * It must match the pattern
   * `projects/* /locations/* /keyRings/* /cryptoKeys/*`.
   */
  cryptoKeyName: string;
}

/** State lists all the possible states of a Channel */
export enum Channel_State {
  /** STATE_UNSPECIFIED - Default value. This value is unused. */
  STATE_UNSPECIFIED = 0,
  /**
   * PENDING - The PENDING state indicates that a Channel has been created successfully
   * and there is a new activation token available for the subscriber to use
   * to convey the Channel to the provider in order to create a Connection.
   */
  PENDING = 1,
  /**
   * ACTIVE - The ACTIVE state indicates that a Channel has been successfully
   * connected with the event provider.
   * An ACTIVE Channel is ready to receive and route events from the
   * event provider.
   */
  ACTIVE = 2,
  /**
   * INACTIVE - The INACTIVE state indicates that the Channel cannot receive events
   * permanently. There are two possible cases this state can happen:
   *
   * 1. The SaaS provider disconnected from this Channel.
   * 2. The Channel activation token has expired but the SaaS provider
   *    wasn't connected.
   *
   * To re-establish a Connection with a provider, the subscriber
   * should create a new Channel and give it to the provider.
   */
  INACTIVE = 3,
  UNRECOGNIZED = -1,
}

export function channel_StateFromJSON(object: any): Channel_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Channel_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Channel_State.PENDING;
    case 2:
    case "ACTIVE":
      return Channel_State.ACTIVE;
    case 3:
    case "INACTIVE":
      return Channel_State.INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Channel_State.UNRECOGNIZED;
  }
}

export function channel_StateToJSON(object: Channel_State): string {
  switch (object) {
    case Channel_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Channel_State.PENDING:
      return "PENDING";
    case Channel_State.ACTIVE:
      return "ACTIVE";
    case Channel_State.INACTIVE:
      return "INACTIVE";
    case Channel_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A representation of the ChannelConnection resource.
 * A ChannelConnection is a resource which event providers create during the
 * activation process to establish a connection between the provider and the
 * subscriber channel.
 */
export interface ChannelConnection {
  /** Required. The name of the connection. */
  name: string;
  /**
   * Output only. Server assigned ID of the resource.
   * The server guarantees uniqueness and immutability until deleted.
   */
  uid: string;
  /**
   * Required. The name of the connected subscriber Channel.
   * This is a weak reference to avoid cross project and cross accounts
   * references. This must be in
   * `projects/{project}/location/{location}/channels/{channel_id}` format.
   */
  channel: string;
  /** Output only. The creation time. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The last-modified time. */
  updateTime?: Date | undefined;
}

/** A representation of the trigger resource. */
export interface Trigger {
  /**
   * Required. The resource name of the trigger. Must be unique within the
   * location of the project and must be in
   * `projects/{project}/locations/{location}/triggers/{trigger}` format.
   */
  name: string;
  /**
   * Output only. Server-assigned unique identifier for the trigger. The value
   * is a UUID4 string and guaranteed to remain unchanged until the resource is
   * deleted.
   */
  uid: string;
  /** Output only. The creation time. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The last-modified time. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Required. Unordered list. The list of filters that applies to event
   * attributes. Only events that match all the provided filters are sent to the
   * destination.
   */
  eventFilters: EventFilter[];
  /**
   * Optional. The IAM service account email associated with the trigger. The
   * service account represents the identity of the trigger.
   *
   * The principal who calls this API must have the `iam.serviceAccounts.actAs`
   * permission in the service account. See
   * https://cloud.google.com/iam/docs/understanding-service-accounts?hl=en#sa_common
   * for more information.
   *
   * For Cloud Run destinations, this service account is used to generate
   * identity tokens when invoking the service. See
   * https://cloud.google.com/run/docs/triggering/pubsub-push#create-service-account
   * for information on how to invoke authenticated Cloud Run services.
   * To create Audit Log triggers, the service account should also
   * have the `roles/eventarc.eventReceiver` IAM role.
   */
  serviceAccount: string;
  /** Required. Destination specifies where the events should be sent to. */
  destination?:
    | Destination
    | undefined;
  /**
   * Optional. To deliver messages, Eventarc might use other Google Cloud
   * products as a transport intermediary. This field contains a reference to
   * that transport intermediary. This information can be used for debugging
   * purposes.
   */
  transport?:
    | Transport
    | undefined;
  /**
   * Optional. User labels attached to the triggers that can be used to group
   * resources.
   */
  labels: { [key: string]: string };
  /**
   * Optional. The name of the channel associated with the trigger in
   * `projects/{project}/locations/{location}/channels/{channel}` format.
   * You must provide a channel to receive events from Eventarc SaaS partners.
   */
  channel: string;
  /** Output only. The reason(s) why a trigger is in FAILED state. */
  conditions: { [key: string]: StateCondition };
  /**
   * Optional. EventDataContentType specifies the type of payload in MIME
   * format that is expected from the CloudEvent data field. This is set to
   * `application/json` if the value is not defined.
   */
  eventDataContentType: string;
  /**
   * Output only. This checksum is computed by the server based on the value of
   * other fields, and might be sent only on create requests to ensure that the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

export interface Trigger_LabelsEntry {
  key: string;
  value: string;
}

export interface Trigger_ConditionsEntry {
  key: string;
  value?: StateCondition | undefined;
}

/** Filters events based on exact matches on the CloudEvents attributes. */
export interface EventFilter {
  /**
   * Required. The name of a CloudEvents attribute. Currently, only a subset of
   * attributes are supported for filtering.
   *
   * All triggers MUST provide a filter for the 'type' attribute.
   */
  attribute: string;
  /** Required. The value for the attribute. */
  value: string;
  /**
   * Optional. The operator used for matching the events with the value of the
   * filter. If not specified, only events that have an exact key-value pair
   * specified in the filter are matched. The only allowed value is
   * `match-path-pattern`.
   */
  operator: string;
}

/** A condition that is part of the trigger state computation. */
export interface StateCondition {
  /** The canonical code of the condition. */
  code: Code;
  /** Human-readable message. */
  message: string;
}

/** Represents a target of an invocation over HTTP. */
export interface Destination {
  /**
   * Cloud Run fully-managed resource that receives the events. The resource
   * should be in the same project as the trigger.
   */
  cloudRun?:
    | CloudRun
    | undefined;
  /**
   * The Cloud Function resource name. Only Cloud Functions V2 is supported.
   * Format: `projects/{project}/locations/{location}/functions/{function}`
   *
   * This is a read-only field. Creating Cloud Functions V2 triggers is only
   * supported via the Cloud Functions product. An error will be returned if
   * the user sets this value.
   */
  cloudFunction?:
    | string
    | undefined;
  /**
   * A GKE service capable of receiving events. The service should be running
   * in the same project as the trigger.
   */
  gke?:
    | GKE
    | undefined;
  /**
   * The resource name of the Workflow whose Executions are triggered by
   * the events. The Workflow resource should be deployed in the same project
   * as the trigger.
   * Format: `projects/{project}/locations/{location}/workflows/{workflow}`
   */
  workflow?: string | undefined;
}

/**
 * Represents the transport intermediaries created for the trigger to
 * deliver events.
 */
export interface Transport {
  /**
   * The Pub/Sub topic and subscription used by Eventarc as a transport
   * intermediary.
   */
  pubsub?: Pubsub | undefined;
}

/** Represents a Cloud Run destination. */
export interface CloudRun {
  /**
   * Required. The name of the Cloud Run service being addressed. See
   * https://cloud.google.com/run/docs/reference/rest/v1/namespaces.services.
   *
   * Only services located in the same project as the trigger object
   * can be addressed.
   */
  service: string;
  /**
   * Optional. The relative path on the Cloud Run service the events should be
   * sent to.
   *
   * The value must conform to the definition of a URI path segment (section 3.3
   * of RFC2396). Examples: "/route", "route", "route/subroute".
   */
  path: string;
  /** Required. The region the Cloud Run service is deployed in. */
  region: string;
}

/** Represents a GKE destination. */
export interface GKE {
  /**
   * Required. The name of the cluster the GKE service is running in. The
   * cluster must be running in the same project as the trigger being created.
   */
  cluster: string;
  /**
   * Required. The name of the Google Compute Engine in which the cluster
   * resides, which can either be compute zone (for example, us-central1-a) for
   * the zonal clusters or region (for example, us-central1) for regional
   * clusters.
   */
  location: string;
  /** Required. The namespace the GKE service is running in. */
  namespace: string;
  /** Required. Name of the GKE service. */
  service: string;
  /**
   * Optional. The relative path on the GKE service the events should be sent
   * to.
   *
   * The value must conform to the definition of a URI path segment (section 3.3
   * of RFC2396). Examples: "/route", "route", "route/subroute".
   */
  path: string;
}

/** Represents a Pub/Sub transport. */
export interface Pubsub {
  /**
   * Optional. The name of the Pub/Sub topic created and managed by Eventarc as
   * a transport for the event delivery. Format:
   * `projects/{PROJECT_ID}/topics/{TOPIC_NAME}`.
   *
   * You can set an existing topic for triggers of the type
   * `google.cloud.pubsub.topic.v1.messagePublished`. The topic you provide
   * here is not deleted by Eventarc at trigger deletion.
   */
  topic: string;
  /**
   * Output only. The name of the Pub/Sub subscription created and managed by
   * Eventarc as a transport for the event delivery. Format:
   * `projects/{PROJECT_ID}/subscriptions/{SUBSCRIPTION_NAME}`.
   */
  subscription: string;
}

/** The data within all Trigger events. */
export interface TriggerEventData {
  /** The Trigger event payload. */
  payload?: Trigger | undefined;
}

/** The data within all Channel events. */
export interface ChannelEventData {
  /** The Channel event payload. */
  payload?: Channel | undefined;
}

/** The data within all ChannelConnection events. */
export interface ChannelConnectionEventData {
  /** The ChannelConnection event payload. */
  payload?: ChannelConnection | undefined;
}

function createBaseChannel(): Channel {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    provider: "",
    pubsubTopic: undefined,
    state: 0,
    activationToken: "",
    cryptoKeyName: "",
  };
}

export const Channel: MessageFns<Channel> = {
  encode(message: Channel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.provider !== "") {
      writer.uint32(58).string(message.provider);
    }
    if (message.pubsubTopic !== undefined) {
      writer.uint32(66).string(message.pubsubTopic);
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    if (message.activationToken !== "") {
      writer.uint32(82).string(message.activationToken);
    }
    if (message.cryptoKeyName !== "") {
      writer.uint32(90).string(message.cryptoKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Channel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pubsubTopic = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.activationToken = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.cryptoKeyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      pubsubTopic: isSet(object.pubsubTopic) ? globalThis.String(object.pubsubTopic) : undefined,
      state: isSet(object.state) ? channel_StateFromJSON(object.state) : 0,
      activationToken: isSet(object.activationToken) ? globalThis.String(object.activationToken) : "",
      cryptoKeyName: isSet(object.cryptoKeyName) ? globalThis.String(object.cryptoKeyName) : "",
    };
  },

  toJSON(message: Channel): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.pubsubTopic !== undefined) {
      obj.pubsubTopic = message.pubsubTopic;
    }
    if (message.state !== 0) {
      obj.state = channel_StateToJSON(message.state);
    }
    if (message.activationToken !== "") {
      obj.activationToken = message.activationToken;
    }
    if (message.cryptoKeyName !== "") {
      obj.cryptoKeyName = message.cryptoKeyName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Channel>, I>>(base?: I): Channel {
    return Channel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Channel>, I>>(object: I): Channel {
    const message = createBaseChannel();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.provider = object.provider ?? "";
    message.pubsubTopic = object.pubsubTopic ?? undefined;
    message.state = object.state ?? 0;
    message.activationToken = object.activationToken ?? "";
    message.cryptoKeyName = object.cryptoKeyName ?? "";
    return message;
  },
};

function createBaseChannelConnection(): ChannelConnection {
  return { name: "", uid: "", channel: "", createTime: undefined, updateTime: undefined };
}

export const ChannelConnection: MessageFns<ChannelConnection> = {
  encode(message: ChannelConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.channel !== "") {
      writer.uint32(42).string(message.channel);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelConnection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: ChannelConnection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelConnection>, I>>(base?: I): ChannelConnection {
    return ChannelConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelConnection>, I>>(object: I): ChannelConnection {
    const message = createBaseChannelConnection();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.channel = object.channel ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseTrigger(): Trigger {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    eventFilters: [],
    serviceAccount: "",
    destination: undefined,
    transport: undefined,
    labels: {},
    channel: "",
    conditions: {},
    eventDataContentType: "",
    etag: "",
  };
}

export const Trigger: MessageFns<Trigger> = {
  encode(message: Trigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.eventFilters) {
      EventFilter.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.serviceAccount !== "") {
      writer.uint32(74).string(message.serviceAccount);
    }
    if (message.destination !== undefined) {
      Destination.encode(message.destination, writer.uint32(82).fork()).join();
    }
    if (message.transport !== undefined) {
      Transport.encode(message.transport, writer.uint32(90).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Trigger_LabelsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.channel !== "") {
      writer.uint32(106).string(message.channel);
    }
    Object.entries(message.conditions).forEach(([key, value]) => {
      Trigger_ConditionsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.eventDataContentType !== "") {
      writer.uint32(130).string(message.eventDataContentType);
    }
    if (message.etag !== "") {
      writer.uint32(794).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.eventFilters.push(EventFilter.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.destination = Destination.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.transport = Transport.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = Trigger_LabelsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.labels[entry12.key] = entry12.value;
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = Trigger_ConditionsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.conditions[entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.eventDataContentType = reader.string();
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      eventFilters: globalThis.Array.isArray(object?.eventFilters)
        ? object.eventFilters.map((e: any) => EventFilter.fromJSON(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      destination: isSet(object.destination) ? Destination.fromJSON(object.destination) : undefined,
      transport: isSet(object.transport) ? Transport.fromJSON(object.transport) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      conditions: isObject(object.conditions)
        ? Object.entries(object.conditions).reduce<{ [key: string]: StateCondition }>((acc, [key, value]) => {
          acc[key] = StateCondition.fromJSON(value);
          return acc;
        }, {})
        : {},
      eventDataContentType: isSet(object.eventDataContentType) ? globalThis.String(object.eventDataContentType) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Trigger): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.eventFilters?.length) {
      obj.eventFilters = message.eventFilters.map((e) => EventFilter.toJSON(e));
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.destination !== undefined) {
      obj.destination = Destination.toJSON(message.destination);
    }
    if (message.transport !== undefined) {
      obj.transport = Transport.toJSON(message.transport);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.conditions) {
      const entries = Object.entries(message.conditions);
      if (entries.length > 0) {
        obj.conditions = {};
        entries.forEach(([k, v]) => {
          obj.conditions[k] = StateCondition.toJSON(v);
        });
      }
    }
    if (message.eventDataContentType !== "") {
      obj.eventDataContentType = message.eventDataContentType;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trigger>, I>>(base?: I): Trigger {
    return Trigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trigger>, I>>(object: I): Trigger {
    const message = createBaseTrigger();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.eventFilters = object.eventFilters?.map((e) => EventFilter.fromPartial(e)) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? Destination.fromPartial(object.destination)
      : undefined;
    message.transport = (object.transport !== undefined && object.transport !== null)
      ? Transport.fromPartial(object.transport)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.channel = object.channel ?? "";
    message.conditions = Object.entries(object.conditions ?? {}).reduce<{ [key: string]: StateCondition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = StateCondition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.eventDataContentType = object.eventDataContentType ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseTrigger_LabelsEntry(): Trigger_LabelsEntry {
  return { key: "", value: "" };
}

export const Trigger_LabelsEntry: MessageFns<Trigger_LabelsEntry> = {
  encode(message: Trigger_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Trigger_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trigger_LabelsEntry>, I>>(base?: I): Trigger_LabelsEntry {
    return Trigger_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trigger_LabelsEntry>, I>>(object: I): Trigger_LabelsEntry {
    const message = createBaseTrigger_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTrigger_ConditionsEntry(): Trigger_ConditionsEntry {
  return { key: "", value: undefined };
}

export const Trigger_ConditionsEntry: MessageFns<Trigger_ConditionsEntry> = {
  encode(message: Trigger_ConditionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      StateCondition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger_ConditionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger_ConditionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = StateCondition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger_ConditionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? StateCondition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Trigger_ConditionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = StateCondition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trigger_ConditionsEntry>, I>>(base?: I): Trigger_ConditionsEntry {
    return Trigger_ConditionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trigger_ConditionsEntry>, I>>(object: I): Trigger_ConditionsEntry {
    const message = createBaseTrigger_ConditionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? StateCondition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEventFilter(): EventFilter {
  return { attribute: "", value: "", operator: "" };
}

export const EventFilter: MessageFns<EventFilter> = {
  encode(message: EventFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== "") {
      writer.uint32(10).string(message.attribute);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.operator !== "") {
      writer.uint32(26).string(message.operator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFilter {
    return {
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
    };
  },

  toJSON(message: EventFilter): unknown {
    const obj: any = {};
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventFilter>, I>>(base?: I): EventFilter {
    return EventFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventFilter>, I>>(object: I): EventFilter {
    const message = createBaseEventFilter();
    message.attribute = object.attribute ?? "";
    message.value = object.value ?? "";
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseStateCondition(): StateCondition {
  return { code: 0, message: "" };
}

export const StateCondition: MessageFns<StateCondition> = {
  encode(message: StateCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateCondition {
    return {
      code: isSet(object.code) ? codeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: StateCondition): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = codeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateCondition>, I>>(base?: I): StateCondition {
    return StateCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateCondition>, I>>(object: I): StateCondition {
    const message = createBaseStateCondition();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseDestination(): Destination {
  return { cloudRun: undefined, cloudFunction: undefined, gke: undefined, workflow: undefined };
}

export const Destination: MessageFns<Destination> = {
  encode(message: Destination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudRun !== undefined) {
      CloudRun.encode(message.cloudRun, writer.uint32(10).fork()).join();
    }
    if (message.cloudFunction !== undefined) {
      writer.uint32(18).string(message.cloudFunction);
    }
    if (message.gke !== undefined) {
      GKE.encode(message.gke, writer.uint32(26).fork()).join();
    }
    if (message.workflow !== undefined) {
      writer.uint32(34).string(message.workflow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Destination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cloudRun = CloudRun.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cloudFunction = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gke = GKE.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflow = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Destination {
    return {
      cloudRun: isSet(object.cloudRun) ? CloudRun.fromJSON(object.cloudRun) : undefined,
      cloudFunction: isSet(object.cloudFunction) ? globalThis.String(object.cloudFunction) : undefined,
      gke: isSet(object.gke) ? GKE.fromJSON(object.gke) : undefined,
      workflow: isSet(object.workflow) ? globalThis.String(object.workflow) : undefined,
    };
  },

  toJSON(message: Destination): unknown {
    const obj: any = {};
    if (message.cloudRun !== undefined) {
      obj.cloudRun = CloudRun.toJSON(message.cloudRun);
    }
    if (message.cloudFunction !== undefined) {
      obj.cloudFunction = message.cloudFunction;
    }
    if (message.gke !== undefined) {
      obj.gke = GKE.toJSON(message.gke);
    }
    if (message.workflow !== undefined) {
      obj.workflow = message.workflow;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Destination>, I>>(base?: I): Destination {
    return Destination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Destination>, I>>(object: I): Destination {
    const message = createBaseDestination();
    message.cloudRun = (object.cloudRun !== undefined && object.cloudRun !== null)
      ? CloudRun.fromPartial(object.cloudRun)
      : undefined;
    message.cloudFunction = object.cloudFunction ?? undefined;
    message.gke = (object.gke !== undefined && object.gke !== null) ? GKE.fromPartial(object.gke) : undefined;
    message.workflow = object.workflow ?? undefined;
    return message;
  },
};

function createBaseTransport(): Transport {
  return { pubsub: undefined };
}

export const Transport: MessageFns<Transport> = {
  encode(message: Transport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pubsub !== undefined) {
      Pubsub.encode(message.pubsub, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pubsub = Pubsub.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transport {
    return { pubsub: isSet(object.pubsub) ? Pubsub.fromJSON(object.pubsub) : undefined };
  },

  toJSON(message: Transport): unknown {
    const obj: any = {};
    if (message.pubsub !== undefined) {
      obj.pubsub = Pubsub.toJSON(message.pubsub);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transport>, I>>(base?: I): Transport {
    return Transport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transport>, I>>(object: I): Transport {
    const message = createBaseTransport();
    message.pubsub = (object.pubsub !== undefined && object.pubsub !== null)
      ? Pubsub.fromPartial(object.pubsub)
      : undefined;
    return message;
  },
};

function createBaseCloudRun(): CloudRun {
  return { service: "", path: "", region: "" };
}

export const CloudRun: MessageFns<CloudRun> = {
  encode(message: CloudRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.region !== "") {
      writer.uint32(26).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.region = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRun {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: CloudRun): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudRun>, I>>(base?: I): CloudRun {
    return CloudRun.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudRun>, I>>(object: I): CloudRun {
    const message = createBaseCloudRun();
    message.service = object.service ?? "";
    message.path = object.path ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseGKE(): GKE {
  return { cluster: "", location: "", namespace: "", service: "", path: "" };
}

export const GKE: MessageFns<GKE> = {
  encode(message: GKE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.namespace !== "") {
      writer.uint32(26).string(message.namespace);
    }
    if (message.service !== "") {
      writer.uint32(34).string(message.service);
    }
    if (message.path !== "") {
      writer.uint32(42).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GKE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGKE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GKE {
    return {
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: GKE): unknown {
    const obj: any = {};
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GKE>, I>>(base?: I): GKE {
    return GKE.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GKE>, I>>(object: I): GKE {
    const message = createBaseGKE();
    message.cluster = object.cluster ?? "";
    message.location = object.location ?? "";
    message.namespace = object.namespace ?? "";
    message.service = object.service ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBasePubsub(): Pubsub {
  return { topic: "", subscription: "" };
}

export const Pubsub: MessageFns<Pubsub> = {
  encode(message: Pubsub, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.subscription !== "") {
      writer.uint32(18).string(message.subscription);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pubsub {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsub();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscription = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pubsub {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "",
    };
  },

  toJSON(message: Pubsub): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pubsub>, I>>(base?: I): Pubsub {
    return Pubsub.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pubsub>, I>>(object: I): Pubsub {
    const message = createBasePubsub();
    message.topic = object.topic ?? "";
    message.subscription = object.subscription ?? "";
    return message;
  },
};

function createBaseTriggerEventData(): TriggerEventData {
  return { payload: undefined };
}

export const TriggerEventData: MessageFns<TriggerEventData> = {
  encode(message: TriggerEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Trigger.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Trigger.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerEventData {
    return { payload: isSet(object.payload) ? Trigger.fromJSON(object.payload) : undefined };
  },

  toJSON(message: TriggerEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Trigger.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TriggerEventData>, I>>(base?: I): TriggerEventData {
    return TriggerEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TriggerEventData>, I>>(object: I): TriggerEventData {
    const message = createBaseTriggerEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Trigger.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseChannelEventData(): ChannelEventData {
  return { payload: undefined };
}

export const ChannelEventData: MessageFns<ChannelEventData> = {
  encode(message: ChannelEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Channel.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Channel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelEventData {
    return { payload: isSet(object.payload) ? Channel.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ChannelEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Channel.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelEventData>, I>>(base?: I): ChannelEventData {
    return ChannelEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelEventData>, I>>(object: I): ChannelEventData {
    const message = createBaseChannelEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Channel.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseChannelConnectionEventData(): ChannelConnectionEventData {
  return { payload: undefined };
}

export const ChannelConnectionEventData: MessageFns<ChannelConnectionEventData> = {
  encode(message: ChannelConnectionEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ChannelConnection.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelConnectionEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelConnectionEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ChannelConnection.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelConnectionEventData {
    return { payload: isSet(object.payload) ? ChannelConnection.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ChannelConnectionEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ChannelConnection.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelConnectionEventData>, I>>(base?: I): ChannelConnectionEventData {
    return ChannelConnectionEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelConnectionEventData>, I>>(object: I): ChannelConnectionEventData {
    const message = createBaseChannelConnectionEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ChannelConnection.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
