// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/gkehub/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";

export const protobufPackage = "google.events.cloud.gkehub.v1";

/** Feature represents the settings and status of any Hub Feature. */
export interface Feature {
  /**
   * Output only. The full, unique name of this Feature resource in the format
   * `projects/* /locations/* /features/*`.
   */
  name: string;
  /** GCP labels for this Feature. */
  labels: { [key: string]: string };
  /** Output only. State of the Feature resource itself. */
  resourceState?:
    | FeatureResourceState
    | undefined;
  /** Output only. The Hub-wide Feature state. */
  state?:
    | CommonFeatureState
    | undefined;
  /**
   * Output only. Membership-specific Feature status. If this Feature does
   * report any per-Membership status, this field may be unused.
   *
   * The keys indicate which Membership the state is for, in the form:
   *
   * `projects/{p}/locations/{l}/memberships/{m}`
   *
   * Where {p} is the project number, {l} is a valid location and {m} is a valid
   * Membership in this project at that location. {p} MUST match the Feature's
   * project number.
   */
  membershipStates: { [key: string]: MembershipFeatureState };
  /** Output only. When the Feature resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. When the Feature resource was last updated. */
  updateTime?:
    | Date
    | undefined;
  /** Output only. When the Feature resource was deleted. */
  deleteTime?:
    | Date
    | undefined;
  /**
   * Output only. Scope-specific Feature status. If this Feature does
   * report any per-Scope status, this field may be unused.
   *
   * The keys indicate which Scope the state is for, in the form:
   *
   * `projects/{p}/locations/global/scopes/{s}`
   *
   * Where {p} is the project, {s} is a valid Scope in this project.
   * {p} WILL match the Feature's project.
   */
  scopeStates: { [key: string]: ScopeFeatureState };
}

export interface Feature_LabelsEntry {
  key: string;
  value: string;
}

export interface Feature_MembershipStatesEntry {
  key: string;
  value?: MembershipFeatureState | undefined;
}

export interface Feature_ScopeStatesEntry {
  key: string;
  value?: ScopeFeatureState | undefined;
}

/**
 * FeatureResourceState describes the state of a Feature *resource* in the
 * GkeHub API. See `FeatureState` for the "running state" of the Feature in the
 * Hub and across Memberships.
 */
export interface FeatureResourceState {
  /** The current state of the Feature resource in the Hub API. */
  state: FeatureResourceState_State;
}

/** State describes the lifecycle status of a Feature. */
export enum FeatureResourceState_State {
  /** STATE_UNSPECIFIED - State is unknown or not set. */
  STATE_UNSPECIFIED = 0,
  /**
   * ENABLING - The Feature is being enabled, and the Feature resource is being created.
   * Once complete, the corresponding Feature will be enabled in this Hub.
   */
  ENABLING = 1,
  /**
   * ACTIVE - The Feature is enabled in this Hub, and the Feature resource is fully
   * available.
   */
  ACTIVE = 2,
  /**
   * DISABLING - The Feature is being disabled in this Hub, and the Feature resource
   * is being deleted.
   */
  DISABLING = 3,
  /** UPDATING - The Feature resource is being updated. */
  UPDATING = 4,
  /** SERVICE_UPDATING - The Feature resource is being updated by the Hub Service. */
  SERVICE_UPDATING = 5,
  UNRECOGNIZED = -1,
}

export function featureResourceState_StateFromJSON(object: any): FeatureResourceState_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return FeatureResourceState_State.STATE_UNSPECIFIED;
    case 1:
    case "ENABLING":
      return FeatureResourceState_State.ENABLING;
    case 2:
    case "ACTIVE":
      return FeatureResourceState_State.ACTIVE;
    case 3:
    case "DISABLING":
      return FeatureResourceState_State.DISABLING;
    case 4:
    case "UPDATING":
      return FeatureResourceState_State.UPDATING;
    case 5:
    case "SERVICE_UPDATING":
      return FeatureResourceState_State.SERVICE_UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatureResourceState_State.UNRECOGNIZED;
  }
}

export function featureResourceState_StateToJSON(object: FeatureResourceState_State): string {
  switch (object) {
    case FeatureResourceState_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case FeatureResourceState_State.ENABLING:
      return "ENABLING";
    case FeatureResourceState_State.ACTIVE:
      return "ACTIVE";
    case FeatureResourceState_State.DISABLING:
      return "DISABLING";
    case FeatureResourceState_State.UPDATING:
      return "UPDATING";
    case FeatureResourceState_State.SERVICE_UPDATING:
      return "SERVICE_UPDATING";
    case FeatureResourceState_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * FeatureState describes the high-level state of a Feature. It may be used to
 * describe a Feature's state at the environ-level, or per-membershop, depending
 * on the context.
 */
export interface FeatureState {
  /** The high-level, machine-readable status of this Feature. */
  code: FeatureState_Code;
  /** A human-readable description of the current status. */
  description: string;
  /** The time this status and any related Feature-specific details were updated. */
  updateTime?: Date | undefined;
}

/** Code represents a machine-readable, high-level status of the Feature. */
export enum FeatureState_Code {
  /** CODE_UNSPECIFIED - Unknown or not set. */
  CODE_UNSPECIFIED = 0,
  /** OK - The Feature is operating normally. */
  OK = 1,
  /**
   * WARNING - The Feature has encountered an issue, and is operating in a degraded
   * state. The Feature may need intervention to return to normal operation.
   * See the description and any associated Feature-specific details for more
   * information.
   */
  WARNING = 2,
  /**
   * ERROR - The Feature is not operating or is in a severely degraded state.
   * The Feature may need intervention to return to normal operation.
   * See the description and any associated Feature-specific details for more
   * information.
   */
  ERROR = 3,
  UNRECOGNIZED = -1,
}

export function featureState_CodeFromJSON(object: any): FeatureState_Code {
  switch (object) {
    case 0:
    case "CODE_UNSPECIFIED":
      return FeatureState_Code.CODE_UNSPECIFIED;
    case 1:
    case "OK":
      return FeatureState_Code.OK;
    case 2:
    case "WARNING":
      return FeatureState_Code.WARNING;
    case 3:
    case "ERROR":
      return FeatureState_Code.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatureState_Code.UNRECOGNIZED;
  }
}

export function featureState_CodeToJSON(object: FeatureState_Code): string {
  switch (object) {
    case FeatureState_Code.CODE_UNSPECIFIED:
      return "CODE_UNSPECIFIED";
    case FeatureState_Code.OK:
      return "OK";
    case FeatureState_Code.WARNING:
      return "WARNING";
    case FeatureState_Code.ERROR:
      return "ERROR";
    case FeatureState_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** CommonFeatureState contains Hub-wide Feature status information. */
export interface CommonFeatureState {
  /** Output only. The "running state" of the Feature in this Hub. */
  state?: FeatureState | undefined;
}

/** ScopeFeatureState contains Scope-wide Feature status information. */
export interface ScopeFeatureState {
  /** Output only. The "running state" of the Feature in this Scope. */
  state?: FeatureState | undefined;
}

/**
 * MembershipFeatureState contains Feature status information for a single
 * Membership.
 */
export interface MembershipFeatureState {
  /** The high-level state of this Feature for a single membership. */
  state?: FeatureState | undefined;
}

/** Scope represents a Scope in a Fleet. */
export interface Scope {
  /**
   * The resource name for the scope
   * `projects/{project}/locations/{location}/scopes/{scope}`
   */
  name: string;
  /**
   * Output only. Google-generated UUID for this resource. This is unique across
   * all scope resources. If a scope resource is deleted and another resource
   * with the same name is created, it gets a different uid.
   */
  uid: string;
  /** Output only. When the scope was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. When the scope was last updated. */
  updateTime?:
    | Date
    | undefined;
  /** Output only. When the scope was deleted. */
  deleteTime?:
    | Date
    | undefined;
  /** Output only. State of the scope resource. */
  state?: ScopeLifecycleState | undefined;
}

/** ScopeLifecycleState describes the state of a Scope resource. */
export interface ScopeLifecycleState {
  /** Output only. The current state of the scope resource. */
  code: ScopeLifecycleState_Code;
}

/** Code describes the state of a Scope resource. */
export enum ScopeLifecycleState_Code {
  /** CODE_UNSPECIFIED - The code is not set. */
  CODE_UNSPECIFIED = 0,
  /** CREATING - The scope is being created. */
  CREATING = 1,
  /** READY - The scope active. */
  READY = 2,
  /** DELETING - The scope is being deleted. */
  DELETING = 3,
  /** UPDATING - The scope is being updated. */
  UPDATING = 4,
  UNRECOGNIZED = -1,
}

export function scopeLifecycleState_CodeFromJSON(object: any): ScopeLifecycleState_Code {
  switch (object) {
    case 0:
    case "CODE_UNSPECIFIED":
      return ScopeLifecycleState_Code.CODE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return ScopeLifecycleState_Code.CREATING;
    case 2:
    case "READY":
      return ScopeLifecycleState_Code.READY;
    case 3:
    case "DELETING":
      return ScopeLifecycleState_Code.DELETING;
    case 4:
    case "UPDATING":
      return ScopeLifecycleState_Code.UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScopeLifecycleState_Code.UNRECOGNIZED;
  }
}

export function scopeLifecycleState_CodeToJSON(object: ScopeLifecycleState_Code): string {
  switch (object) {
    case ScopeLifecycleState_Code.CODE_UNSPECIFIED:
      return "CODE_UNSPECIFIED";
    case ScopeLifecycleState_Code.CREATING:
      return "CREATING";
    case ScopeLifecycleState_Code.READY:
      return "READY";
    case ScopeLifecycleState_Code.DELETING:
      return "DELETING";
    case ScopeLifecycleState_Code.UPDATING:
      return "UPDATING";
    case ScopeLifecycleState_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * MembershipBinding is a subresource of a Membership, representing
 * what Fleet Scopes (or other, future Fleet resources) a Membership is bound
 * to.
 */
export interface MembershipBinding {
  /**
   * A Workspace resource name in the format
   * `projects/* /locations/* /scopes/*`.
   */
  scope?:
    | string
    | undefined;
  /**
   * Whether the membershipbinding is Fleet-wide; true means that this
   * Membership should be bound to all Namespaces in this entire Fleet.
   */
  fleet?:
    | boolean
    | undefined;
  /**
   * The resource name for the membershipbinding itself
   * `projects/{project}/locations/{location}/memberships/{membership}/bindings/{membershipbinding}`
   */
  name: string;
  /**
   * Output only. Google-generated UUID for this resource. This is unique across
   * all membershipbinding resources. If a membershipbinding resource is deleted
   * and another resource with the same name is created, it gets a different
   * uid.
   */
  uid: string;
  /** Output only. When the membership binding was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. When the membership binding was last updated. */
  updateTime?:
    | Date
    | undefined;
  /** Output only. When the membership binding was deleted. */
  deleteTime?:
    | Date
    | undefined;
  /** Output only. State of the membership binding resource. */
  state?: MembershipBindingLifecycleState | undefined;
}

/** MembershipBindingLifecycleState describes the state of a Binding resource. */
export interface MembershipBindingLifecycleState {
  /** Output only. The current state of the MembershipBinding resource. */
  code: MembershipBindingLifecycleState_Code;
}

/** Code describes the state of a MembershipBinding resource. */
export enum MembershipBindingLifecycleState_Code {
  /** CODE_UNSPECIFIED - The code is not set. */
  CODE_UNSPECIFIED = 0,
  /** CREATING - The membershipbinding is being created. */
  CREATING = 1,
  /** READY - The membershipbinding active. */
  READY = 2,
  /** DELETING - The membershipbinding is being deleted. */
  DELETING = 3,
  /** UPDATING - The membershipbinding is being updated. */
  UPDATING = 4,
  UNRECOGNIZED = -1,
}

export function membershipBindingLifecycleState_CodeFromJSON(object: any): MembershipBindingLifecycleState_Code {
  switch (object) {
    case 0:
    case "CODE_UNSPECIFIED":
      return MembershipBindingLifecycleState_Code.CODE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return MembershipBindingLifecycleState_Code.CREATING;
    case 2:
    case "READY":
      return MembershipBindingLifecycleState_Code.READY;
    case 3:
    case "DELETING":
      return MembershipBindingLifecycleState_Code.DELETING;
    case 4:
    case "UPDATING":
      return MembershipBindingLifecycleState_Code.UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MembershipBindingLifecycleState_Code.UNRECOGNIZED;
  }
}

export function membershipBindingLifecycleState_CodeToJSON(object: MembershipBindingLifecycleState_Code): string {
  switch (object) {
    case MembershipBindingLifecycleState_Code.CODE_UNSPECIFIED:
      return "CODE_UNSPECIFIED";
    case MembershipBindingLifecycleState_Code.CREATING:
      return "CREATING";
    case MembershipBindingLifecycleState_Code.READY:
      return "READY";
    case MembershipBindingLifecycleState_Code.DELETING:
      return "DELETING";
    case MembershipBindingLifecycleState_Code.UPDATING:
      return "UPDATING";
    case MembershipBindingLifecycleState_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Membership contains information about a member cluster. */
export interface Membership {
  /** Optional. Endpoint information to reach this member. */
  endpoint?:
    | MembershipEndpoint
    | undefined;
  /**
   * Output only. The full, unique name of this Membership resource in the
   * format `projects/* /locations/* /memberships/{membership_id}`, set during
   * creation.
   *
   * `membership_id` must be a valid RFC 1123 compliant DNS label:
   *
   *   1. At most 63 characters in length
   *   2. It must consist of lower case alphanumeric characters or `-`
   *   3. It must start and end with an alphanumeric character
   *
   * Which can be expressed as the regex: `[a-z0-9]([-a-z0-9]*[a-z0-9])?`,
   * with a maximum length of 63 characters.
   */
  name: string;
  /** Optional. GCP labels for this membership. */
  labels: { [key: string]: string };
  /**
   * Output only. Description of this membership, limited to 63 characters.
   * Must match the regex: `[a-zA-Z0-9][a-zA-Z0-9_\-\.\ ]*`
   *
   * This field is present for legacy purposes.
   */
  description: string;
  /** Output only. State of the Membership resource. */
  state?:
    | MembershipState
    | undefined;
  /** Output only. When the Membership was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. When the Membership was last updated. */
  updateTime?:
    | Date
    | undefined;
  /** Output only. When the Membership was deleted. */
  deleteTime?:
    | Date
    | undefined;
  /**
   * Optional. An externally-generated and managed ID for this Membership. This
   * ID may be modified after creation, but this is not recommended.
   *
   * The ID must match the regex: `[a-zA-Z0-9][a-zA-Z0-9_\-\.]*`
   *
   * If this Membership represents a Kubernetes cluster, this value should be
   * set to the UID of the `kube-system` namespace object.
   */
  externalId: string;
  /**
   * Output only. For clusters using Connect, the timestamp of the most recent
   * connection established with Google Cloud. This time is updated every
   * several minutes, not continuously. For clusters that do not use GKE
   * Connect, or that have never connected successfully, this field will be
   * unset.
   */
  lastConnectionTime?:
    | Date
    | undefined;
  /**
   * Output only. Google-generated UUID for this resource. This is unique across
   * all Membership resources. If a Membership resource is deleted and another
   * resource with the same name is created, it gets a different unique_id.
   */
  uniqueId: string;
  /**
   * Optional. How to identify workloads from this Membership.
   * See the documentation on Workload Identity for more details:
   * https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
   */
  authority?: Authority | undefined;
}

export interface Membership_LabelsEntry {
  key: string;
  value: string;
}

/**
 * MembershipEndpoint contains information needed to contact a Kubernetes API,
 * endpoint and any additional Kubernetes metadata.
 */
export interface MembershipEndpoint {
  /** Optional. Specific information for a GKE-on-GCP cluster. */
  gkeCluster?:
    | GkeCluster
    | undefined;
  /**
   * Optional. Specific information for a GKE On-Prem cluster. An onprem
   * user-cluster who has no resourceLink is not allowed to use this field, it
   * should have a nil "type" instead.
   */
  onPremCluster?:
    | OnPremCluster
    | undefined;
  /** Optional. Specific information for a GKE Multi-Cloud cluster. */
  multiCloudCluster?:
    | MultiCloudCluster
    | undefined;
  /** Optional. Specific information for a Google Edge cluster. */
  edgeCluster?:
    | EdgeCluster
    | undefined;
  /** Optional. Specific information for a GDC Edge Appliance cluster. */
  applianceCluster?:
    | ApplianceCluster
    | undefined;
  /** Output only. Useful Kubernetes-specific metadata. */
  kubernetesMetadata?:
    | KubernetesMetadata
    | undefined;
  /**
   * Optional. The in-cluster Kubernetes Resources that should be applied for a
   * correctly registered cluster, in the steady state. These resources:
   *
   *   * Ensure that the cluster is exclusively registered to one and only one
   *     Hub Membership.
   *   * Propagate Workload Pool Information available in the Membership
   *     Authority field.
   *   * Ensure proper initial configuration of default Hub Features.
   */
  kubernetesResource?:
    | KubernetesResource
    | undefined;
  /**
   * Output only. Whether the lifecycle of this membership is managed by a
   * google cluster platform service.
   */
  googleManaged: boolean;
}

/**
 * KubernetesResource contains the YAML manifests and configuration for
 * Membership Kubernetes resources in the cluster. After CreateMembership or
 * UpdateMembership, these resources should be re-applied in the cluster.
 */
export interface KubernetesResource {
  /**
   * Output only. Additional Kubernetes resources that need to be applied to the
   * cluster after Membership creation, and after every update.
   *
   * This field is only populated in the Membership returned from a successful
   * long-running operation from CreateMembership or UpdateMembership. It is not
   * populated during normal GetMembership or ListMemberships requests. To get
   * the resource manifest after the initial registration, the caller should
   * make a UpdateMembership call with an empty field mask.
   */
  membershipResources: ResourceManifest[];
  /**
   * Output only. The Kubernetes resources for installing the GKE Connect agent
   *
   * This field is only populated in the Membership returned from a successful
   * long-running operation from CreateMembership or UpdateMembership. It is not
   * populated during normal GetMembership or ListMemberships requests. To get
   * the resource manifest after the initial registration, the caller should
   * make a UpdateMembership call with an empty field mask.
   */
  connectResources: ResourceManifest[];
  /** Optional. Options for Kubernetes resource generation. */
  resourceOptions?: ResourceOptions | undefined;
}

/** ResourceOptions represent options for Kubernetes resource generation. */
export interface ResourceOptions {
  /**
   * Optional. The Connect agent version to use for connect_resources. Defaults
   * to the latest GKE Connect version. The version must be a currently
   * supported version, obsolete versions will be rejected.
   */
  connectVersion: string;
  /**
   * Optional. Use `apiextensions/v1beta1` instead of `apiextensions/v1` for
   * CustomResourceDefinition resources.
   * This option should be set for clusters with Kubernetes apiserver versions
   * <1.16.
   */
  v1beta1Crd: boolean;
  /**
   * Optional. Major version of the Kubernetes cluster. This is only used to
   * determine which version to use for the CustomResourceDefinition resources,
   * `apiextensions/v1beta1` or`apiextensions/v1`.
   */
  k8sVersion: string;
}

/**
 * ResourceManifest represents a single Kubernetes resource to be applied to
 * the cluster.
 */
export interface ResourceManifest {
  /** YAML manifest of the resource. */
  manifest: string;
  /**
   * Whether the resource provided in the manifest is `cluster_scoped`.
   * If unset, the manifest is assumed to be namespace scoped.
   *
   * This field is used for REST mapping when applying the resource in a
   * cluster.
   */
  clusterScoped: boolean;
}

/** GkeCluster contains information specific to GKE clusters. */
export interface GkeCluster {
  /**
   * Immutable. Self-link of the GCP resource for the GKE cluster. For example:
   *
   * //container.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
   *
   * Zonal clusters are also supported.
   */
  resourceLink: string;
  /**
   * Output only. If cluster_missing is set then it denotes that the GKE cluster
   * no longer exists in the GKE Control Plane.
   */
  clusterMissing: boolean;
}

/** OnPremCluster contains information specific to GKE On-Prem clusters. */
export interface OnPremCluster {
  /**
   * Immutable. Self-link of the GCP resource for the GKE On-Prem cluster. For
   * example:
   *
   *  //gkeonprem.googleapis.com/projects/my-project/locations/us-west1-a/vmwareClusters/my-cluster
   *  //gkeonprem.googleapis.com/projects/my-project/locations/us-west1-a/bareMetalClusters/my-cluster
   */
  resourceLink: string;
  /**
   * Output only. If cluster_missing is set then it denotes that
   * API(gkeonprem.googleapis.com) resource for this GKE On-Prem cluster no
   * longer exists.
   */
  clusterMissing: boolean;
  /** Immutable. Whether the cluster is an admin cluster. */
  adminCluster: boolean;
  /** Immutable. The on prem cluster's type. */
  clusterType: OnPremCluster_ClusterType;
}

/** ClusterType describes on prem cluster's type. */
export enum OnPremCluster_ClusterType {
  /** CLUSTERTYPE_UNSPECIFIED - The ClusterType is not set. */
  CLUSTERTYPE_UNSPECIFIED = 0,
  /** BOOTSTRAP - The ClusterType is bootstrap cluster. */
  BOOTSTRAP = 1,
  /** HYBRID - The ClusterType is baremetal hybrid cluster. */
  HYBRID = 2,
  /** STANDALONE - The ClusterType is baremetal standalone cluster. */
  STANDALONE = 3,
  /** USER - The ClusterType is user cluster. */
  USER = 4,
  UNRECOGNIZED = -1,
}

export function onPremCluster_ClusterTypeFromJSON(object: any): OnPremCluster_ClusterType {
  switch (object) {
    case 0:
    case "CLUSTERTYPE_UNSPECIFIED":
      return OnPremCluster_ClusterType.CLUSTERTYPE_UNSPECIFIED;
    case 1:
    case "BOOTSTRAP":
      return OnPremCluster_ClusterType.BOOTSTRAP;
    case 2:
    case "HYBRID":
      return OnPremCluster_ClusterType.HYBRID;
    case 3:
    case "STANDALONE":
      return OnPremCluster_ClusterType.STANDALONE;
    case 4:
    case "USER":
      return OnPremCluster_ClusterType.USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OnPremCluster_ClusterType.UNRECOGNIZED;
  }
}

export function onPremCluster_ClusterTypeToJSON(object: OnPremCluster_ClusterType): string {
  switch (object) {
    case OnPremCluster_ClusterType.CLUSTERTYPE_UNSPECIFIED:
      return "CLUSTERTYPE_UNSPECIFIED";
    case OnPremCluster_ClusterType.BOOTSTRAP:
      return "BOOTSTRAP";
    case OnPremCluster_ClusterType.HYBRID:
      return "HYBRID";
    case OnPremCluster_ClusterType.STANDALONE:
      return "STANDALONE";
    case OnPremCluster_ClusterType.USER:
      return "USER";
    case OnPremCluster_ClusterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MultiCloudCluster contains information specific to GKE Multi-Cloud clusters. */
export interface MultiCloudCluster {
  /**
   * Immutable. Self-link of the GCP resource for the GKE Multi-Cloud cluster.
   * For example:
   *
   *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/awsClusters/my-cluster
   *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/azureClusters/my-cluster
   *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/attachedClusters/my-cluster
   */
  resourceLink: string;
  /**
   * Output only. If cluster_missing is set then it denotes that
   * API(gkemulticloud.googleapis.com) resource for this GKE Multi-Cloud cluster
   * no longer exists.
   */
  clusterMissing: boolean;
}

/** EdgeCluster contains information specific to Google Edge Clusters. */
export interface EdgeCluster {
  /**
   * Immutable. Self-link of the GCP resource for the Edge Cluster. For
   * example:
   *
   * //edgecontainer.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
   */
  resourceLink: string;
}

/**
 * ApplianceCluster contains information specific to GDC Edge Appliance
 * Clusters.
 */
export interface ApplianceCluster {
  /**
   * Immutable. Self-link of the GCP resource for the Appliance Cluster. For
   * example:
   *
   * //transferappliance.googleapis.com/projects/my-project/locations/us-west1-a/appliances/my-appliance
   */
  resourceLink: string;
}

/**
 * KubernetesMetadata provides informational metadata for Memberships
 * representing Kubernetes clusters.
 */
export interface KubernetesMetadata {
  /**
   * Output only. Kubernetes API server version string as reported by
   * `/version`.
   */
  kubernetesApiServerVersion: string;
  /**
   * Output only. Node providerID as reported by the first node in the list of
   * nodes on the Kubernetes endpoint. On Kubernetes platforms that support
   * zero-node clusters (like GKE-on-GCP), the node_count will be zero and the
   * node_provider_id will be empty.
   */
  nodeProviderId: string;
  /** Output only. Node count as reported by Kubernetes nodes resources. */
  nodeCount: number;
  /** Output only. vCPU count as reported by Kubernetes nodes resources. */
  vcpuCount: number;
  /**
   * Output only. The total memory capacity as reported by the sum of all
   * Kubernetes nodes resources, defined in MB.
   */
  memoryMb: number;
  /**
   * Output only. The time at which these details were last updated. This
   * update_time is different from the Membership-level update_time since
   * EndpointDetails are updated internally for API consumers.
   */
  updateTime?: Date | undefined;
}

/** MembershipState describes the state of a Membership resource. */
export interface MembershipState {
  /** Output only. The current state of the Membership resource. */
  code: MembershipState_Code;
}

/** Code describes the state of a Membership resource. */
export enum MembershipState_Code {
  /** CODE_UNSPECIFIED - The code is not set. */
  CODE_UNSPECIFIED = 0,
  /** CREATING - The cluster is being registered. */
  CREATING = 1,
  /** READY - The cluster is registered. */
  READY = 2,
  /** DELETING - The cluster is being unregistered. */
  DELETING = 3,
  /** UPDATING - The Membership is being updated. */
  UPDATING = 4,
  /** SERVICE_UPDATING - The Membership is being updated by the Hub Service. */
  SERVICE_UPDATING = 5,
  UNRECOGNIZED = -1,
}

export function membershipState_CodeFromJSON(object: any): MembershipState_Code {
  switch (object) {
    case 0:
    case "CODE_UNSPECIFIED":
      return MembershipState_Code.CODE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return MembershipState_Code.CREATING;
    case 2:
    case "READY":
      return MembershipState_Code.READY;
    case 3:
    case "DELETING":
      return MembershipState_Code.DELETING;
    case 4:
    case "UPDATING":
      return MembershipState_Code.UPDATING;
    case 5:
    case "SERVICE_UPDATING":
      return MembershipState_Code.SERVICE_UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MembershipState_Code.UNRECOGNIZED;
  }
}

export function membershipState_CodeToJSON(object: MembershipState_Code): string {
  switch (object) {
    case MembershipState_Code.CODE_UNSPECIFIED:
      return "CODE_UNSPECIFIED";
    case MembershipState_Code.CREATING:
      return "CREATING";
    case MembershipState_Code.READY:
      return "READY";
    case MembershipState_Code.DELETING:
      return "DELETING";
    case MembershipState_Code.UPDATING:
      return "UPDATING";
    case MembershipState_Code.SERVICE_UPDATING:
      return "SERVICE_UPDATING";
    case MembershipState_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Authority encodes how Google will recognize identities from this Membership.
 * See the workload identity documentation for more details:
 * https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
 */
export interface Authority {
  /**
   * Optional. A JSON Web Token (JWT) issuer URI. `issuer` must start with
   * `https://` and be a valid URL with length <2000 characters.
   *
   * If set, then Google will allow valid OIDC tokens from this issuer to
   * authenticate within the workload_identity_pool. OIDC discovery will be
   * performed on this URI to validate tokens from the issuer.
   *
   * Clearing `issuer` disables Workload Identity. `issuer` cannot be directly
   * modified; it must be cleared (and Workload Identity disabled) before using
   * a new issuer (and re-enabling Workload Identity).
   */
  issuer: string;
  /**
   * Output only. The name of the workload identity pool in which `issuer` will
   * be recognized.
   *
   * There is a single Workload Identity Pool per Hub that is shared
   * between all Memberships that belong to that Hub. For a Hub hosted in
   * {PROJECT_ID}, the workload pool format is `{PROJECT_ID}.hub.id.goog`,
   * although this is subject to change in newer versions of this API.
   */
  workloadIdentityPool: string;
  /**
   * Output only. An identity provider that reflects the `issuer` in the
   * workload identity pool.
   */
  identityProvider: string;
  /**
   * Optional. OIDC verification keys for this Membership in JWKS format (RFC
   * 7517).
   *
   * When this field is set, OIDC discovery will NOT be performed on `issuer`,
   * and instead OIDC tokens will be validated using this field.
   */
  oidcJwks: Uint8Array;
}

/** The data within all Scope events. */
export interface ScopeEventData {
  /** Optional. The Scope event payload. Unset for deletion events. */
  payload?: Scope | undefined;
}

/** The data within all Membership events. */
export interface MembershipEventData {
  /** Optional. The Membership event payload. Unset for deletion events. */
  payload?: Membership | undefined;
}

/** The data within all Feature events. */
export interface FeatureEventData {
  /** Optional. The Feature event payload. Unset for deletion events. */
  payload?: Feature | undefined;
}

/** The data within all MembershipBinding events. */
export interface MembershipBindingEventData {
  /** Optional. The MembershipBinding event payload. Unset for deletion events. */
  payload?: MembershipBinding | undefined;
}

function createBaseFeature(): Feature {
  return {
    name: "",
    labels: {},
    resourceState: undefined,
    state: undefined,
    membershipStates: {},
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    scopeStates: {},
  };
}

export const Feature: MessageFns<Feature> = {
  encode(message: Feature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Feature_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.resourceState !== undefined) {
      FeatureResourceState.encode(message.resourceState, writer.uint32(26).fork()).join();
    }
    if (message.state !== undefined) {
      CommonFeatureState.encode(message.state, writer.uint32(50).fork()).join();
    }
    Object.entries(message.membershipStates).forEach(([key, value]) => {
      Feature_MembershipStatesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(82).fork()).join();
    }
    Object.entries(message.scopeStates).forEach(([key, value]) => {
      Feature_ScopeStatesEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Feature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Feature_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resourceState = FeatureResourceState.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.state = CommonFeatureState.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Feature_MembershipStatesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.membershipStates[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = Feature_ScopeStatesEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.scopeStates[entry13.key] = entry13.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Feature {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      resourceState: isSet(object.resourceState) ? FeatureResourceState.fromJSON(object.resourceState) : undefined,
      state: isSet(object.state) ? CommonFeatureState.fromJSON(object.state) : undefined,
      membershipStates: isObject(object.membershipStates)
        ? Object.entries(object.membershipStates).reduce<{ [key: string]: MembershipFeatureState }>(
          (acc, [key, value]) => {
            acc[key] = MembershipFeatureState.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      scopeStates: isObject(object.scopeStates)
        ? Object.entries(object.scopeStates).reduce<{ [key: string]: ScopeFeatureState }>((acc, [key, value]) => {
          acc[key] = ScopeFeatureState.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Feature): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.resourceState !== undefined) {
      obj.resourceState = FeatureResourceState.toJSON(message.resourceState);
    }
    if (message.state !== undefined) {
      obj.state = CommonFeatureState.toJSON(message.state);
    }
    if (message.membershipStates) {
      const entries = Object.entries(message.membershipStates);
      if (entries.length > 0) {
        obj.membershipStates = {};
        entries.forEach(([k, v]) => {
          obj.membershipStates[k] = MembershipFeatureState.toJSON(v);
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.scopeStates) {
      const entries = Object.entries(message.scopeStates);
      if (entries.length > 0) {
        obj.scopeStates = {};
        entries.forEach(([k, v]) => {
          obj.scopeStates[k] = ScopeFeatureState.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Feature>, I>>(base?: I): Feature {
    return Feature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Feature>, I>>(object: I): Feature {
    const message = createBaseFeature();
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.resourceState = (object.resourceState !== undefined && object.resourceState !== null)
      ? FeatureResourceState.fromPartial(object.resourceState)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? CommonFeatureState.fromPartial(object.state)
      : undefined;
    message.membershipStates = Object.entries(object.membershipStates ?? {}).reduce<
      { [key: string]: MembershipFeatureState }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = MembershipFeatureState.fromPartial(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.scopeStates = Object.entries(object.scopeStates ?? {}).reduce<{ [key: string]: ScopeFeatureState }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScopeFeatureState.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseFeature_LabelsEntry(): Feature_LabelsEntry {
  return { key: "", value: "" };
}

export const Feature_LabelsEntry: MessageFns<Feature_LabelsEntry> = {
  encode(message: Feature_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Feature_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeature_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Feature_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Feature_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Feature_LabelsEntry>, I>>(base?: I): Feature_LabelsEntry {
    return Feature_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Feature_LabelsEntry>, I>>(object: I): Feature_LabelsEntry {
    const message = createBaseFeature_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFeature_MembershipStatesEntry(): Feature_MembershipStatesEntry {
  return { key: "", value: undefined };
}

export const Feature_MembershipStatesEntry: MessageFns<Feature_MembershipStatesEntry> = {
  encode(message: Feature_MembershipStatesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MembershipFeatureState.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Feature_MembershipStatesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeature_MembershipStatesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MembershipFeatureState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Feature_MembershipStatesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MembershipFeatureState.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Feature_MembershipStatesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MembershipFeatureState.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Feature_MembershipStatesEntry>, I>>(base?: I): Feature_MembershipStatesEntry {
    return Feature_MembershipStatesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Feature_MembershipStatesEntry>, I>>(
    object: I,
  ): Feature_MembershipStatesEntry {
    const message = createBaseFeature_MembershipStatesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MembershipFeatureState.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFeature_ScopeStatesEntry(): Feature_ScopeStatesEntry {
  return { key: "", value: undefined };
}

export const Feature_ScopeStatesEntry: MessageFns<Feature_ScopeStatesEntry> = {
  encode(message: Feature_ScopeStatesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScopeFeatureState.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Feature_ScopeStatesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeature_ScopeStatesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScopeFeatureState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Feature_ScopeStatesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScopeFeatureState.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Feature_ScopeStatesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScopeFeatureState.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Feature_ScopeStatesEntry>, I>>(base?: I): Feature_ScopeStatesEntry {
    return Feature_ScopeStatesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Feature_ScopeStatesEntry>, I>>(object: I): Feature_ScopeStatesEntry {
    const message = createBaseFeature_ScopeStatesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScopeFeatureState.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFeatureResourceState(): FeatureResourceState {
  return { state: 0 };
}

export const FeatureResourceState: MessageFns<FeatureResourceState> = {
  encode(message: FeatureResourceState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureResourceState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureResourceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureResourceState {
    return { state: isSet(object.state) ? featureResourceState_StateFromJSON(object.state) : 0 };
  },

  toJSON(message: FeatureResourceState): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = featureResourceState_StateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureResourceState>, I>>(base?: I): FeatureResourceState {
    return FeatureResourceState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureResourceState>, I>>(object: I): FeatureResourceState {
    const message = createBaseFeatureResourceState();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseFeatureState(): FeatureState {
  return { code: 0, description: "", updateTime: undefined };
}

export const FeatureState: MessageFns<FeatureState> = {
  encode(message: FeatureState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureState {
    return {
      code: isSet(object.code) ? featureState_CodeFromJSON(object.code) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: FeatureState): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = featureState_CodeToJSON(message.code);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureState>, I>>(base?: I): FeatureState {
    return FeatureState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureState>, I>>(object: I): FeatureState {
    const message = createBaseFeatureState();
    message.code = object.code ?? 0;
    message.description = object.description ?? "";
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseCommonFeatureState(): CommonFeatureState {
  return { state: undefined };
}

export const CommonFeatureState: MessageFns<CommonFeatureState> = {
  encode(message: CommonFeatureState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      FeatureState.encode(message.state, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonFeatureState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonFeatureState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.state = FeatureState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonFeatureState {
    return { state: isSet(object.state) ? FeatureState.fromJSON(object.state) : undefined };
  },

  toJSON(message: CommonFeatureState): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = FeatureState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonFeatureState>, I>>(base?: I): CommonFeatureState {
    return CommonFeatureState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonFeatureState>, I>>(object: I): CommonFeatureState {
    const message = createBaseCommonFeatureState();
    message.state = (object.state !== undefined && object.state !== null)
      ? FeatureState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseScopeFeatureState(): ScopeFeatureState {
  return { state: undefined };
}

export const ScopeFeatureState: MessageFns<ScopeFeatureState> = {
  encode(message: ScopeFeatureState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      FeatureState.encode(message.state, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopeFeatureState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopeFeatureState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.state = FeatureState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopeFeatureState {
    return { state: isSet(object.state) ? FeatureState.fromJSON(object.state) : undefined };
  },

  toJSON(message: ScopeFeatureState): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = FeatureState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopeFeatureState>, I>>(base?: I): ScopeFeatureState {
    return ScopeFeatureState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopeFeatureState>, I>>(object: I): ScopeFeatureState {
    const message = createBaseScopeFeatureState();
    message.state = (object.state !== undefined && object.state !== null)
      ? FeatureState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseMembershipFeatureState(): MembershipFeatureState {
  return { state: undefined };
}

export const MembershipFeatureState: MessageFns<MembershipFeatureState> = {
  encode(message: MembershipFeatureState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      FeatureState.encode(message.state, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipFeatureState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipFeatureState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.state = FeatureState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipFeatureState {
    return { state: isSet(object.state) ? FeatureState.fromJSON(object.state) : undefined };
  },

  toJSON(message: MembershipFeatureState): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = FeatureState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipFeatureState>, I>>(base?: I): MembershipFeatureState {
    return MembershipFeatureState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MembershipFeatureState>, I>>(object: I): MembershipFeatureState {
    const message = createBaseMembershipFeatureState();
    message.state = (object.state !== undefined && object.state !== null)
      ? FeatureState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseScope(): Scope {
  return { name: "", uid: "", createTime: undefined, updateTime: undefined, deleteTime: undefined, state: undefined };
}

export const Scope: MessageFns<Scope> = {
  encode(message: Scope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(42).fork()).join();
    }
    if (message.state !== undefined) {
      ScopeLifecycleState.encode(message.state, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.state = ScopeLifecycleState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scope {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      state: isSet(object.state) ? ScopeLifecycleState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: Scope): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.state !== undefined) {
      obj.state = ScopeLifecycleState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Scope>, I>>(base?: I): Scope {
    return Scope.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Scope>, I>>(object: I): Scope {
    const message = createBaseScope();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? ScopeLifecycleState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseScopeLifecycleState(): ScopeLifecycleState {
  return { code: 0 };
}

export const ScopeLifecycleState: MessageFns<ScopeLifecycleState> = {
  encode(message: ScopeLifecycleState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopeLifecycleState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopeLifecycleState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopeLifecycleState {
    return { code: isSet(object.code) ? scopeLifecycleState_CodeFromJSON(object.code) : 0 };
  },

  toJSON(message: ScopeLifecycleState): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = scopeLifecycleState_CodeToJSON(message.code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopeLifecycleState>, I>>(base?: I): ScopeLifecycleState {
    return ScopeLifecycleState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopeLifecycleState>, I>>(object: I): ScopeLifecycleState {
    const message = createBaseScopeLifecycleState();
    message.code = object.code ?? 0;
    return message;
  },
};

function createBaseMembershipBinding(): MembershipBinding {
  return {
    scope: undefined,
    fleet: undefined,
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    state: undefined,
  };
}

export const MembershipBinding: MessageFns<MembershipBinding> = {
  encode(message: MembershipBinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scope !== undefined) {
      writer.uint32(26).string(message.scope);
    }
    if (message.fleet !== undefined) {
      writer.uint32(32).bool(message.fleet);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(58).fork()).join();
    }
    if (message.state !== undefined) {
      MembershipBindingLifecycleState.encode(message.state, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipBinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fleet = reader.bool();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.state = MembershipBindingLifecycleState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipBinding {
    return {
      scope: isSet(object.scope) ? globalThis.String(object.scope) : undefined,
      fleet: isSet(object.fleet) ? globalThis.Boolean(object.fleet) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      state: isSet(object.state) ? MembershipBindingLifecycleState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: MembershipBinding): unknown {
    const obj: any = {};
    if (message.scope !== undefined) {
      obj.scope = message.scope;
    }
    if (message.fleet !== undefined) {
      obj.fleet = message.fleet;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.state !== undefined) {
      obj.state = MembershipBindingLifecycleState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipBinding>, I>>(base?: I): MembershipBinding {
    return MembershipBinding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MembershipBinding>, I>>(object: I): MembershipBinding {
    const message = createBaseMembershipBinding();
    message.scope = object.scope ?? undefined;
    message.fleet = object.fleet ?? undefined;
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? MembershipBindingLifecycleState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseMembershipBindingLifecycleState(): MembershipBindingLifecycleState {
  return { code: 0 };
}

export const MembershipBindingLifecycleState: MessageFns<MembershipBindingLifecycleState> = {
  encode(message: MembershipBindingLifecycleState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipBindingLifecycleState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipBindingLifecycleState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipBindingLifecycleState {
    return { code: isSet(object.code) ? membershipBindingLifecycleState_CodeFromJSON(object.code) : 0 };
  },

  toJSON(message: MembershipBindingLifecycleState): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = membershipBindingLifecycleState_CodeToJSON(message.code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipBindingLifecycleState>, I>>(base?: I): MembershipBindingLifecycleState {
    return MembershipBindingLifecycleState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MembershipBindingLifecycleState>, I>>(
    object: I,
  ): MembershipBindingLifecycleState {
    const message = createBaseMembershipBindingLifecycleState();
    message.code = object.code ?? 0;
    return message;
  },
};

function createBaseMembership(): Membership {
  return {
    endpoint: undefined,
    name: "",
    labels: {},
    description: "",
    state: undefined,
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    externalId: "",
    lastConnectionTime: undefined,
    uniqueId: "",
    authority: undefined,
  };
}

export const Membership: MessageFns<Membership> = {
  encode(message: Membership, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== undefined) {
      MembershipEndpoint.encode(message.endpoint, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Membership_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.state !== undefined) {
      MembershipState.encode(message.state, writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(66).fork()).join();
    }
    if (message.externalId !== "") {
      writer.uint32(74).string(message.externalId);
    }
    if (message.lastConnectionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastConnectionTime), writer.uint32(82).fork()).join();
    }
    if (message.uniqueId !== "") {
      writer.uint32(90).string(message.uniqueId);
    }
    if (message.authority !== undefined) {
      Authority.encode(message.authority, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Membership {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endpoint = MembershipEndpoint.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Membership_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.state = MembershipState.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lastConnectionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.authority = Authority.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Membership {
    return {
      endpoint: isSet(object.endpoint) ? MembershipEndpoint.fromJSON(object.endpoint) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? MembershipState.fromJSON(object.state) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      lastConnectionTime: isSet(object.lastConnectionTime) ? fromJsonTimestamp(object.lastConnectionTime) : undefined,
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      authority: isSet(object.authority) ? Authority.fromJSON(object.authority) : undefined,
    };
  },

  toJSON(message: Membership): unknown {
    const obj: any = {};
    if (message.endpoint !== undefined) {
      obj.endpoint = MembershipEndpoint.toJSON(message.endpoint);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== undefined) {
      obj.state = MembershipState.toJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.lastConnectionTime !== undefined) {
      obj.lastConnectionTime = message.lastConnectionTime.toISOString();
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.authority !== undefined) {
      obj.authority = Authority.toJSON(message.authority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Membership>, I>>(base?: I): Membership {
    return Membership.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Membership>, I>>(object: I): Membership {
    const message = createBaseMembership();
    message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
      ? MembershipEndpoint.fromPartial(object.endpoint)
      : undefined;
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.state = (object.state !== undefined && object.state !== null)
      ? MembershipState.fromPartial(object.state)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.externalId = object.externalId ?? "";
    message.lastConnectionTime = object.lastConnectionTime ?? undefined;
    message.uniqueId = object.uniqueId ?? "";
    message.authority = (object.authority !== undefined && object.authority !== null)
      ? Authority.fromPartial(object.authority)
      : undefined;
    return message;
  },
};

function createBaseMembership_LabelsEntry(): Membership_LabelsEntry {
  return { key: "", value: "" };
}

export const Membership_LabelsEntry: MessageFns<Membership_LabelsEntry> = {
  encode(message: Membership_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Membership_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembership_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Membership_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Membership_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Membership_LabelsEntry>, I>>(base?: I): Membership_LabelsEntry {
    return Membership_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Membership_LabelsEntry>, I>>(object: I): Membership_LabelsEntry {
    const message = createBaseMembership_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMembershipEndpoint(): MembershipEndpoint {
  return {
    gkeCluster: undefined,
    onPremCluster: undefined,
    multiCloudCluster: undefined,
    edgeCluster: undefined,
    applianceCluster: undefined,
    kubernetesMetadata: undefined,
    kubernetesResource: undefined,
    googleManaged: false,
  };
}

export const MembershipEndpoint: MessageFns<MembershipEndpoint> = {
  encode(message: MembershipEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gkeCluster !== undefined) {
      GkeCluster.encode(message.gkeCluster, writer.uint32(10).fork()).join();
    }
    if (message.onPremCluster !== undefined) {
      OnPremCluster.encode(message.onPremCluster, writer.uint32(34).fork()).join();
    }
    if (message.multiCloudCluster !== undefined) {
      MultiCloudCluster.encode(message.multiCloudCluster, writer.uint32(42).fork()).join();
    }
    if (message.edgeCluster !== undefined) {
      EdgeCluster.encode(message.edgeCluster, writer.uint32(50).fork()).join();
    }
    if (message.applianceCluster !== undefined) {
      ApplianceCluster.encode(message.applianceCluster, writer.uint32(58).fork()).join();
    }
    if (message.kubernetesMetadata !== undefined) {
      KubernetesMetadata.encode(message.kubernetesMetadata, writer.uint32(18).fork()).join();
    }
    if (message.kubernetesResource !== undefined) {
      KubernetesResource.encode(message.kubernetesResource, writer.uint32(26).fork()).join();
    }
    if (message.googleManaged !== false) {
      writer.uint32(64).bool(message.googleManaged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gkeCluster = GkeCluster.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.onPremCluster = OnPremCluster.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.multiCloudCluster = MultiCloudCluster.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.edgeCluster = EdgeCluster.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.applianceCluster = ApplianceCluster.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kubernetesMetadata = KubernetesMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kubernetesResource = KubernetesResource.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.googleManaged = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipEndpoint {
    return {
      gkeCluster: isSet(object.gkeCluster) ? GkeCluster.fromJSON(object.gkeCluster) : undefined,
      onPremCluster: isSet(object.onPremCluster) ? OnPremCluster.fromJSON(object.onPremCluster) : undefined,
      multiCloudCluster: isSet(object.multiCloudCluster)
        ? MultiCloudCluster.fromJSON(object.multiCloudCluster)
        : undefined,
      edgeCluster: isSet(object.edgeCluster) ? EdgeCluster.fromJSON(object.edgeCluster) : undefined,
      applianceCluster: isSet(object.applianceCluster) ? ApplianceCluster.fromJSON(object.applianceCluster) : undefined,
      kubernetesMetadata: isSet(object.kubernetesMetadata)
        ? KubernetesMetadata.fromJSON(object.kubernetesMetadata)
        : undefined,
      kubernetesResource: isSet(object.kubernetesResource)
        ? KubernetesResource.fromJSON(object.kubernetesResource)
        : undefined,
      googleManaged: isSet(object.googleManaged) ? globalThis.Boolean(object.googleManaged) : false,
    };
  },

  toJSON(message: MembershipEndpoint): unknown {
    const obj: any = {};
    if (message.gkeCluster !== undefined) {
      obj.gkeCluster = GkeCluster.toJSON(message.gkeCluster);
    }
    if (message.onPremCluster !== undefined) {
      obj.onPremCluster = OnPremCluster.toJSON(message.onPremCluster);
    }
    if (message.multiCloudCluster !== undefined) {
      obj.multiCloudCluster = MultiCloudCluster.toJSON(message.multiCloudCluster);
    }
    if (message.edgeCluster !== undefined) {
      obj.edgeCluster = EdgeCluster.toJSON(message.edgeCluster);
    }
    if (message.applianceCluster !== undefined) {
      obj.applianceCluster = ApplianceCluster.toJSON(message.applianceCluster);
    }
    if (message.kubernetesMetadata !== undefined) {
      obj.kubernetesMetadata = KubernetesMetadata.toJSON(message.kubernetesMetadata);
    }
    if (message.kubernetesResource !== undefined) {
      obj.kubernetesResource = KubernetesResource.toJSON(message.kubernetesResource);
    }
    if (message.googleManaged !== false) {
      obj.googleManaged = message.googleManaged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipEndpoint>, I>>(base?: I): MembershipEndpoint {
    return MembershipEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MembershipEndpoint>, I>>(object: I): MembershipEndpoint {
    const message = createBaseMembershipEndpoint();
    message.gkeCluster = (object.gkeCluster !== undefined && object.gkeCluster !== null)
      ? GkeCluster.fromPartial(object.gkeCluster)
      : undefined;
    message.onPremCluster = (object.onPremCluster !== undefined && object.onPremCluster !== null)
      ? OnPremCluster.fromPartial(object.onPremCluster)
      : undefined;
    message.multiCloudCluster = (object.multiCloudCluster !== undefined && object.multiCloudCluster !== null)
      ? MultiCloudCluster.fromPartial(object.multiCloudCluster)
      : undefined;
    message.edgeCluster = (object.edgeCluster !== undefined && object.edgeCluster !== null)
      ? EdgeCluster.fromPartial(object.edgeCluster)
      : undefined;
    message.applianceCluster = (object.applianceCluster !== undefined && object.applianceCluster !== null)
      ? ApplianceCluster.fromPartial(object.applianceCluster)
      : undefined;
    message.kubernetesMetadata = (object.kubernetesMetadata !== undefined && object.kubernetesMetadata !== null)
      ? KubernetesMetadata.fromPartial(object.kubernetesMetadata)
      : undefined;
    message.kubernetesResource = (object.kubernetesResource !== undefined && object.kubernetesResource !== null)
      ? KubernetesResource.fromPartial(object.kubernetesResource)
      : undefined;
    message.googleManaged = object.googleManaged ?? false;
    return message;
  },
};

function createBaseKubernetesResource(): KubernetesResource {
  return { membershipResources: [], connectResources: [], resourceOptions: undefined };
}

export const KubernetesResource: MessageFns<KubernetesResource> = {
  encode(message: KubernetesResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.membershipResources) {
      ResourceManifest.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.connectResources) {
      ResourceManifest.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.resourceOptions !== undefined) {
      ResourceOptions.encode(message.resourceOptions, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.membershipResources.push(ResourceManifest.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectResources.push(ResourceManifest.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resourceOptions = ResourceOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesResource {
    return {
      membershipResources: globalThis.Array.isArray(object?.membershipResources)
        ? object.membershipResources.map((e: any) => ResourceManifest.fromJSON(e))
        : [],
      connectResources: globalThis.Array.isArray(object?.connectResources)
        ? object.connectResources.map((e: any) => ResourceManifest.fromJSON(e))
        : [],
      resourceOptions: isSet(object.resourceOptions) ? ResourceOptions.fromJSON(object.resourceOptions) : undefined,
    };
  },

  toJSON(message: KubernetesResource): unknown {
    const obj: any = {};
    if (message.membershipResources?.length) {
      obj.membershipResources = message.membershipResources.map((e) => ResourceManifest.toJSON(e));
    }
    if (message.connectResources?.length) {
      obj.connectResources = message.connectResources.map((e) => ResourceManifest.toJSON(e));
    }
    if (message.resourceOptions !== undefined) {
      obj.resourceOptions = ResourceOptions.toJSON(message.resourceOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesResource>, I>>(base?: I): KubernetesResource {
    return KubernetesResource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesResource>, I>>(object: I): KubernetesResource {
    const message = createBaseKubernetesResource();
    message.membershipResources = object.membershipResources?.map((e) => ResourceManifest.fromPartial(e)) || [];
    message.connectResources = object.connectResources?.map((e) => ResourceManifest.fromPartial(e)) || [];
    message.resourceOptions = (object.resourceOptions !== undefined && object.resourceOptions !== null)
      ? ResourceOptions.fromPartial(object.resourceOptions)
      : undefined;
    return message;
  },
};

function createBaseResourceOptions(): ResourceOptions {
  return { connectVersion: "", v1beta1Crd: false, k8sVersion: "" };
}

export const ResourceOptions: MessageFns<ResourceOptions> = {
  encode(message: ResourceOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectVersion !== "") {
      writer.uint32(10).string(message.connectVersion);
    }
    if (message.v1beta1Crd !== false) {
      writer.uint32(16).bool(message.v1beta1Crd);
    }
    if (message.k8sVersion !== "") {
      writer.uint32(26).string(message.k8sVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.v1beta1Crd = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.k8sVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceOptions {
    return {
      connectVersion: isSet(object.connectVersion) ? globalThis.String(object.connectVersion) : "",
      v1beta1Crd: isSet(object.v1beta1Crd) ? globalThis.Boolean(object.v1beta1Crd) : false,
      k8sVersion: isSet(object.k8sVersion) ? globalThis.String(object.k8sVersion) : "",
    };
  },

  toJSON(message: ResourceOptions): unknown {
    const obj: any = {};
    if (message.connectVersion !== "") {
      obj.connectVersion = message.connectVersion;
    }
    if (message.v1beta1Crd !== false) {
      obj.v1beta1Crd = message.v1beta1Crd;
    }
    if (message.k8sVersion !== "") {
      obj.k8sVersion = message.k8sVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceOptions>, I>>(base?: I): ResourceOptions {
    return ResourceOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceOptions>, I>>(object: I): ResourceOptions {
    const message = createBaseResourceOptions();
    message.connectVersion = object.connectVersion ?? "";
    message.v1beta1Crd = object.v1beta1Crd ?? false;
    message.k8sVersion = object.k8sVersion ?? "";
    return message;
  },
};

function createBaseResourceManifest(): ResourceManifest {
  return { manifest: "", clusterScoped: false };
}

export const ResourceManifest: MessageFns<ResourceManifest> = {
  encode(message: ResourceManifest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.manifest !== "") {
      writer.uint32(10).string(message.manifest);
    }
    if (message.clusterScoped !== false) {
      writer.uint32(16).bool(message.clusterScoped);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceManifest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceManifest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.manifest = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clusterScoped = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceManifest {
    return {
      manifest: isSet(object.manifest) ? globalThis.String(object.manifest) : "",
      clusterScoped: isSet(object.clusterScoped) ? globalThis.Boolean(object.clusterScoped) : false,
    };
  },

  toJSON(message: ResourceManifest): unknown {
    const obj: any = {};
    if (message.manifest !== "") {
      obj.manifest = message.manifest;
    }
    if (message.clusterScoped !== false) {
      obj.clusterScoped = message.clusterScoped;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceManifest>, I>>(base?: I): ResourceManifest {
    return ResourceManifest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceManifest>, I>>(object: I): ResourceManifest {
    const message = createBaseResourceManifest();
    message.manifest = object.manifest ?? "";
    message.clusterScoped = object.clusterScoped ?? false;
    return message;
  },
};

function createBaseGkeCluster(): GkeCluster {
  return { resourceLink: "", clusterMissing: false };
}

export const GkeCluster: MessageFns<GkeCluster> = {
  encode(message: GkeCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    if (message.clusterMissing !== false) {
      writer.uint32(16).bool(message.clusterMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GkeCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGkeCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clusterMissing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GkeCluster {
    return {
      resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "",
      clusterMissing: isSet(object.clusterMissing) ? globalThis.Boolean(object.clusterMissing) : false,
    };
  },

  toJSON(message: GkeCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    if (message.clusterMissing !== false) {
      obj.clusterMissing = message.clusterMissing;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GkeCluster>, I>>(base?: I): GkeCluster {
    return GkeCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GkeCluster>, I>>(object: I): GkeCluster {
    const message = createBaseGkeCluster();
    message.resourceLink = object.resourceLink ?? "";
    message.clusterMissing = object.clusterMissing ?? false;
    return message;
  },
};

function createBaseOnPremCluster(): OnPremCluster {
  return { resourceLink: "", clusterMissing: false, adminCluster: false, clusterType: 0 };
}

export const OnPremCluster: MessageFns<OnPremCluster> = {
  encode(message: OnPremCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    if (message.clusterMissing !== false) {
      writer.uint32(16).bool(message.clusterMissing);
    }
    if (message.adminCluster !== false) {
      writer.uint32(24).bool(message.adminCluster);
    }
    if (message.clusterType !== 0) {
      writer.uint32(32).int32(message.clusterType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnPremCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnPremCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clusterMissing = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.adminCluster = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.clusterType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnPremCluster {
    return {
      resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "",
      clusterMissing: isSet(object.clusterMissing) ? globalThis.Boolean(object.clusterMissing) : false,
      adminCluster: isSet(object.adminCluster) ? globalThis.Boolean(object.adminCluster) : false,
      clusterType: isSet(object.clusterType) ? onPremCluster_ClusterTypeFromJSON(object.clusterType) : 0,
    };
  },

  toJSON(message: OnPremCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    if (message.clusterMissing !== false) {
      obj.clusterMissing = message.clusterMissing;
    }
    if (message.adminCluster !== false) {
      obj.adminCluster = message.adminCluster;
    }
    if (message.clusterType !== 0) {
      obj.clusterType = onPremCluster_ClusterTypeToJSON(message.clusterType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnPremCluster>, I>>(base?: I): OnPremCluster {
    return OnPremCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnPremCluster>, I>>(object: I): OnPremCluster {
    const message = createBaseOnPremCluster();
    message.resourceLink = object.resourceLink ?? "";
    message.clusterMissing = object.clusterMissing ?? false;
    message.adminCluster = object.adminCluster ?? false;
    message.clusterType = object.clusterType ?? 0;
    return message;
  },
};

function createBaseMultiCloudCluster(): MultiCloudCluster {
  return { resourceLink: "", clusterMissing: false };
}

export const MultiCloudCluster: MessageFns<MultiCloudCluster> = {
  encode(message: MultiCloudCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    if (message.clusterMissing !== false) {
      writer.uint32(16).bool(message.clusterMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiCloudCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiCloudCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clusterMissing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiCloudCluster {
    return {
      resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "",
      clusterMissing: isSet(object.clusterMissing) ? globalThis.Boolean(object.clusterMissing) : false,
    };
  },

  toJSON(message: MultiCloudCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    if (message.clusterMissing !== false) {
      obj.clusterMissing = message.clusterMissing;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiCloudCluster>, I>>(base?: I): MultiCloudCluster {
    return MultiCloudCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiCloudCluster>, I>>(object: I): MultiCloudCluster {
    const message = createBaseMultiCloudCluster();
    message.resourceLink = object.resourceLink ?? "";
    message.clusterMissing = object.clusterMissing ?? false;
    return message;
  },
};

function createBaseEdgeCluster(): EdgeCluster {
  return { resourceLink: "" };
}

export const EdgeCluster: MessageFns<EdgeCluster> = {
  encode(message: EdgeCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EdgeCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeCluster {
    return { resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "" };
  },

  toJSON(message: EdgeCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EdgeCluster>, I>>(base?: I): EdgeCluster {
    return EdgeCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EdgeCluster>, I>>(object: I): EdgeCluster {
    const message = createBaseEdgeCluster();
    message.resourceLink = object.resourceLink ?? "";
    return message;
  },
};

function createBaseApplianceCluster(): ApplianceCluster {
  return { resourceLink: "" };
}

export const ApplianceCluster: MessageFns<ApplianceCluster> = {
  encode(message: ApplianceCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplianceCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplianceCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplianceCluster {
    return { resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "" };
  },

  toJSON(message: ApplianceCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplianceCluster>, I>>(base?: I): ApplianceCluster {
    return ApplianceCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplianceCluster>, I>>(object: I): ApplianceCluster {
    const message = createBaseApplianceCluster();
    message.resourceLink = object.resourceLink ?? "";
    return message;
  },
};

function createBaseKubernetesMetadata(): KubernetesMetadata {
  return {
    kubernetesApiServerVersion: "",
    nodeProviderId: "",
    nodeCount: 0,
    vcpuCount: 0,
    memoryMb: 0,
    updateTime: undefined,
  };
}

export const KubernetesMetadata: MessageFns<KubernetesMetadata> = {
  encode(message: KubernetesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kubernetesApiServerVersion !== "") {
      writer.uint32(10).string(message.kubernetesApiServerVersion);
    }
    if (message.nodeProviderId !== "") {
      writer.uint32(18).string(message.nodeProviderId);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(24).int32(message.nodeCount);
    }
    if (message.vcpuCount !== 0) {
      writer.uint32(32).int32(message.vcpuCount);
    }
    if (message.memoryMb !== 0) {
      writer.uint32(40).int32(message.memoryMb);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kubernetesApiServerVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeProviderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.vcpuCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.memoryMb = reader.int32();
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesMetadata {
    return {
      kubernetesApiServerVersion: isSet(object.kubernetesApiServerVersion)
        ? globalThis.String(object.kubernetesApiServerVersion)
        : "",
      nodeProviderId: isSet(object.nodeProviderId) ? globalThis.String(object.nodeProviderId) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      vcpuCount: isSet(object.vcpuCount) ? globalThis.Number(object.vcpuCount) : 0,
      memoryMb: isSet(object.memoryMb) ? globalThis.Number(object.memoryMb) : 0,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: KubernetesMetadata): unknown {
    const obj: any = {};
    if (message.kubernetesApiServerVersion !== "") {
      obj.kubernetesApiServerVersion = message.kubernetesApiServerVersion;
    }
    if (message.nodeProviderId !== "") {
      obj.nodeProviderId = message.nodeProviderId;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.vcpuCount !== 0) {
      obj.vcpuCount = Math.round(message.vcpuCount);
    }
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesMetadata>, I>>(base?: I): KubernetesMetadata {
    return KubernetesMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesMetadata>, I>>(object: I): KubernetesMetadata {
    const message = createBaseKubernetesMetadata();
    message.kubernetesApiServerVersion = object.kubernetesApiServerVersion ?? "";
    message.nodeProviderId = object.nodeProviderId ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.vcpuCount = object.vcpuCount ?? 0;
    message.memoryMb = object.memoryMb ?? 0;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseMembershipState(): MembershipState {
  return { code: 0 };
}

export const MembershipState: MessageFns<MembershipState> = {
  encode(message: MembershipState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipState {
    return { code: isSet(object.code) ? membershipState_CodeFromJSON(object.code) : 0 };
  },

  toJSON(message: MembershipState): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = membershipState_CodeToJSON(message.code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipState>, I>>(base?: I): MembershipState {
    return MembershipState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MembershipState>, I>>(object: I): MembershipState {
    const message = createBaseMembershipState();
    message.code = object.code ?? 0;
    return message;
  },
};

function createBaseAuthority(): Authority {
  return { issuer: "", workloadIdentityPool: "", identityProvider: "", oidcJwks: new Uint8Array(0) };
}

export const Authority: MessageFns<Authority> = {
  encode(message: Authority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.workloadIdentityPool !== "") {
      writer.uint32(18).string(message.workloadIdentityPool);
    }
    if (message.identityProvider !== "") {
      writer.uint32(26).string(message.identityProvider);
    }
    if (message.oidcJwks.length !== 0) {
      writer.uint32(34).bytes(message.oidcJwks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workloadIdentityPool = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identityProvider = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oidcJwks = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authority {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      workloadIdentityPool: isSet(object.workloadIdentityPool) ? globalThis.String(object.workloadIdentityPool) : "",
      identityProvider: isSet(object.identityProvider) ? globalThis.String(object.identityProvider) : "",
      oidcJwks: isSet(object.oidcJwks) ? bytesFromBase64(object.oidcJwks) : new Uint8Array(0),
    };
  },

  toJSON(message: Authority): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.workloadIdentityPool !== "") {
      obj.workloadIdentityPool = message.workloadIdentityPool;
    }
    if (message.identityProvider !== "") {
      obj.identityProvider = message.identityProvider;
    }
    if (message.oidcJwks.length !== 0) {
      obj.oidcJwks = base64FromBytes(message.oidcJwks);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Authority>, I>>(base?: I): Authority {
    return Authority.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Authority>, I>>(object: I): Authority {
    const message = createBaseAuthority();
    message.issuer = object.issuer ?? "";
    message.workloadIdentityPool = object.workloadIdentityPool ?? "";
    message.identityProvider = object.identityProvider ?? "";
    message.oidcJwks = object.oidcJwks ?? new Uint8Array(0);
    return message;
  },
};

function createBaseScopeEventData(): ScopeEventData {
  return { payload: undefined };
}

export const ScopeEventData: MessageFns<ScopeEventData> = {
  encode(message: ScopeEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Scope.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopeEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopeEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Scope.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopeEventData {
    return { payload: isSet(object.payload) ? Scope.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ScopeEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Scope.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopeEventData>, I>>(base?: I): ScopeEventData {
    return ScopeEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopeEventData>, I>>(object: I): ScopeEventData {
    const message = createBaseScopeEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Scope.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseMembershipEventData(): MembershipEventData {
  return { payload: undefined };
}

export const MembershipEventData: MessageFns<MembershipEventData> = {
  encode(message: MembershipEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Membership.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Membership.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipEventData {
    return { payload: isSet(object.payload) ? Membership.fromJSON(object.payload) : undefined };
  },

  toJSON(message: MembershipEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Membership.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipEventData>, I>>(base?: I): MembershipEventData {
    return MembershipEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MembershipEventData>, I>>(object: I): MembershipEventData {
    const message = createBaseMembershipEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Membership.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseFeatureEventData(): FeatureEventData {
  return { payload: undefined };
}

export const FeatureEventData: MessageFns<FeatureEventData> = {
  encode(message: FeatureEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Feature.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Feature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureEventData {
    return { payload: isSet(object.payload) ? Feature.fromJSON(object.payload) : undefined };
  },

  toJSON(message: FeatureEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Feature.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureEventData>, I>>(base?: I): FeatureEventData {
    return FeatureEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureEventData>, I>>(object: I): FeatureEventData {
    const message = createBaseFeatureEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Feature.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseMembershipBindingEventData(): MembershipBindingEventData {
  return { payload: undefined };
}

export const MembershipBindingEventData: MessageFns<MembershipBindingEventData> = {
  encode(message: MembershipBindingEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      MembershipBinding.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipBindingEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipBindingEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = MembershipBinding.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipBindingEventData {
    return { payload: isSet(object.payload) ? MembershipBinding.fromJSON(object.payload) : undefined };
  },

  toJSON(message: MembershipBindingEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = MembershipBinding.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipBindingEventData>, I>>(base?: I): MembershipBindingEventData {
    return MembershipBindingEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MembershipBindingEventData>, I>>(object: I): MembershipBindingEventData {
    const message = createBaseMembershipBindingEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? MembershipBinding.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
