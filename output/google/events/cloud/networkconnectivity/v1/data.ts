// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/networkconnectivity/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";
import { Status } from "../../../../rpc/status";

export const protobufPackage = "google.events.cloud.networkconnectivity.v1";

/** The infrastructure used for connections between consumers/producers. */
export enum Infrastructure {
  /** INFRASTRUCTURE_UNSPECIFIED - An invalid infrastructure as the default case. */
  INFRASTRUCTURE_UNSPECIFIED = 0,
  /** PSC - Private Service Connect is used for connections. */
  PSC = 1,
  UNRECOGNIZED = -1,
}

export function infrastructureFromJSON(object: any): Infrastructure {
  switch (object) {
    case 0:
    case "INFRASTRUCTURE_UNSPECIFIED":
      return Infrastructure.INFRASTRUCTURE_UNSPECIFIED;
    case 1:
    case "PSC":
      return Infrastructure.PSC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Infrastructure.UNRECOGNIZED;
  }
}

export function infrastructureToJSON(object: Infrastructure): string {
  switch (object) {
    case Infrastructure.INFRASTRUCTURE_UNSPECIFIED:
      return "INFRASTRUCTURE_UNSPECIFIED";
    case Infrastructure.PSC:
      return "PSC";
    case Infrastructure.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The error type indicates whether a connection error is consumer facing,
 * producer facing or system internal.
 */
export enum ConnectionErrorType {
  /** CONNECTION_ERROR_TYPE_UNSPECIFIED - An invalid error type as the default case. */
  CONNECTION_ERROR_TYPE_UNSPECIFIED = 0,
  /** ERROR_INTERNAL - The error is due to Service Automation system internal. */
  ERROR_INTERNAL = 1,
  /** ERROR_CONSUMER_SIDE - The error is due to the setup on consumer side. */
  ERROR_CONSUMER_SIDE = 2,
  /** ERROR_PRODUCER_SIDE - The error is due to the setup on producer side. */
  ERROR_PRODUCER_SIDE = 3,
  UNRECOGNIZED = -1,
}

export function connectionErrorTypeFromJSON(object: any): ConnectionErrorType {
  switch (object) {
    case 0:
    case "CONNECTION_ERROR_TYPE_UNSPECIFIED":
      return ConnectionErrorType.CONNECTION_ERROR_TYPE_UNSPECIFIED;
    case 1:
    case "ERROR_INTERNAL":
      return ConnectionErrorType.ERROR_INTERNAL;
    case 2:
    case "ERROR_CONSUMER_SIDE":
      return ConnectionErrorType.ERROR_CONSUMER_SIDE;
    case 3:
    case "ERROR_PRODUCER_SIDE":
      return ConnectionErrorType.ERROR_PRODUCER_SIDE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionErrorType.UNRECOGNIZED;
  }
}

export function connectionErrorTypeToJSON(object: ConnectionErrorType): string {
  switch (object) {
    case ConnectionErrorType.CONNECTION_ERROR_TYPE_UNSPECIFIED:
      return "CONNECTION_ERROR_TYPE_UNSPECIFIED";
    case ConnectionErrorType.ERROR_INTERNAL:
      return "ERROR_INTERNAL";
    case ConnectionErrorType.ERROR_CONSUMER_SIDE:
      return "ERROR_CONSUMER_SIDE";
    case ConnectionErrorType.ERROR_PRODUCER_SIDE:
      return "ERROR_PRODUCER_SIDE";
    case ConnectionErrorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The State enum represents the lifecycle stage of a Network Connectivity
 * Center resource.
 */
export enum State {
  /** STATE_UNSPECIFIED - No state information available */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The resource's create operation is in progress. */
  CREATING = 1,
  /** ACTIVE - The resource is active */
  ACTIVE = 2,
  /** DELETING - The resource's delete operation is in progress. */
  DELETING = 3,
  /** UPDATING - The resource's update operation is in progress. */
  UPDATING = 6,
  UNRECOGNIZED = -1,
}

export function stateFromJSON(object: any): State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return State.CREATING;
    case 2:
    case "ACTIVE":
      return State.ACTIVE;
    case 3:
    case "DELETING":
      return State.DELETING;
    case 6:
    case "UPDATING":
      return State.UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return State.UNRECOGNIZED;
  }
}

export function stateToJSON(object: State): string {
  switch (object) {
    case State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case State.CREATING:
      return "CREATING";
    case State.ACTIVE:
      return "ACTIVE";
    case State.DELETING:
      return "DELETING";
    case State.UPDATING:
      return "UPDATING";
    case State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The ServiceConnectionMap resource.
 * Next id: 14
 */
export interface ServiceConnectionMap {
  /**
   * Immutable. The name of a ServiceConnectionMap.
   * Format:
   * projects/{project}/locations/{location}/serviceConnectionMaps/{service_connection_map}
   * See: https://google.aip.dev/122#fields-representing-resource-names
   */
  name: string;
  /** Output only. Time when the ServiceConnectionMap was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Time when the ServiceConnectionMap was updated. */
  updateTime?:
    | Date
    | undefined;
  /** User-defined labels. */
  labels: { [key: string]: string };
  /** A description of this resource. */
  description: string;
  /**
   * The service class identifier this ServiceConnectionMap is for.
   * The user of ServiceConnectionMap create API needs to have
   * networkconnecitivty.serviceclasses.use iam permission for the service
   * class.
   */
  serviceClass: string;
  /** Output only. The service class uri this ServiceConnectionMap is for. */
  serviceClassUri: string;
  /**
   * Output only. The infrastructure used for connections between
   * consumers/producers.
   */
  infrastructure: Infrastructure;
  /** The PSC configurations on producer side. */
  producerPscConfigs: ServiceConnectionMap_ProducerPscConfig[];
  /** The PSC configurations on consumer side. */
  consumerPscConfigs: ServiceConnectionMap_ConsumerPscConfig[];
  /** Output only. PSC connection details on consumer side. */
  consumerPscConnections: ServiceConnectionMap_ConsumerPscConnection[];
}

/** The PSC configurations on producer side. */
export interface ServiceConnectionMap_ProducerPscConfig {
  /**
   * The resource path of a service attachment.
   * Example:
   * projects/{projectNumOrId}/regions/{region}/serviceAttachments/{resourceId}.
   */
  serviceAttachmentUri: string;
}

/** Allow the producer to specify which consumers can connect to it. */
export interface ServiceConnectionMap_ConsumerPscConfig {
  /** The consumer project where PSC connections are allowed to be created in. */
  project: string;
  /**
   * The resource path of the consumer network where PSC connections are
   * allowed to be created in. Note, this network does not need be in the
   * ConsumerPscConfig.project in the case of SharedVPC.
   * Example:
   * projects/{projectNumOrId}/global/networks/{networkId}.
   */
  network: string;
  /**
   * This is used in PSC consumer ForwardingRule to control whether the PSC
   * endpoint can be accessed from another region.
   */
  disableGlobalAccess: boolean;
  /**
   * Output only. Overall state of PSC Connections management for this
   * consumer psc config.
   */
  state: ServiceConnectionMap_ConsumerPscConfig_State;
}

/** PSC Consumer Config State. */
export enum ServiceConnectionMap_ConsumerPscConfig_State {
  /** STATE_UNSPECIFIED - Default state, when Connection Map is created initially. */
  STATE_UNSPECIFIED = 0,
  /**
   * VALID - Set when policy and map configuration is valid,
   * and their matching can lead to allowing creation of PSC Connections
   * subject to other constraints like connections limit.
   */
  VALID = 1,
  /**
   * CONNECTION_POLICY_MISSING - No Service Connection Policy found for this network and Service
   * Class
   */
  CONNECTION_POLICY_MISSING = 2,
  UNRECOGNIZED = -1,
}

export function serviceConnectionMap_ConsumerPscConfig_StateFromJSON(
  object: any,
): ServiceConnectionMap_ConsumerPscConfig_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ServiceConnectionMap_ConsumerPscConfig_State.STATE_UNSPECIFIED;
    case 1:
    case "VALID":
      return ServiceConnectionMap_ConsumerPscConfig_State.VALID;
    case 2:
    case "CONNECTION_POLICY_MISSING":
      return ServiceConnectionMap_ConsumerPscConfig_State.CONNECTION_POLICY_MISSING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceConnectionMap_ConsumerPscConfig_State.UNRECOGNIZED;
  }
}

export function serviceConnectionMap_ConsumerPscConfig_StateToJSON(
  object: ServiceConnectionMap_ConsumerPscConfig_State,
): string {
  switch (object) {
    case ServiceConnectionMap_ConsumerPscConfig_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ServiceConnectionMap_ConsumerPscConfig_State.VALID:
      return "VALID";
    case ServiceConnectionMap_ConsumerPscConfig_State.CONNECTION_POLICY_MISSING:
      return "CONNECTION_POLICY_MISSING";
    case ServiceConnectionMap_ConsumerPscConfig_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** PSC connection details on consumer side. */
export interface ServiceConnectionMap_ConsumerPscConnection {
  /**
   * The URI of a service attachment which is the target of the PSC
   * connection.
   */
  serviceAttachmentUri: string;
  /** The state of the PSC connection. */
  state: ServiceConnectionMap_ConsumerPscConnection_State;
  /**
   * The consumer project whose PSC forwarding rule is connected to the
   * service attachments in this service connection map.
   */
  project: string;
  /**
   * The consumer network whose PSC forwarding rule is connected to the
   * service attachments in this service connection map.
   * Note that the network could be on a different project (shared VPC).
   */
  network: string;
  /**
   * The PSC connection id of the PSC forwarding rule connected
   * to the service attachments in this service connection map.
   */
  pscConnectionId: string;
  /**
   * The IP literal allocated on the consumer network for the PSC forwarding
   * rule that is created to connect to the producer service attachment in
   * this service connection map.
   */
  ip: string;
  /**
   * The error type indicates whether the error is consumer facing, producer
   * facing or system internal.
   */
  errorType: ConnectionErrorType;
  /** The most recent error during operating this connection. */
  error?:
    | Status
    | undefined;
  /** The last Compute Engine operation to setup PSC connection. */
  gceOperation: string;
  /**
   * The URI of the consumer forwarding rule created.
   * Example:
   * projects/{projectNumOrId}/regions/us-east1/networks/{resourceId}.
   */
  forwardingRule: string;
}

/** The state of the PSC connection. */
export enum ServiceConnectionMap_ConsumerPscConnection_State {
  /** STATE_UNSPECIFIED - An invalid state as the default case. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The connection is fully established and ready to use. */
  ACTIVE = 1,
  /**
   * FAILED - The connection is not functional since some resources on the connection
   * fail to be created.
   */
  FAILED = 2,
  /** CREATING - The connection is being created. */
  CREATING = 3,
  /** DELETING - The connection is being deleted. */
  DELETING = 4,
  UNRECOGNIZED = -1,
}

export function serviceConnectionMap_ConsumerPscConnection_StateFromJSON(
  object: any,
): ServiceConnectionMap_ConsumerPscConnection_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ServiceConnectionMap_ConsumerPscConnection_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ServiceConnectionMap_ConsumerPscConnection_State.ACTIVE;
    case 2:
    case "FAILED":
      return ServiceConnectionMap_ConsumerPscConnection_State.FAILED;
    case 3:
    case "CREATING":
      return ServiceConnectionMap_ConsumerPscConnection_State.CREATING;
    case 4:
    case "DELETING":
      return ServiceConnectionMap_ConsumerPscConnection_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceConnectionMap_ConsumerPscConnection_State.UNRECOGNIZED;
  }
}

export function serviceConnectionMap_ConsumerPscConnection_StateToJSON(
  object: ServiceConnectionMap_ConsumerPscConnection_State,
): string {
  switch (object) {
    case ServiceConnectionMap_ConsumerPscConnection_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ServiceConnectionMap_ConsumerPscConnection_State.ACTIVE:
      return "ACTIVE";
    case ServiceConnectionMap_ConsumerPscConnection_State.FAILED:
      return "FAILED";
    case ServiceConnectionMap_ConsumerPscConnection_State.CREATING:
      return "CREATING";
    case ServiceConnectionMap_ConsumerPscConnection_State.DELETING:
      return "DELETING";
    case ServiceConnectionMap_ConsumerPscConnection_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ServiceConnectionMap_LabelsEntry {
  key: string;
  value: string;
}

/**
 * The ServiceConnectionPolicy resource.
 * Next id: 11
 */
export interface ServiceConnectionPolicy {
  /**
   * Immutable. The name of a ServiceConnectionPolicy.
   * Format:
   * projects/{project}/locations/{location}/serviceConnectionPolicies/{service_connection_policy}
   * See: https://google.aip.dev/122#fields-representing-resource-names
   */
  name: string;
  /** Output only. Time when the ServiceConnectionMap was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Time when the ServiceConnectionMap was updated. */
  updateTime?:
    | Date
    | undefined;
  /** User-defined labels. */
  labels: { [key: string]: string };
  /** A description of this resource. */
  description: string;
  /**
   * The resource path of the consumer network.
   * Example:
   * - projects/{projectNumOrId}/global/networks/{resourceId}.
   */
  network: string;
  /**
   * The service class identifier for which this ServiceConnectionPolicy is for.
   * The service class identifier is a unique, symbolic representation of a
   * ServiceClass. It is provided by the Service Producer. Google services have
   * a prefix of gcp. For example, gcp-cloud-sql. 3rd party services do not. For
   * example, test-service-a3dfcx.
   */
  serviceClass: string;
  /**
   * Output only. The type of underlying resources used to create the
   * connection.
   */
  infrastructure: Infrastructure;
  /**
   * Configuration used for Private Service Connect connections. Used when
   * Infrastructure is PSC.
   */
  pscConfig?:
    | ServiceConnectionPolicy_PscConfig
    | undefined;
  /**
   * Output only. [Output only] Information about each Private Service Connect
   * connection.
   */
  pscConnections: ServiceConnectionPolicy_PscConnection[];
}

/** The state of the PSC connection. */
export enum ServiceConnectionPolicy_State {
  /** STATE_UNSPECIFIED - An invalid state as the default case. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The connection is fully established and ready to use. */
  ACTIVE = 1,
  /**
   * FAILED - The connection is not functional since some resources on the connection
   * fail to be created.
   */
  FAILED = 2,
  /** CREATING - The connection is being created. */
  CREATING = 3,
  /** DELETING - The connection is being deleted. */
  DELETING = 4,
  UNRECOGNIZED = -1,
}

export function serviceConnectionPolicy_StateFromJSON(object: any): ServiceConnectionPolicy_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ServiceConnectionPolicy_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ServiceConnectionPolicy_State.ACTIVE;
    case 2:
    case "FAILED":
      return ServiceConnectionPolicy_State.FAILED;
    case 3:
    case "CREATING":
      return ServiceConnectionPolicy_State.CREATING;
    case 4:
    case "DELETING":
      return ServiceConnectionPolicy_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceConnectionPolicy_State.UNRECOGNIZED;
  }
}

export function serviceConnectionPolicy_StateToJSON(object: ServiceConnectionPolicy_State): string {
  switch (object) {
    case ServiceConnectionPolicy_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ServiceConnectionPolicy_State.ACTIVE:
      return "ACTIVE";
    case ServiceConnectionPolicy_State.FAILED:
      return "FAILED";
    case ServiceConnectionPolicy_State.CREATING:
      return "CREATING";
    case ServiceConnectionPolicy_State.DELETING:
      return "DELETING";
    case ServiceConnectionPolicy_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Configuration used for Private Service Connect connections. Used when
 * Infrastructure is PSC.
 */
export interface ServiceConnectionPolicy_PscConfig {
  /**
   * The resource paths of subnetworks to use for IP address management.
   * Example:
   * projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.
   */
  subnetworks: string[];
  /** Optional. Max number of PSC connections for this policy. */
  limit?: Long | undefined;
}

/** Information about a specific Private Service Connect connection. */
export interface ServiceConnectionPolicy_PscConnection {
  /** State of the PSC Connection */
  state: ServiceConnectionPolicy_State;
  /**
   * The resource reference of the PSC Forwarding Rule within the consumer
   * VPC.
   */
  consumerForwardingRule: string;
  /** The resource reference of the consumer address. */
  consumerAddress: string;
  /**
   * The error type indicates whether the error is consumer facing, producer
   * facing or system internal.
   */
  errorType: ConnectionErrorType;
  /** The most recent error during operating this connection. */
  error?:
    | Status
    | undefined;
  /** The last Compute Engine operation to setup PSC connection. */
  gceOperation: string;
  /** The project where the PSC connection is created. */
  consumerTargetProject: string;
  /** The PSC connection id of the PSC forwarding rule. */
  pscConnectionId: string;
}

export interface ServiceConnectionPolicy_LabelsEntry {
  key: string;
  value: string;
}

/**
 * The ServiceClass resource.
 * Next id: 8
 */
export interface ServiceClass {
  /**
   * Immutable. The name of a ServiceClass resource.
   * Format:
   * projects/{project}/locations/{location}/serviceClasses/{service_class}
   * See: https://google.aip.dev/122#fields-representing-resource-names
   */
  name: string;
  /**
   * Output only. The generated service class name. Use this name to refer to
   * the Service class in Service Connection Maps and Service Connection
   * Policies.
   */
  serviceClass: string;
  /** Output only. Time when the ServiceClass was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Time when the ServiceClass was updated. */
  updateTime?:
    | Date
    | undefined;
  /** User-defined labels. */
  labels: { [key: string]: string };
  /** A description of this resource. */
  description: string;
  /** Output only. URIs of all Service Connection Maps using this service class. */
  serviceConnectionMaps: string[];
}

export interface ServiceClass_LabelsEntry {
  key: string;
  value: string;
}

/**
 * The ServiceConnectionToken resource.
 * Next id: 9
 */
export interface ServiceConnectionToken {
  /**
   * Immutable. The name of a ServiceConnectionToken.
   * Format:
   * projects/{project}/locations/{location}/ServiceConnectionTokens/{service_connection_token}
   * See: https://google.aip.dev/122#fields-representing-resource-names
   */
  name: string;
  /** Output only. Time when the ServiceConnectionToken was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Time when the ServiceConnectionToken was updated. */
  updateTime?:
    | Date
    | undefined;
  /** User-defined labels. */
  labels: { [key: string]: string };
  /** A description of this resource. */
  description: string;
  /**
   * The resource path of the network associated with this token.
   * Example:
   * projects/{projectNumOrId}/global/networks/{resourceId}.
   */
  network: string;
}

export interface ServiceConnectionToken_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A Network Connectivity Center hub is a global management resource to which
 * you attach spokes. A single hub can contain spokes from multiple regions.
 * However, if any of a hub's spokes use the site-to-site data transfer feature,
 * the resources associated with those spokes must all be in the same VPC
 * network. Spokes that do not use site-to-site data transfer can be associated
 * with any VPC network in your project.
 */
export interface Hub {
  /**
   * Immutable. The name of the hub. Hub names must be unique. They use the
   * following form:
   *     `projects/{project_number}/locations/global/hubs/{hub_id}`
   */
  name: string;
  /** Output only. The time the hub was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time the hub was last updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional labels in key:value format. For more information about labels, see
   * [Requirements for
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
   */
  labels: { [key: string]: string };
  /** An optional description of the hub. */
  description: string;
  /**
   * Output only. The Google-generated UUID for the hub. This value is unique
   * across all hub resources. If a hub is deleted and another with the same
   * name is created, the new hub is assigned a different unique_id.
   */
  uniqueId: string;
  /** Output only. The current lifecycle state of this hub. */
  state: State;
  /**
   * The VPC networks associated with this hub's spokes.
   *
   * This field is read-only. Network Connectivity Center automatically
   * populates it based on the set of spokes attached to the hub.
   */
  routingVpcs: RoutingVPC[];
}

export interface Hub_LabelsEntry {
  key: string;
  value: string;
}

/**
 * RoutingVPC contains information about the VPC networks associated
 * with the spokes of a Network Connectivity Center hub.
 */
export interface RoutingVPC {
  /** The URI of the VPC network. */
  uri: string;
  /**
   * Output only. If true, indicates that this VPC network is currently
   * associated with spokes that use the data transfer feature (spokes where the
   * site_to_site_data_transfer field is set to true). If you create new spokes
   * that use data transfer, they must be associated with this VPC network. At
   * most, one VPC network will have this field set to true.
   */
  requiredForNewSiteToSiteDataTransferSpokes: boolean;
}

/**
 * A Network Connectivity Center spoke represents one or more network
 * connectivity resources.
 *
 * When you create a spoke, you associate it with a hub. You must also
 * identify a value for exactly one of the following fields:
 *
 * * linked_vpn_tunnels
 * * linked_interconnect_attachments
 * * linked_router_appliance_instances
 */
export interface Spoke {
  /**
   * Immutable. The name of the spoke. Spoke names must be unique. They use the
   * following form:
   *     `projects/{project_number}/locations/{region}/spokes/{spoke_id}`
   */
  name: string;
  /** Output only. The time the spoke was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time the spoke was last updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional labels in key:value format. For more information about labels, see
   * [Requirements for
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
   */
  labels: { [key: string]: string };
  /** An optional description of the spoke. */
  description: string;
  /** Immutable. The name of the hub that this spoke is attached to. */
  hub: string;
  /** VPN tunnels that are associated with the spoke. */
  linkedVpnTunnels?:
    | LinkedVpnTunnels
    | undefined;
  /** VLAN attachments that are associated with the spoke. */
  linkedInterconnectAttachments?:
    | LinkedInterconnectAttachments
    | undefined;
  /** Router appliance instances that are associated with the spoke. */
  linkedRouterApplianceInstances?:
    | LinkedRouterApplianceInstances
    | undefined;
  /**
   * Output only. The Google-generated UUID for the spoke. This value is unique
   * across all spoke resources. If a spoke is deleted and another with the same
   * name is created, the new spoke is assigned a different unique_id.
   */
  uniqueId: string;
  /** Output only. The current lifecycle state of this spoke. */
  state: State;
}

export interface Spoke_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A collection of Cloud VPN tunnel resources. These resources should be
 * redundant HA VPN tunnels that all advertise the same prefixes to Google
 * Cloud. Alternatively, in a passive/active configuration, all tunnels
 * should be capable of advertising the same prefixes.
 */
export interface LinkedVpnTunnels {
  /** The URIs of linked VPN tunnel resources. */
  uris: string[];
  /**
   * A value that controls whether site-to-site data transfer is enabled for
   * these resources. Data transfer is available only in [supported
   * locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
   */
  siteToSiteDataTransfer: boolean;
  /** Output only. The VPC network where these VPN tunnels are located. */
  vpcNetwork: string;
}

/**
 * A collection of VLAN attachment resources. These resources should
 * be redundant attachments that all advertise the same prefixes to Google
 * Cloud. Alternatively, in active/passive configurations, all attachments
 * should be capable of advertising the same prefixes.
 */
export interface LinkedInterconnectAttachments {
  /** The URIs of linked interconnect attachment resources */
  uris: string[];
  /**
   * A value that controls whether site-to-site data transfer is enabled for
   * these resources. Data transfer is available only in [supported
   * locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
   */
  siteToSiteDataTransfer: boolean;
  /** Output only. The VPC network where these VLAN attachments are located. */
  vpcNetwork: string;
}

/**
 * A collection of router appliance instances. If you configure multiple router
 * appliance instances to receive data from the same set of sites outside of
 * Google Cloud, we recommend that you associate those instances with the same
 * spoke.
 */
export interface LinkedRouterApplianceInstances {
  /** The list of router appliance instances. */
  instances: RouterApplianceInstance[];
  /**
   * A value that controls whether site-to-site data transfer is enabled for
   * these resources. Data transfer is available only in [supported
   * locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
   */
  siteToSiteDataTransfer: boolean;
  /**
   * Output only. The VPC network where these router appliance instances are
   * located.
   */
  vpcNetwork: string;
}

/**
 * A router appliance instance is a Compute Engine virtual machine (VM) instance
 * that acts as a BGP speaker. A router appliance instance is specified by the
 * URI of the VM and the internal IP address of one of the VM's network
 * interfaces.
 */
export interface RouterApplianceInstance {
  /** The URI of the VM. */
  virtualMachine: string;
  /** The IP address on the VM to use for peering. */
  ipAddress: string;
}

/** The data within all ServiceClass events. */
export interface ServiceClassEventData {
  /** Optional. The ServiceClass event payload. Unset for deletion events. */
  payload?: ServiceClass | undefined;
}

/** The data within all ServiceConnectionToken events. */
export interface ServiceConnectionTokenEventData {
  /**
   * Optional. The ServiceConnectionToken event payload. Unset for deletion
   * events.
   */
  payload?: ServiceConnectionToken | undefined;
}

/** The data within all ServiceConnectionMap events. */
export interface ServiceConnectionMapEventData {
  /**
   * Optional. The ServiceConnectionMap event payload. Unset for deletion
   * events.
   */
  payload?: ServiceConnectionMap | undefined;
}

/** The data within all Hub events. */
export interface HubEventData {
  /** Optional. The Hub event payload. Unset for deletion events. */
  payload?: Hub | undefined;
}

/** The data within all Spoke events. */
export interface SpokeEventData {
  /** Optional. The Spoke event payload. Unset for deletion events. */
  payload?: Spoke | undefined;
}

/** The data within all ServiceConnectionPolicy events. */
export interface ServiceConnectionPolicyEventData {
  /**
   * Optional. The ServiceConnectionPolicy event payload. Unset for deletion
   * events.
   */
  payload?: ServiceConnectionPolicy | undefined;
}

function createBaseServiceConnectionMap(): ServiceConnectionMap {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    serviceClass: "",
    serviceClassUri: "",
    infrastructure: 0,
    producerPscConfigs: [],
    consumerPscConfigs: [],
    consumerPscConnections: [],
  };
}

export const ServiceConnectionMap: MessageFns<ServiceConnectionMap> = {
  encode(message: ServiceConnectionMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ServiceConnectionMap_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.serviceClass !== "") {
      writer.uint32(58).string(message.serviceClass);
    }
    if (message.serviceClassUri !== "") {
      writer.uint32(98).string(message.serviceClassUri);
    }
    if (message.infrastructure !== 0) {
      writer.uint32(64).int32(message.infrastructure);
    }
    for (const v of message.producerPscConfigs) {
      ServiceConnectionMap_ProducerPscConfig.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.consumerPscConfigs) {
      ServiceConnectionMap_ConsumerPscConfig.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.consumerPscConnections) {
      ServiceConnectionMap_ConsumerPscConnection.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ServiceConnectionMap_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.serviceClass = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.serviceClassUri = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.infrastructure = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.producerPscConfigs.push(ServiceConnectionMap_ProducerPscConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.consumerPscConfigs.push(ServiceConnectionMap_ConsumerPscConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.consumerPscConnections.push(
            ServiceConnectionMap_ConsumerPscConnection.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionMap {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      serviceClass: isSet(object.serviceClass) ? globalThis.String(object.serviceClass) : "",
      serviceClassUri: isSet(object.serviceClassUri) ? globalThis.String(object.serviceClassUri) : "",
      infrastructure: isSet(object.infrastructure) ? infrastructureFromJSON(object.infrastructure) : 0,
      producerPscConfigs: globalThis.Array.isArray(object?.producerPscConfigs)
        ? object.producerPscConfigs.map((e: any) => ServiceConnectionMap_ProducerPscConfig.fromJSON(e))
        : [],
      consumerPscConfigs: globalThis.Array.isArray(object?.consumerPscConfigs)
        ? object.consumerPscConfigs.map((e: any) => ServiceConnectionMap_ConsumerPscConfig.fromJSON(e))
        : [],
      consumerPscConnections: globalThis.Array.isArray(object?.consumerPscConnections)
        ? object.consumerPscConnections.map((e: any) => ServiceConnectionMap_ConsumerPscConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServiceConnectionMap): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.serviceClass !== "") {
      obj.serviceClass = message.serviceClass;
    }
    if (message.serviceClassUri !== "") {
      obj.serviceClassUri = message.serviceClassUri;
    }
    if (message.infrastructure !== 0) {
      obj.infrastructure = infrastructureToJSON(message.infrastructure);
    }
    if (message.producerPscConfigs?.length) {
      obj.producerPscConfigs = message.producerPscConfigs.map((e) => ServiceConnectionMap_ProducerPscConfig.toJSON(e));
    }
    if (message.consumerPscConfigs?.length) {
      obj.consumerPscConfigs = message.consumerPscConfigs.map((e) => ServiceConnectionMap_ConsumerPscConfig.toJSON(e));
    }
    if (message.consumerPscConnections?.length) {
      obj.consumerPscConnections = message.consumerPscConnections.map((e) =>
        ServiceConnectionMap_ConsumerPscConnection.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionMap>, I>>(base?: I): ServiceConnectionMap {
    return ServiceConnectionMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionMap>, I>>(object: I): ServiceConnectionMap {
    const message = createBaseServiceConnectionMap();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.serviceClass = object.serviceClass ?? "";
    message.serviceClassUri = object.serviceClassUri ?? "";
    message.infrastructure = object.infrastructure ?? 0;
    message.producerPscConfigs =
      object.producerPscConfigs?.map((e) => ServiceConnectionMap_ProducerPscConfig.fromPartial(e)) || [];
    message.consumerPscConfigs =
      object.consumerPscConfigs?.map((e) => ServiceConnectionMap_ConsumerPscConfig.fromPartial(e)) || [];
    message.consumerPscConnections =
      object.consumerPscConnections?.map((e) => ServiceConnectionMap_ConsumerPscConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServiceConnectionMap_ProducerPscConfig(): ServiceConnectionMap_ProducerPscConfig {
  return { serviceAttachmentUri: "" };
}

export const ServiceConnectionMap_ProducerPscConfig: MessageFns<ServiceConnectionMap_ProducerPscConfig> = {
  encode(message: ServiceConnectionMap_ProducerPscConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAttachmentUri !== "") {
      writer.uint32(10).string(message.serviceAttachmentUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionMap_ProducerPscConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionMap_ProducerPscConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceAttachmentUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionMap_ProducerPscConfig {
    return {
      serviceAttachmentUri: isSet(object.serviceAttachmentUri) ? globalThis.String(object.serviceAttachmentUri) : "",
    };
  },

  toJSON(message: ServiceConnectionMap_ProducerPscConfig): unknown {
    const obj: any = {};
    if (message.serviceAttachmentUri !== "") {
      obj.serviceAttachmentUri = message.serviceAttachmentUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionMap_ProducerPscConfig>, I>>(
    base?: I,
  ): ServiceConnectionMap_ProducerPscConfig {
    return ServiceConnectionMap_ProducerPscConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionMap_ProducerPscConfig>, I>>(
    object: I,
  ): ServiceConnectionMap_ProducerPscConfig {
    const message = createBaseServiceConnectionMap_ProducerPscConfig();
    message.serviceAttachmentUri = object.serviceAttachmentUri ?? "";
    return message;
  },
};

function createBaseServiceConnectionMap_ConsumerPscConfig(): ServiceConnectionMap_ConsumerPscConfig {
  return { project: "", network: "", disableGlobalAccess: false, state: 0 };
}

export const ServiceConnectionMap_ConsumerPscConfig: MessageFns<ServiceConnectionMap_ConsumerPscConfig> = {
  encode(message: ServiceConnectionMap_ConsumerPscConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    if (message.disableGlobalAccess !== false) {
      writer.uint32(24).bool(message.disableGlobalAccess);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionMap_ConsumerPscConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionMap_ConsumerPscConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disableGlobalAccess = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionMap_ConsumerPscConfig {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      disableGlobalAccess: isSet(object.disableGlobalAccess) ? globalThis.Boolean(object.disableGlobalAccess) : false,
      state: isSet(object.state) ? serviceConnectionMap_ConsumerPscConfig_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: ServiceConnectionMap_ConsumerPscConfig): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.disableGlobalAccess !== false) {
      obj.disableGlobalAccess = message.disableGlobalAccess;
    }
    if (message.state !== 0) {
      obj.state = serviceConnectionMap_ConsumerPscConfig_StateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionMap_ConsumerPscConfig>, I>>(
    base?: I,
  ): ServiceConnectionMap_ConsumerPscConfig {
    return ServiceConnectionMap_ConsumerPscConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionMap_ConsumerPscConfig>, I>>(
    object: I,
  ): ServiceConnectionMap_ConsumerPscConfig {
    const message = createBaseServiceConnectionMap_ConsumerPscConfig();
    message.project = object.project ?? "";
    message.network = object.network ?? "";
    message.disableGlobalAccess = object.disableGlobalAccess ?? false;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseServiceConnectionMap_ConsumerPscConnection(): ServiceConnectionMap_ConsumerPscConnection {
  return {
    serviceAttachmentUri: "",
    state: 0,
    project: "",
    network: "",
    pscConnectionId: "",
    ip: "",
    errorType: 0,
    error: undefined,
    gceOperation: "",
    forwardingRule: "",
  };
}

export const ServiceConnectionMap_ConsumerPscConnection: MessageFns<ServiceConnectionMap_ConsumerPscConnection> = {
  encode(message: ServiceConnectionMap_ConsumerPscConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAttachmentUri !== "") {
      writer.uint32(10).string(message.serviceAttachmentUri);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.project !== "") {
      writer.uint32(26).string(message.project);
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    if (message.pscConnectionId !== "") {
      writer.uint32(42).string(message.pscConnectionId);
    }
    if (message.ip !== "") {
      writer.uint32(50).string(message.ip);
    }
    if (message.errorType !== 0) {
      writer.uint32(56).int32(message.errorType);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(66).fork()).join();
    }
    if (message.gceOperation !== "") {
      writer.uint32(74).string(message.gceOperation);
    }
    if (message.forwardingRule !== "") {
      writer.uint32(82).string(message.forwardingRule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionMap_ConsumerPscConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionMap_ConsumerPscConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceAttachmentUri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pscConnectionId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.errorType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gceOperation = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.forwardingRule = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionMap_ConsumerPscConnection {
    return {
      serviceAttachmentUri: isSet(object.serviceAttachmentUri) ? globalThis.String(object.serviceAttachmentUri) : "",
      state: isSet(object.state) ? serviceConnectionMap_ConsumerPscConnection_StateFromJSON(object.state) : 0,
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      pscConnectionId: isSet(object.pscConnectionId) ? globalThis.String(object.pscConnectionId) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      errorType: isSet(object.errorType) ? connectionErrorTypeFromJSON(object.errorType) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      gceOperation: isSet(object.gceOperation) ? globalThis.String(object.gceOperation) : "",
      forwardingRule: isSet(object.forwardingRule) ? globalThis.String(object.forwardingRule) : "",
    };
  },

  toJSON(message: ServiceConnectionMap_ConsumerPscConnection): unknown {
    const obj: any = {};
    if (message.serviceAttachmentUri !== "") {
      obj.serviceAttachmentUri = message.serviceAttachmentUri;
    }
    if (message.state !== 0) {
      obj.state = serviceConnectionMap_ConsumerPscConnection_StateToJSON(message.state);
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.pscConnectionId !== "") {
      obj.pscConnectionId = message.pscConnectionId;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.errorType !== 0) {
      obj.errorType = connectionErrorTypeToJSON(message.errorType);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.gceOperation !== "") {
      obj.gceOperation = message.gceOperation;
    }
    if (message.forwardingRule !== "") {
      obj.forwardingRule = message.forwardingRule;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionMap_ConsumerPscConnection>, I>>(
    base?: I,
  ): ServiceConnectionMap_ConsumerPscConnection {
    return ServiceConnectionMap_ConsumerPscConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionMap_ConsumerPscConnection>, I>>(
    object: I,
  ): ServiceConnectionMap_ConsumerPscConnection {
    const message = createBaseServiceConnectionMap_ConsumerPscConnection();
    message.serviceAttachmentUri = object.serviceAttachmentUri ?? "";
    message.state = object.state ?? 0;
    message.project = object.project ?? "";
    message.network = object.network ?? "";
    message.pscConnectionId = object.pscConnectionId ?? "";
    message.ip = object.ip ?? "";
    message.errorType = object.errorType ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.gceOperation = object.gceOperation ?? "";
    message.forwardingRule = object.forwardingRule ?? "";
    return message;
  },
};

function createBaseServiceConnectionMap_LabelsEntry(): ServiceConnectionMap_LabelsEntry {
  return { key: "", value: "" };
}

export const ServiceConnectionMap_LabelsEntry: MessageFns<ServiceConnectionMap_LabelsEntry> = {
  encode(message: ServiceConnectionMap_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionMap_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionMap_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionMap_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ServiceConnectionMap_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionMap_LabelsEntry>, I>>(
    base?: I,
  ): ServiceConnectionMap_LabelsEntry {
    return ServiceConnectionMap_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionMap_LabelsEntry>, I>>(
    object: I,
  ): ServiceConnectionMap_LabelsEntry {
    const message = createBaseServiceConnectionMap_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServiceConnectionPolicy(): ServiceConnectionPolicy {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    network: "",
    serviceClass: "",
    infrastructure: 0,
    pscConfig: undefined,
    pscConnections: [],
  };
}

export const ServiceConnectionPolicy: MessageFns<ServiceConnectionPolicy> = {
  encode(message: ServiceConnectionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ServiceConnectionPolicy_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.network !== "") {
      writer.uint32(50).string(message.network);
    }
    if (message.serviceClass !== "") {
      writer.uint32(58).string(message.serviceClass);
    }
    if (message.infrastructure !== 0) {
      writer.uint32(64).int32(message.infrastructure);
    }
    if (message.pscConfig !== undefined) {
      ServiceConnectionPolicy_PscConfig.encode(message.pscConfig, writer.uint32(74).fork()).join();
    }
    for (const v of message.pscConnections) {
      ServiceConnectionPolicy_PscConnection.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ServiceConnectionPolicy_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.serviceClass = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.infrastructure = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pscConfig = ServiceConnectionPolicy_PscConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pscConnections.push(ServiceConnectionPolicy_PscConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionPolicy {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      serviceClass: isSet(object.serviceClass) ? globalThis.String(object.serviceClass) : "",
      infrastructure: isSet(object.infrastructure) ? infrastructureFromJSON(object.infrastructure) : 0,
      pscConfig: isSet(object.pscConfig) ? ServiceConnectionPolicy_PscConfig.fromJSON(object.pscConfig) : undefined,
      pscConnections: globalThis.Array.isArray(object?.pscConnections)
        ? object.pscConnections.map((e: any) => ServiceConnectionPolicy_PscConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServiceConnectionPolicy): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.serviceClass !== "") {
      obj.serviceClass = message.serviceClass;
    }
    if (message.infrastructure !== 0) {
      obj.infrastructure = infrastructureToJSON(message.infrastructure);
    }
    if (message.pscConfig !== undefined) {
      obj.pscConfig = ServiceConnectionPolicy_PscConfig.toJSON(message.pscConfig);
    }
    if (message.pscConnections?.length) {
      obj.pscConnections = message.pscConnections.map((e) => ServiceConnectionPolicy_PscConnection.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionPolicy>, I>>(base?: I): ServiceConnectionPolicy {
    return ServiceConnectionPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionPolicy>, I>>(object: I): ServiceConnectionPolicy {
    const message = createBaseServiceConnectionPolicy();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.network = object.network ?? "";
    message.serviceClass = object.serviceClass ?? "";
    message.infrastructure = object.infrastructure ?? 0;
    message.pscConfig = (object.pscConfig !== undefined && object.pscConfig !== null)
      ? ServiceConnectionPolicy_PscConfig.fromPartial(object.pscConfig)
      : undefined;
    message.pscConnections = object.pscConnections?.map((e) => ServiceConnectionPolicy_PscConnection.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseServiceConnectionPolicy_PscConfig(): ServiceConnectionPolicy_PscConfig {
  return { subnetworks: [], limit: undefined };
}

export const ServiceConnectionPolicy_PscConfig: MessageFns<ServiceConnectionPolicy_PscConfig> = {
  encode(message: ServiceConnectionPolicy_PscConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subnetworks) {
      writer.uint32(10).string(v!);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int64(message.limit.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionPolicy_PscConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionPolicy_PscConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subnetworks.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionPolicy_PscConfig {
    return {
      subnetworks: globalThis.Array.isArray(object?.subnetworks)
        ? object.subnetworks.map((e: any) => globalThis.String(e))
        : [],
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : undefined,
    };
  },

  toJSON(message: ServiceConnectionPolicy_PscConfig): unknown {
    const obj: any = {};
    if (message.subnetworks?.length) {
      obj.subnetworks = message.subnetworks;
    }
    if (message.limit !== undefined) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionPolicy_PscConfig>, I>>(
    base?: I,
  ): ServiceConnectionPolicy_PscConfig {
    return ServiceConnectionPolicy_PscConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionPolicy_PscConfig>, I>>(
    object: I,
  ): ServiceConnectionPolicy_PscConfig {
    const message = createBaseServiceConnectionPolicy_PscConfig();
    message.subnetworks = object.subnetworks?.map((e) => e) || [];
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : undefined;
    return message;
  },
};

function createBaseServiceConnectionPolicy_PscConnection(): ServiceConnectionPolicy_PscConnection {
  return {
    state: 0,
    consumerForwardingRule: "",
    consumerAddress: "",
    errorType: 0,
    error: undefined,
    gceOperation: "",
    consumerTargetProject: "",
    pscConnectionId: "",
  };
}

export const ServiceConnectionPolicy_PscConnection: MessageFns<ServiceConnectionPolicy_PscConnection> = {
  encode(message: ServiceConnectionPolicy_PscConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.consumerForwardingRule !== "") {
      writer.uint32(18).string(message.consumerForwardingRule);
    }
    if (message.consumerAddress !== "") {
      writer.uint32(26).string(message.consumerAddress);
    }
    if (message.errorType !== 0) {
      writer.uint32(32).int32(message.errorType);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    if (message.gceOperation !== "") {
      writer.uint32(50).string(message.gceOperation);
    }
    if (message.consumerTargetProject !== "") {
      writer.uint32(58).string(message.consumerTargetProject);
    }
    if (message.pscConnectionId !== "") {
      writer.uint32(66).string(message.pscConnectionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionPolicy_PscConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionPolicy_PscConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumerForwardingRule = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.consumerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gceOperation = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.consumerTargetProject = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pscConnectionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionPolicy_PscConnection {
    return {
      state: isSet(object.state) ? serviceConnectionPolicy_StateFromJSON(object.state) : 0,
      consumerForwardingRule: isSet(object.consumerForwardingRule)
        ? globalThis.String(object.consumerForwardingRule)
        : "",
      consumerAddress: isSet(object.consumerAddress) ? globalThis.String(object.consumerAddress) : "",
      errorType: isSet(object.errorType) ? connectionErrorTypeFromJSON(object.errorType) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      gceOperation: isSet(object.gceOperation) ? globalThis.String(object.gceOperation) : "",
      consumerTargetProject: isSet(object.consumerTargetProject) ? globalThis.String(object.consumerTargetProject) : "",
      pscConnectionId: isSet(object.pscConnectionId) ? globalThis.String(object.pscConnectionId) : "",
    };
  },

  toJSON(message: ServiceConnectionPolicy_PscConnection): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = serviceConnectionPolicy_StateToJSON(message.state);
    }
    if (message.consumerForwardingRule !== "") {
      obj.consumerForwardingRule = message.consumerForwardingRule;
    }
    if (message.consumerAddress !== "") {
      obj.consumerAddress = message.consumerAddress;
    }
    if (message.errorType !== 0) {
      obj.errorType = connectionErrorTypeToJSON(message.errorType);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.gceOperation !== "") {
      obj.gceOperation = message.gceOperation;
    }
    if (message.consumerTargetProject !== "") {
      obj.consumerTargetProject = message.consumerTargetProject;
    }
    if (message.pscConnectionId !== "") {
      obj.pscConnectionId = message.pscConnectionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionPolicy_PscConnection>, I>>(
    base?: I,
  ): ServiceConnectionPolicy_PscConnection {
    return ServiceConnectionPolicy_PscConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionPolicy_PscConnection>, I>>(
    object: I,
  ): ServiceConnectionPolicy_PscConnection {
    const message = createBaseServiceConnectionPolicy_PscConnection();
    message.state = object.state ?? 0;
    message.consumerForwardingRule = object.consumerForwardingRule ?? "";
    message.consumerAddress = object.consumerAddress ?? "";
    message.errorType = object.errorType ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.gceOperation = object.gceOperation ?? "";
    message.consumerTargetProject = object.consumerTargetProject ?? "";
    message.pscConnectionId = object.pscConnectionId ?? "";
    return message;
  },
};

function createBaseServiceConnectionPolicy_LabelsEntry(): ServiceConnectionPolicy_LabelsEntry {
  return { key: "", value: "" };
}

export const ServiceConnectionPolicy_LabelsEntry: MessageFns<ServiceConnectionPolicy_LabelsEntry> = {
  encode(message: ServiceConnectionPolicy_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionPolicy_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionPolicy_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionPolicy_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ServiceConnectionPolicy_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionPolicy_LabelsEntry>, I>>(
    base?: I,
  ): ServiceConnectionPolicy_LabelsEntry {
    return ServiceConnectionPolicy_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionPolicy_LabelsEntry>, I>>(
    object: I,
  ): ServiceConnectionPolicy_LabelsEntry {
    const message = createBaseServiceConnectionPolicy_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServiceClass(): ServiceClass {
  return {
    name: "",
    serviceClass: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    serviceConnectionMaps: [],
  };
}

export const ServiceClass: MessageFns<ServiceClass> = {
  encode(message: ServiceClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.serviceClass !== "") {
      writer.uint32(58).string(message.serviceClass);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ServiceClass_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.serviceConnectionMaps) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.serviceClass = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ServiceClass_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.serviceConnectionMaps.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceClass {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      serviceClass: isSet(object.serviceClass) ? globalThis.String(object.serviceClass) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      serviceConnectionMaps: globalThis.Array.isArray(object?.serviceConnectionMaps)
        ? object.serviceConnectionMaps.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServiceClass): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.serviceClass !== "") {
      obj.serviceClass = message.serviceClass;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.serviceConnectionMaps?.length) {
      obj.serviceConnectionMaps = message.serviceConnectionMaps;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceClass>, I>>(base?: I): ServiceClass {
    return ServiceClass.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceClass>, I>>(object: I): ServiceClass {
    const message = createBaseServiceClass();
    message.name = object.name ?? "";
    message.serviceClass = object.serviceClass ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.serviceConnectionMaps = object.serviceConnectionMaps?.map((e) => e) || [];
    return message;
  },
};

function createBaseServiceClass_LabelsEntry(): ServiceClass_LabelsEntry {
  return { key: "", value: "" };
}

export const ServiceClass_LabelsEntry: MessageFns<ServiceClass_LabelsEntry> = {
  encode(message: ServiceClass_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceClass_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceClass_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceClass_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ServiceClass_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceClass_LabelsEntry>, I>>(base?: I): ServiceClass_LabelsEntry {
    return ServiceClass_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceClass_LabelsEntry>, I>>(object: I): ServiceClass_LabelsEntry {
    const message = createBaseServiceClass_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServiceConnectionToken(): ServiceConnectionToken {
  return { name: "", createTime: undefined, updateTime: undefined, labels: {}, description: "", network: "" };
}

export const ServiceConnectionToken: MessageFns<ServiceConnectionToken> = {
  encode(message: ServiceConnectionToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ServiceConnectionToken_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.network !== "") {
      writer.uint32(50).string(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ServiceConnectionToken_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.network = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionToken {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: ServiceConnectionToken): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionToken>, I>>(base?: I): ServiceConnectionToken {
    return ServiceConnectionToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionToken>, I>>(object: I): ServiceConnectionToken {
    const message = createBaseServiceConnectionToken();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseServiceConnectionToken_LabelsEntry(): ServiceConnectionToken_LabelsEntry {
  return { key: "", value: "" };
}

export const ServiceConnectionToken_LabelsEntry: MessageFns<ServiceConnectionToken_LabelsEntry> = {
  encode(message: ServiceConnectionToken_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionToken_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionToken_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionToken_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ServiceConnectionToken_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionToken_LabelsEntry>, I>>(
    base?: I,
  ): ServiceConnectionToken_LabelsEntry {
    return ServiceConnectionToken_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionToken_LabelsEntry>, I>>(
    object: I,
  ): ServiceConnectionToken_LabelsEntry {
    const message = createBaseServiceConnectionToken_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHub(): Hub {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    uniqueId: "",
    state: 0,
    routingVpcs: [],
  };
}

export const Hub: MessageFns<Hub> = {
  encode(message: Hub, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Hub_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.uniqueId !== "") {
      writer.uint32(66).string(message.uniqueId);
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    for (const v of message.routingVpcs) {
      RoutingVPC.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hub {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHub();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Hub_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.routingVpcs.push(RoutingVPC.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hub {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      state: isSet(object.state) ? stateFromJSON(object.state) : 0,
      routingVpcs: globalThis.Array.isArray(object?.routingVpcs)
        ? object.routingVpcs.map((e: any) => RoutingVPC.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Hub): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.state !== 0) {
      obj.state = stateToJSON(message.state);
    }
    if (message.routingVpcs?.length) {
      obj.routingVpcs = message.routingVpcs.map((e) => RoutingVPC.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hub>, I>>(base?: I): Hub {
    return Hub.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hub>, I>>(object: I): Hub {
    const message = createBaseHub();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.uniqueId = object.uniqueId ?? "";
    message.state = object.state ?? 0;
    message.routingVpcs = object.routingVpcs?.map((e) => RoutingVPC.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHub_LabelsEntry(): Hub_LabelsEntry {
  return { key: "", value: "" };
}

export const Hub_LabelsEntry: MessageFns<Hub_LabelsEntry> = {
  encode(message: Hub_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hub_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHub_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hub_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Hub_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hub_LabelsEntry>, I>>(base?: I): Hub_LabelsEntry {
    return Hub_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hub_LabelsEntry>, I>>(object: I): Hub_LabelsEntry {
    const message = createBaseHub_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRoutingVPC(): RoutingVPC {
  return { uri: "", requiredForNewSiteToSiteDataTransferSpokes: false };
}

export const RoutingVPC: MessageFns<RoutingVPC> = {
  encode(message: RoutingVPC, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.requiredForNewSiteToSiteDataTransferSpokes !== false) {
      writer.uint32(16).bool(message.requiredForNewSiteToSiteDataTransferSpokes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingVPC {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingVPC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.requiredForNewSiteToSiteDataTransferSpokes = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingVPC {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      requiredForNewSiteToSiteDataTransferSpokes: isSet(object.requiredForNewSiteToSiteDataTransferSpokes)
        ? globalThis.Boolean(object.requiredForNewSiteToSiteDataTransferSpokes)
        : false,
    };
  },

  toJSON(message: RoutingVPC): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.requiredForNewSiteToSiteDataTransferSpokes !== false) {
      obj.requiredForNewSiteToSiteDataTransferSpokes = message.requiredForNewSiteToSiteDataTransferSpokes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingVPC>, I>>(base?: I): RoutingVPC {
    return RoutingVPC.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingVPC>, I>>(object: I): RoutingVPC {
    const message = createBaseRoutingVPC();
    message.uri = object.uri ?? "";
    message.requiredForNewSiteToSiteDataTransferSpokes = object.requiredForNewSiteToSiteDataTransferSpokes ?? false;
    return message;
  },
};

function createBaseSpoke(): Spoke {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    hub: "",
    linkedVpnTunnels: undefined,
    linkedInterconnectAttachments: undefined,
    linkedRouterApplianceInstances: undefined,
    uniqueId: "",
    state: 0,
  };
}

export const Spoke: MessageFns<Spoke> = {
  encode(message: Spoke, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Spoke_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.hub !== "") {
      writer.uint32(50).string(message.hub);
    }
    if (message.linkedVpnTunnels !== undefined) {
      LinkedVpnTunnels.encode(message.linkedVpnTunnels, writer.uint32(138).fork()).join();
    }
    if (message.linkedInterconnectAttachments !== undefined) {
      LinkedInterconnectAttachments.encode(message.linkedInterconnectAttachments, writer.uint32(146).fork()).join();
    }
    if (message.linkedRouterApplianceInstances !== undefined) {
      LinkedRouterApplianceInstances.encode(message.linkedRouterApplianceInstances, writer.uint32(154).fork()).join();
    }
    if (message.uniqueId !== "") {
      writer.uint32(90).string(message.uniqueId);
    }
    if (message.state !== 0) {
      writer.uint32(120).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spoke {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Spoke_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.hub = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.linkedVpnTunnels = LinkedVpnTunnels.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.linkedInterconnectAttachments = LinkedInterconnectAttachments.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.linkedRouterApplianceInstances = LinkedRouterApplianceInstances.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spoke {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      hub: isSet(object.hub) ? globalThis.String(object.hub) : "",
      linkedVpnTunnels: isSet(object.linkedVpnTunnels) ? LinkedVpnTunnels.fromJSON(object.linkedVpnTunnels) : undefined,
      linkedInterconnectAttachments: isSet(object.linkedInterconnectAttachments)
        ? LinkedInterconnectAttachments.fromJSON(object.linkedInterconnectAttachments)
        : undefined,
      linkedRouterApplianceInstances: isSet(object.linkedRouterApplianceInstances)
        ? LinkedRouterApplianceInstances.fromJSON(object.linkedRouterApplianceInstances)
        : undefined,
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      state: isSet(object.state) ? stateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Spoke): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.hub !== "") {
      obj.hub = message.hub;
    }
    if (message.linkedVpnTunnels !== undefined) {
      obj.linkedVpnTunnels = LinkedVpnTunnels.toJSON(message.linkedVpnTunnels);
    }
    if (message.linkedInterconnectAttachments !== undefined) {
      obj.linkedInterconnectAttachments = LinkedInterconnectAttachments.toJSON(message.linkedInterconnectAttachments);
    }
    if (message.linkedRouterApplianceInstances !== undefined) {
      obj.linkedRouterApplianceInstances = LinkedRouterApplianceInstances.toJSON(
        message.linkedRouterApplianceInstances,
      );
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.state !== 0) {
      obj.state = stateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spoke>, I>>(base?: I): Spoke {
    return Spoke.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spoke>, I>>(object: I): Spoke {
    const message = createBaseSpoke();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.hub = object.hub ?? "";
    message.linkedVpnTunnels = (object.linkedVpnTunnels !== undefined && object.linkedVpnTunnels !== null)
      ? LinkedVpnTunnels.fromPartial(object.linkedVpnTunnels)
      : undefined;
    message.linkedInterconnectAttachments =
      (object.linkedInterconnectAttachments !== undefined && object.linkedInterconnectAttachments !== null)
        ? LinkedInterconnectAttachments.fromPartial(object.linkedInterconnectAttachments)
        : undefined;
    message.linkedRouterApplianceInstances =
      (object.linkedRouterApplianceInstances !== undefined && object.linkedRouterApplianceInstances !== null)
        ? LinkedRouterApplianceInstances.fromPartial(object.linkedRouterApplianceInstances)
        : undefined;
    message.uniqueId = object.uniqueId ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseSpoke_LabelsEntry(): Spoke_LabelsEntry {
  return { key: "", value: "" };
}

export const Spoke_LabelsEntry: MessageFns<Spoke_LabelsEntry> = {
  encode(message: Spoke_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spoke_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpoke_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spoke_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Spoke_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spoke_LabelsEntry>, I>>(base?: I): Spoke_LabelsEntry {
    return Spoke_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spoke_LabelsEntry>, I>>(object: I): Spoke_LabelsEntry {
    const message = createBaseSpoke_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLinkedVpnTunnels(): LinkedVpnTunnels {
  return { uris: [], siteToSiteDataTransfer: false, vpcNetwork: "" };
}

export const LinkedVpnTunnels: MessageFns<LinkedVpnTunnels> = {
  encode(message: LinkedVpnTunnels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.uris) {
      writer.uint32(10).string(v!);
    }
    if (message.siteToSiteDataTransfer !== false) {
      writer.uint32(16).bool(message.siteToSiteDataTransfer);
    }
    if (message.vpcNetwork !== "") {
      writer.uint32(26).string(message.vpcNetwork);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkedVpnTunnels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkedVpnTunnels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uris.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.siteToSiteDataTransfer = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vpcNetwork = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkedVpnTunnels {
    return {
      uris: globalThis.Array.isArray(object?.uris) ? object.uris.map((e: any) => globalThis.String(e)) : [],
      siteToSiteDataTransfer: isSet(object.siteToSiteDataTransfer)
        ? globalThis.Boolean(object.siteToSiteDataTransfer)
        : false,
      vpcNetwork: isSet(object.vpcNetwork) ? globalThis.String(object.vpcNetwork) : "",
    };
  },

  toJSON(message: LinkedVpnTunnels): unknown {
    const obj: any = {};
    if (message.uris?.length) {
      obj.uris = message.uris;
    }
    if (message.siteToSiteDataTransfer !== false) {
      obj.siteToSiteDataTransfer = message.siteToSiteDataTransfer;
    }
    if (message.vpcNetwork !== "") {
      obj.vpcNetwork = message.vpcNetwork;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkedVpnTunnels>, I>>(base?: I): LinkedVpnTunnels {
    return LinkedVpnTunnels.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkedVpnTunnels>, I>>(object: I): LinkedVpnTunnels {
    const message = createBaseLinkedVpnTunnels();
    message.uris = object.uris?.map((e) => e) || [];
    message.siteToSiteDataTransfer = object.siteToSiteDataTransfer ?? false;
    message.vpcNetwork = object.vpcNetwork ?? "";
    return message;
  },
};

function createBaseLinkedInterconnectAttachments(): LinkedInterconnectAttachments {
  return { uris: [], siteToSiteDataTransfer: false, vpcNetwork: "" };
}

export const LinkedInterconnectAttachments: MessageFns<LinkedInterconnectAttachments> = {
  encode(message: LinkedInterconnectAttachments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.uris) {
      writer.uint32(10).string(v!);
    }
    if (message.siteToSiteDataTransfer !== false) {
      writer.uint32(16).bool(message.siteToSiteDataTransfer);
    }
    if (message.vpcNetwork !== "") {
      writer.uint32(26).string(message.vpcNetwork);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkedInterconnectAttachments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkedInterconnectAttachments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uris.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.siteToSiteDataTransfer = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vpcNetwork = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkedInterconnectAttachments {
    return {
      uris: globalThis.Array.isArray(object?.uris) ? object.uris.map((e: any) => globalThis.String(e)) : [],
      siteToSiteDataTransfer: isSet(object.siteToSiteDataTransfer)
        ? globalThis.Boolean(object.siteToSiteDataTransfer)
        : false,
      vpcNetwork: isSet(object.vpcNetwork) ? globalThis.String(object.vpcNetwork) : "",
    };
  },

  toJSON(message: LinkedInterconnectAttachments): unknown {
    const obj: any = {};
    if (message.uris?.length) {
      obj.uris = message.uris;
    }
    if (message.siteToSiteDataTransfer !== false) {
      obj.siteToSiteDataTransfer = message.siteToSiteDataTransfer;
    }
    if (message.vpcNetwork !== "") {
      obj.vpcNetwork = message.vpcNetwork;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkedInterconnectAttachments>, I>>(base?: I): LinkedInterconnectAttachments {
    return LinkedInterconnectAttachments.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkedInterconnectAttachments>, I>>(
    object: I,
  ): LinkedInterconnectAttachments {
    const message = createBaseLinkedInterconnectAttachments();
    message.uris = object.uris?.map((e) => e) || [];
    message.siteToSiteDataTransfer = object.siteToSiteDataTransfer ?? false;
    message.vpcNetwork = object.vpcNetwork ?? "";
    return message;
  },
};

function createBaseLinkedRouterApplianceInstances(): LinkedRouterApplianceInstances {
  return { instances: [], siteToSiteDataTransfer: false, vpcNetwork: "" };
}

export const LinkedRouterApplianceInstances: MessageFns<LinkedRouterApplianceInstances> = {
  encode(message: LinkedRouterApplianceInstances, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      RouterApplianceInstance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.siteToSiteDataTransfer !== false) {
      writer.uint32(16).bool(message.siteToSiteDataTransfer);
    }
    if (message.vpcNetwork !== "") {
      writer.uint32(26).string(message.vpcNetwork);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkedRouterApplianceInstances {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkedRouterApplianceInstances();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instances.push(RouterApplianceInstance.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.siteToSiteDataTransfer = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vpcNetwork = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkedRouterApplianceInstances {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => RouterApplianceInstance.fromJSON(e))
        : [],
      siteToSiteDataTransfer: isSet(object.siteToSiteDataTransfer)
        ? globalThis.Boolean(object.siteToSiteDataTransfer)
        : false,
      vpcNetwork: isSet(object.vpcNetwork) ? globalThis.String(object.vpcNetwork) : "",
    };
  },

  toJSON(message: LinkedRouterApplianceInstances): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => RouterApplianceInstance.toJSON(e));
    }
    if (message.siteToSiteDataTransfer !== false) {
      obj.siteToSiteDataTransfer = message.siteToSiteDataTransfer;
    }
    if (message.vpcNetwork !== "") {
      obj.vpcNetwork = message.vpcNetwork;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkedRouterApplianceInstances>, I>>(base?: I): LinkedRouterApplianceInstances {
    return LinkedRouterApplianceInstances.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkedRouterApplianceInstances>, I>>(
    object: I,
  ): LinkedRouterApplianceInstances {
    const message = createBaseLinkedRouterApplianceInstances();
    message.instances = object.instances?.map((e) => RouterApplianceInstance.fromPartial(e)) || [];
    message.siteToSiteDataTransfer = object.siteToSiteDataTransfer ?? false;
    message.vpcNetwork = object.vpcNetwork ?? "";
    return message;
  },
};

function createBaseRouterApplianceInstance(): RouterApplianceInstance {
  return { virtualMachine: "", ipAddress: "" };
}

export const RouterApplianceInstance: MessageFns<RouterApplianceInstance> = {
  encode(message: RouterApplianceInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.virtualMachine !== "") {
      writer.uint32(10).string(message.virtualMachine);
    }
    if (message.ipAddress !== "") {
      writer.uint32(26).string(message.ipAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouterApplianceInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouterApplianceInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.virtualMachine = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouterApplianceInstance {
    return {
      virtualMachine: isSet(object.virtualMachine) ? globalThis.String(object.virtualMachine) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
    };
  },

  toJSON(message: RouterApplianceInstance): unknown {
    const obj: any = {};
    if (message.virtualMachine !== "") {
      obj.virtualMachine = message.virtualMachine;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouterApplianceInstance>, I>>(base?: I): RouterApplianceInstance {
    return RouterApplianceInstance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouterApplianceInstance>, I>>(object: I): RouterApplianceInstance {
    const message = createBaseRouterApplianceInstance();
    message.virtualMachine = object.virtualMachine ?? "";
    message.ipAddress = object.ipAddress ?? "";
    return message;
  },
};

function createBaseServiceClassEventData(): ServiceClassEventData {
  return { payload: undefined };
}

export const ServiceClassEventData: MessageFns<ServiceClassEventData> = {
  encode(message: ServiceClassEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ServiceClass.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceClassEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceClassEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ServiceClass.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceClassEventData {
    return { payload: isSet(object.payload) ? ServiceClass.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ServiceClassEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ServiceClass.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceClassEventData>, I>>(base?: I): ServiceClassEventData {
    return ServiceClassEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceClassEventData>, I>>(object: I): ServiceClassEventData {
    const message = createBaseServiceClassEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ServiceClass.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseServiceConnectionTokenEventData(): ServiceConnectionTokenEventData {
  return { payload: undefined };
}

export const ServiceConnectionTokenEventData: MessageFns<ServiceConnectionTokenEventData> = {
  encode(message: ServiceConnectionTokenEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ServiceConnectionToken.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionTokenEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionTokenEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ServiceConnectionToken.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionTokenEventData {
    return { payload: isSet(object.payload) ? ServiceConnectionToken.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ServiceConnectionTokenEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ServiceConnectionToken.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionTokenEventData>, I>>(base?: I): ServiceConnectionTokenEventData {
    return ServiceConnectionTokenEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionTokenEventData>, I>>(
    object: I,
  ): ServiceConnectionTokenEventData {
    const message = createBaseServiceConnectionTokenEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ServiceConnectionToken.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseServiceConnectionMapEventData(): ServiceConnectionMapEventData {
  return { payload: undefined };
}

export const ServiceConnectionMapEventData: MessageFns<ServiceConnectionMapEventData> = {
  encode(message: ServiceConnectionMapEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ServiceConnectionMap.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionMapEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionMapEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ServiceConnectionMap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionMapEventData {
    return { payload: isSet(object.payload) ? ServiceConnectionMap.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ServiceConnectionMapEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ServiceConnectionMap.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionMapEventData>, I>>(base?: I): ServiceConnectionMapEventData {
    return ServiceConnectionMapEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionMapEventData>, I>>(
    object: I,
  ): ServiceConnectionMapEventData {
    const message = createBaseServiceConnectionMapEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ServiceConnectionMap.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseHubEventData(): HubEventData {
  return { payload: undefined };
}

export const HubEventData: MessageFns<HubEventData> = {
  encode(message: HubEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Hub.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HubEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHubEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Hub.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HubEventData {
    return { payload: isSet(object.payload) ? Hub.fromJSON(object.payload) : undefined };
  },

  toJSON(message: HubEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Hub.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HubEventData>, I>>(base?: I): HubEventData {
    return HubEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HubEventData>, I>>(object: I): HubEventData {
    const message = createBaseHubEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Hub.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseSpokeEventData(): SpokeEventData {
  return { payload: undefined };
}

export const SpokeEventData: MessageFns<SpokeEventData> = {
  encode(message: SpokeEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Spoke.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpokeEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpokeEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Spoke.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpokeEventData {
    return { payload: isSet(object.payload) ? Spoke.fromJSON(object.payload) : undefined };
  },

  toJSON(message: SpokeEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Spoke.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpokeEventData>, I>>(base?: I): SpokeEventData {
    return SpokeEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpokeEventData>, I>>(object: I): SpokeEventData {
    const message = createBaseSpokeEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Spoke.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseServiceConnectionPolicyEventData(): ServiceConnectionPolicyEventData {
  return { payload: undefined };
}

export const ServiceConnectionPolicyEventData: MessageFns<ServiceConnectionPolicyEventData> = {
  encode(message: ServiceConnectionPolicyEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ServiceConnectionPolicy.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceConnectionPolicyEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceConnectionPolicyEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ServiceConnectionPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceConnectionPolicyEventData {
    return { payload: isSet(object.payload) ? ServiceConnectionPolicy.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ServiceConnectionPolicyEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ServiceConnectionPolicy.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceConnectionPolicyEventData>, I>>(
    base?: I,
  ): ServiceConnectionPolicyEventData {
    return ServiceConnectionPolicyEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceConnectionPolicyEventData>, I>>(
    object: I,
  ): ServiceConnectionPolicyEventData {
    const message = createBaseServiceConnectionPolicyEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ServiceConnectionPolicy.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
