// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/networkmanagement/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";
import { Status } from "../../../../rpc/status";

export const protobufPackage = "google.events.cloud.networkmanagement.v1";

/**
 * Trace represents one simulated packet forwarding path.
 *
 *   * Each trace contains multiple ordered steps.
 *   * Each step is in a particular state with associated configuration.
 *   * State is categorized as final or non-final states.
 *   * Each final state has a reason associated.
 *   * Each trace must end with a final state (the last step).
 * ```
 *   |---------------------Trace----------------------|
 *   Step1(State) Step2(State) ---  StepN(State(final))
 * ```
 */
export interface Trace {
  /**
   * Derived from the source and destination endpoints definition specified by
   * user request, and validated by the data plane model.
   * If there are multiple traces starting from different source locations, then
   * the endpoint_info may be different between traces.
   */
  endpointInfo?:
    | EndpointInfo
    | undefined;
  /**
   * A trace of a test contains multiple steps from the initial state to the
   * final state (delivered, dropped, forwarded, or aborted).
   *
   * The steps are ordered by the processing sequence within the simulated
   * network state machine. It is critical to preserve the order of the steps
   * and avoid reordering or sorting them.
   */
  steps: Step[];
}

/**
 * A simulated forwarding path is composed of multiple steps.
 * Each step has a well-defined state and an associated configuration.
 */
export interface Step {
  /** A description of the step. Usually this is a summary of the state. */
  description: string;
  /** Each step is in one of the pre-defined states. */
  state: Step_State;
  /** This is a step that leads to the final state Drop. */
  causesDrop: boolean;
  /** Project ID that contains the configuration this step is validating. */
  projectId: string;
  /** Display information of a Compute Engine instance. */
  instance?:
    | InstanceInfo
    | undefined;
  /** Display information of a Compute Engine firewall rule. */
  firewall?:
    | FirewallInfo
    | undefined;
  /** Display information of a Compute Engine route. */
  route?:
    | RouteInfo
    | undefined;
  /**
   * Display information of the source and destination under analysis.
   * The endpoint information in an intermediate state may differ with the
   * initial input, as it might be modified by state like NAT,
   * or Connection Proxy.
   */
  endpoint?:
    | EndpointInfo
    | undefined;
  /** Display information of a Google service */
  googleService?:
    | GoogleServiceInfo
    | undefined;
  /** Display information of a Compute Engine forwarding rule. */
  forwardingRule?:
    | ForwardingRuleInfo
    | undefined;
  /** Display information of a Compute Engine VPN gateway. */
  vpnGateway?:
    | VpnGatewayInfo
    | undefined;
  /** Display information of a Compute Engine VPN tunnel. */
  vpnTunnel?:
    | VpnTunnelInfo
    | undefined;
  /** Display information of a VPC connector. */
  vpcConnector?:
    | VpcConnectorInfo
    | undefined;
  /** Display information of the final state "deliver" and reason. */
  deliver?:
    | DeliverInfo
    | undefined;
  /** Display information of the final state "forward" and reason. */
  forward?:
    | ForwardInfo
    | undefined;
  /** Display information of the final state "abort" and reason. */
  abort?:
    | AbortInfo
    | undefined;
  /** Display information of the final state "drop" and reason. */
  drop?:
    | DropInfo
    | undefined;
  /** Display information of the load balancers. */
  loadBalancer?:
    | LoadBalancerInfo
    | undefined;
  /** Display information of a Google Cloud network. */
  network?:
    | NetworkInfo
    | undefined;
  /** Display information of a Google Kubernetes Engine cluster master. */
  gkeMaster?:
    | GKEMasterInfo
    | undefined;
  /** Display information of a Cloud SQL instance. */
  cloudSqlInstance?:
    | CloudSQLInstanceInfo
    | undefined;
  /** Display information of a Cloud Function. */
  cloudFunction?:
    | CloudFunctionInfo
    | undefined;
  /** Display information of an App Engine service version. */
  appEngineVersion?:
    | AppEngineVersionInfo
    | undefined;
  /** Display information of a Cloud Run revision. */
  cloudRunRevision?: CloudRunRevisionInfo | undefined;
}

/**
 * Type of states that are defined in the network state machine.
 * Each step in the packet trace is in a specific state.
 */
export enum Step_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /**
   * START_FROM_INSTANCE - Initial state: packet originating from a Compute Engine instance.
   * An InstanceInfo is populated with starting instance information.
   */
  START_FROM_INSTANCE = 1,
  /**
   * START_FROM_INTERNET - Initial state: packet originating from the internet.
   * The endpoint information is populated.
   */
  START_FROM_INTERNET = 2,
  /**
   * START_FROM_GOOGLE_SERVICE - Initial state: packet originating from a Google service. Some Google
   * services, such as health check probers or Identity Aware Proxy use
   * special routes, outside VPC routing configuration to reach Compute Engine
   * Instances.
   */
  START_FROM_GOOGLE_SERVICE = 27,
  /**
   * START_FROM_PRIVATE_NETWORK - Initial state: packet originating from a VPC or on-premises network
   * with internal source IP.
   * If the source is a VPC network visible to the user, a NetworkInfo
   * is populated with details of the network.
   */
  START_FROM_PRIVATE_NETWORK = 3,
  /**
   * START_FROM_GKE_MASTER - Initial state: packet originating from a Google Kubernetes Engine cluster
   * master. A GKEMasterInfo is populated with starting instance information.
   */
  START_FROM_GKE_MASTER = 21,
  /**
   * START_FROM_CLOUD_SQL_INSTANCE - Initial state: packet originating from a Cloud SQL instance.
   * A CloudSQLInstanceInfo is populated with starting instance information.
   */
  START_FROM_CLOUD_SQL_INSTANCE = 22,
  /**
   * START_FROM_CLOUD_FUNCTION - Initial state: packet originating from a Cloud Function.
   * A CloudFunctionInfo is populated with starting function information.
   */
  START_FROM_CLOUD_FUNCTION = 23,
  /**
   * START_FROM_APP_ENGINE_VERSION - Initial state: packet originating from an App Engine service version.
   * An AppEngineVersionInfo is populated with starting version information.
   */
  START_FROM_APP_ENGINE_VERSION = 25,
  /**
   * START_FROM_CLOUD_RUN_REVISION - Initial state: packet originating from a Cloud Run revision.
   * A CloudRunRevisionInfo is populated with starting revision information.
   */
  START_FROM_CLOUD_RUN_REVISION = 26,
  /** APPLY_INGRESS_FIREWALL_RULE - Config checking state: verify ingress firewall rule. */
  APPLY_INGRESS_FIREWALL_RULE = 4,
  /** APPLY_EGRESS_FIREWALL_RULE - Config checking state: verify egress firewall rule. */
  APPLY_EGRESS_FIREWALL_RULE = 5,
  /** APPLY_ROUTE - Config checking state: verify route. */
  APPLY_ROUTE = 6,
  /** APPLY_FORWARDING_RULE - Config checking state: match forwarding rule. */
  APPLY_FORWARDING_RULE = 7,
  /**
   * SPOOFING_APPROVED - Config checking state: packet sent or received under foreign IP
   * address and allowed.
   */
  SPOOFING_APPROVED = 8,
  /** ARRIVE_AT_INSTANCE - Forwarding state: arriving at a Compute Engine instance. */
  ARRIVE_AT_INSTANCE = 9,
  /** ARRIVE_AT_INTERNAL_LOAD_BALANCER - Forwarding state: arriving at a Compute Engine internal load balancer. */
  ARRIVE_AT_INTERNAL_LOAD_BALANCER = 10,
  /** ARRIVE_AT_EXTERNAL_LOAD_BALANCER - Forwarding state: arriving at a Compute Engine external load balancer. */
  ARRIVE_AT_EXTERNAL_LOAD_BALANCER = 11,
  /** ARRIVE_AT_VPN_GATEWAY - Forwarding state: arriving at a Cloud VPN gateway. */
  ARRIVE_AT_VPN_GATEWAY = 12,
  /** ARRIVE_AT_VPN_TUNNEL - Forwarding state: arriving at a Cloud VPN tunnel. */
  ARRIVE_AT_VPN_TUNNEL = 13,
  /** ARRIVE_AT_VPC_CONNECTOR - Forwarding state: arriving at a VPC connector. */
  ARRIVE_AT_VPC_CONNECTOR = 24,
  /** NAT - Transition state: packet header translated. */
  NAT = 14,
  /**
   * PROXY_CONNECTION - Transition state: original connection is terminated and a new proxied
   * connection is initiated.
   */
  PROXY_CONNECTION = 15,
  /** DELIVER - Final state: packet could be delivered. */
  DELIVER = 16,
  /** DROP - Final state: packet could be dropped. */
  DROP = 17,
  /**
   * FORWARD - Final state: packet could be forwarded to a network with an unknown
   * configuration.
   */
  FORWARD = 18,
  /** ABORT - Final state: analysis is aborted. */
  ABORT = 19,
  /**
   * VIEWER_PERMISSION_MISSING - Special state: viewer of the test result does not have permission to
   * see the configuration in this step.
   */
  VIEWER_PERMISSION_MISSING = 20,
  UNRECOGNIZED = -1,
}

export function step_StateFromJSON(object: any): Step_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Step_State.STATE_UNSPECIFIED;
    case 1:
    case "START_FROM_INSTANCE":
      return Step_State.START_FROM_INSTANCE;
    case 2:
    case "START_FROM_INTERNET":
      return Step_State.START_FROM_INTERNET;
    case 27:
    case "START_FROM_GOOGLE_SERVICE":
      return Step_State.START_FROM_GOOGLE_SERVICE;
    case 3:
    case "START_FROM_PRIVATE_NETWORK":
      return Step_State.START_FROM_PRIVATE_NETWORK;
    case 21:
    case "START_FROM_GKE_MASTER":
      return Step_State.START_FROM_GKE_MASTER;
    case 22:
    case "START_FROM_CLOUD_SQL_INSTANCE":
      return Step_State.START_FROM_CLOUD_SQL_INSTANCE;
    case 23:
    case "START_FROM_CLOUD_FUNCTION":
      return Step_State.START_FROM_CLOUD_FUNCTION;
    case 25:
    case "START_FROM_APP_ENGINE_VERSION":
      return Step_State.START_FROM_APP_ENGINE_VERSION;
    case 26:
    case "START_FROM_CLOUD_RUN_REVISION":
      return Step_State.START_FROM_CLOUD_RUN_REVISION;
    case 4:
    case "APPLY_INGRESS_FIREWALL_RULE":
      return Step_State.APPLY_INGRESS_FIREWALL_RULE;
    case 5:
    case "APPLY_EGRESS_FIREWALL_RULE":
      return Step_State.APPLY_EGRESS_FIREWALL_RULE;
    case 6:
    case "APPLY_ROUTE":
      return Step_State.APPLY_ROUTE;
    case 7:
    case "APPLY_FORWARDING_RULE":
      return Step_State.APPLY_FORWARDING_RULE;
    case 8:
    case "SPOOFING_APPROVED":
      return Step_State.SPOOFING_APPROVED;
    case 9:
    case "ARRIVE_AT_INSTANCE":
      return Step_State.ARRIVE_AT_INSTANCE;
    case 10:
    case "ARRIVE_AT_INTERNAL_LOAD_BALANCER":
      return Step_State.ARRIVE_AT_INTERNAL_LOAD_BALANCER;
    case 11:
    case "ARRIVE_AT_EXTERNAL_LOAD_BALANCER":
      return Step_State.ARRIVE_AT_EXTERNAL_LOAD_BALANCER;
    case 12:
    case "ARRIVE_AT_VPN_GATEWAY":
      return Step_State.ARRIVE_AT_VPN_GATEWAY;
    case 13:
    case "ARRIVE_AT_VPN_TUNNEL":
      return Step_State.ARRIVE_AT_VPN_TUNNEL;
    case 24:
    case "ARRIVE_AT_VPC_CONNECTOR":
      return Step_State.ARRIVE_AT_VPC_CONNECTOR;
    case 14:
    case "NAT":
      return Step_State.NAT;
    case 15:
    case "PROXY_CONNECTION":
      return Step_State.PROXY_CONNECTION;
    case 16:
    case "DELIVER":
      return Step_State.DELIVER;
    case 17:
    case "DROP":
      return Step_State.DROP;
    case 18:
    case "FORWARD":
      return Step_State.FORWARD;
    case 19:
    case "ABORT":
      return Step_State.ABORT;
    case 20:
    case "VIEWER_PERMISSION_MISSING":
      return Step_State.VIEWER_PERMISSION_MISSING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Step_State.UNRECOGNIZED;
  }
}

export function step_StateToJSON(object: Step_State): string {
  switch (object) {
    case Step_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Step_State.START_FROM_INSTANCE:
      return "START_FROM_INSTANCE";
    case Step_State.START_FROM_INTERNET:
      return "START_FROM_INTERNET";
    case Step_State.START_FROM_GOOGLE_SERVICE:
      return "START_FROM_GOOGLE_SERVICE";
    case Step_State.START_FROM_PRIVATE_NETWORK:
      return "START_FROM_PRIVATE_NETWORK";
    case Step_State.START_FROM_GKE_MASTER:
      return "START_FROM_GKE_MASTER";
    case Step_State.START_FROM_CLOUD_SQL_INSTANCE:
      return "START_FROM_CLOUD_SQL_INSTANCE";
    case Step_State.START_FROM_CLOUD_FUNCTION:
      return "START_FROM_CLOUD_FUNCTION";
    case Step_State.START_FROM_APP_ENGINE_VERSION:
      return "START_FROM_APP_ENGINE_VERSION";
    case Step_State.START_FROM_CLOUD_RUN_REVISION:
      return "START_FROM_CLOUD_RUN_REVISION";
    case Step_State.APPLY_INGRESS_FIREWALL_RULE:
      return "APPLY_INGRESS_FIREWALL_RULE";
    case Step_State.APPLY_EGRESS_FIREWALL_RULE:
      return "APPLY_EGRESS_FIREWALL_RULE";
    case Step_State.APPLY_ROUTE:
      return "APPLY_ROUTE";
    case Step_State.APPLY_FORWARDING_RULE:
      return "APPLY_FORWARDING_RULE";
    case Step_State.SPOOFING_APPROVED:
      return "SPOOFING_APPROVED";
    case Step_State.ARRIVE_AT_INSTANCE:
      return "ARRIVE_AT_INSTANCE";
    case Step_State.ARRIVE_AT_INTERNAL_LOAD_BALANCER:
      return "ARRIVE_AT_INTERNAL_LOAD_BALANCER";
    case Step_State.ARRIVE_AT_EXTERNAL_LOAD_BALANCER:
      return "ARRIVE_AT_EXTERNAL_LOAD_BALANCER";
    case Step_State.ARRIVE_AT_VPN_GATEWAY:
      return "ARRIVE_AT_VPN_GATEWAY";
    case Step_State.ARRIVE_AT_VPN_TUNNEL:
      return "ARRIVE_AT_VPN_TUNNEL";
    case Step_State.ARRIVE_AT_VPC_CONNECTOR:
      return "ARRIVE_AT_VPC_CONNECTOR";
    case Step_State.NAT:
      return "NAT";
    case Step_State.PROXY_CONNECTION:
      return "PROXY_CONNECTION";
    case Step_State.DELIVER:
      return "DELIVER";
    case Step_State.DROP:
      return "DROP";
    case Step_State.FORWARD:
      return "FORWARD";
    case Step_State.ABORT:
      return "ABORT";
    case Step_State.VIEWER_PERMISSION_MISSING:
      return "VIEWER_PERMISSION_MISSING";
    case Step_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a Compute Engine instance. */
export interface InstanceInfo {
  /** Name of a Compute Engine instance. */
  displayName: string;
  /** URI of a Compute Engine instance. */
  uri: string;
  /** Name of the network interface of a Compute Engine instance. */
  interface: string;
  /** URI of a Compute Engine network. */
  networkUri: string;
  /** Internal IP address of the network interface. */
  internalIp: string;
  /** External IP address of the network interface. */
  externalIp: string;
  /** Network tags configured on the instance. */
  networkTags: string[];
  /** Service account authorized for the instance. */
  serviceAccount: string;
}

/** For display only. Metadata associated with a Compute Engine network. */
export interface NetworkInfo {
  /** Name of a Compute Engine network. */
  displayName: string;
  /** URI of a Compute Engine network. */
  uri: string;
  /** The IP range that matches the test. */
  matchedIpRange: string;
}

/**
 * For display only. Metadata associated with a VPC firewall rule, an implied
 * VPC firewall rule, or a hierarchical firewall policy rule.
 */
export interface FirewallInfo {
  /**
   * The display name of the VPC firewall rule. This field is not applicable
   * to hierarchical firewall policy rules.
   */
  displayName: string;
  /**
   * The URI of the VPC firewall rule. This field is not applicable to
   * implied firewall rules or hierarchical firewall policy rules.
   */
  uri: string;
  /** Possible values: INGRESS, EGRESS */
  direction: string;
  /** Possible values: ALLOW, DENY */
  action: string;
  /** The priority of the firewall rule. */
  priority: number;
  /**
   * The URI of the VPC network that the firewall rule is associated with.
   * This field is not applicable to hierarchical firewall policy rules.
   */
  networkUri: string;
  /**
   * The target tags defined by the VPC firewall rule. This field is not
   * applicable to hierarchical firewall policy rules.
   */
  targetTags: string[];
  /** The target service accounts specified by the firewall rule. */
  targetServiceAccounts: string[];
  /**
   * The hierarchical firewall policy that this rule is associated with.
   * This field is not applicable to VPC firewall rules.
   */
  policy: string;
  /** The firewall rule's type. */
  firewallRuleType: FirewallInfo_FirewallRuleType;
}

/** The firewall rule's type. */
export enum FirewallInfo_FirewallRuleType {
  /** FIREWALL_RULE_TYPE_UNSPECIFIED - Unspecified type. */
  FIREWALL_RULE_TYPE_UNSPECIFIED = 0,
  /**
   * HIERARCHICAL_FIREWALL_POLICY_RULE - Hierarchical firewall policy rule. For details, see
   * [Hierarchical firewall policies
   * overview](https://cloud.google.com/vpc/docs/firewall-policies).
   */
  HIERARCHICAL_FIREWALL_POLICY_RULE = 1,
  /**
   * VPC_FIREWALL_RULE - VPC firewall rule. For details, see
   * [VPC firewall rules
   * overview](https://cloud.google.com/vpc/docs/firewalls).
   */
  VPC_FIREWALL_RULE = 2,
  /**
   * IMPLIED_VPC_FIREWALL_RULE - Implied VPC firewall rule. For details, see
   * [Implied
   * rules](https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules).
   */
  IMPLIED_VPC_FIREWALL_RULE = 3,
  /**
   * SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE - Implicit firewall rules that are managed by serverless VPC access to
   * allow ingress access. They are not visible in the Google Cloud console.
   * For details, see [VPC connector's implicit
   * rules](https://cloud.google.com/functions/docs/networking/connecting-vpc#restrict-access).
   */
  SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE = 4,
  /**
   * NETWORK_FIREWALL_POLICY_RULE - Global network firewall policy rule.
   * For details, see [Network firewall
   * policies](https://cloud.google.com/vpc/docs/network-firewall-policies).
   */
  NETWORK_FIREWALL_POLICY_RULE = 5,
  UNRECOGNIZED = -1,
}

export function firewallInfo_FirewallRuleTypeFromJSON(object: any): FirewallInfo_FirewallRuleType {
  switch (object) {
    case 0:
    case "FIREWALL_RULE_TYPE_UNSPECIFIED":
      return FirewallInfo_FirewallRuleType.FIREWALL_RULE_TYPE_UNSPECIFIED;
    case 1:
    case "HIERARCHICAL_FIREWALL_POLICY_RULE":
      return FirewallInfo_FirewallRuleType.HIERARCHICAL_FIREWALL_POLICY_RULE;
    case 2:
    case "VPC_FIREWALL_RULE":
      return FirewallInfo_FirewallRuleType.VPC_FIREWALL_RULE;
    case 3:
    case "IMPLIED_VPC_FIREWALL_RULE":
      return FirewallInfo_FirewallRuleType.IMPLIED_VPC_FIREWALL_RULE;
    case 4:
    case "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE":
      return FirewallInfo_FirewallRuleType.SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE;
    case 5:
    case "NETWORK_FIREWALL_POLICY_RULE":
      return FirewallInfo_FirewallRuleType.NETWORK_FIREWALL_POLICY_RULE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FirewallInfo_FirewallRuleType.UNRECOGNIZED;
  }
}

export function firewallInfo_FirewallRuleTypeToJSON(object: FirewallInfo_FirewallRuleType): string {
  switch (object) {
    case FirewallInfo_FirewallRuleType.FIREWALL_RULE_TYPE_UNSPECIFIED:
      return "FIREWALL_RULE_TYPE_UNSPECIFIED";
    case FirewallInfo_FirewallRuleType.HIERARCHICAL_FIREWALL_POLICY_RULE:
      return "HIERARCHICAL_FIREWALL_POLICY_RULE";
    case FirewallInfo_FirewallRuleType.VPC_FIREWALL_RULE:
      return "VPC_FIREWALL_RULE";
    case FirewallInfo_FirewallRuleType.IMPLIED_VPC_FIREWALL_RULE:
      return "IMPLIED_VPC_FIREWALL_RULE";
    case FirewallInfo_FirewallRuleType.SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE:
      return "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE";
    case FirewallInfo_FirewallRuleType.NETWORK_FIREWALL_POLICY_RULE:
      return "NETWORK_FIREWALL_POLICY_RULE";
    case FirewallInfo_FirewallRuleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a Compute Engine route. */
export interface RouteInfo {
  /** Type of route. */
  routeType: RouteInfo_RouteType;
  /** Type of next hop. */
  nextHopType: RouteInfo_NextHopType;
  /** Name of a Compute Engine route. */
  displayName: string;
  /**
   * URI of a Compute Engine route.
   * Dynamic route from cloud router does not have a URI.
   * Advertised route from Google Cloud VPC to on-premises network also does
   * not have a URI.
   */
  uri: string;
  /** Destination IP range of the route. */
  destIpRange: string;
  /** Next hop of the route. */
  nextHop: string;
  /** URI of a Compute Engine network. */
  networkUri: string;
  /** Priority of the route. */
  priority: number;
  /** Instance tags of the route. */
  instanceTags: string[];
  /** Source IP address range of the route. Policy based routes only. */
  srcIpRange: string;
  /** Destination port ranges of the route. Policy based routes only. */
  destPortRanges: string[];
  /** Source port ranges of the route. Policy based routes only. */
  srcPortRanges: string[];
  /** Protocols of the route. Policy based routes only. */
  protocols: string[];
}

/** Type of route: */
export enum RouteInfo_RouteType {
  /** ROUTE_TYPE_UNSPECIFIED - Unspecified type. Default value. */
  ROUTE_TYPE_UNSPECIFIED = 0,
  /** SUBNET - Route is a subnet route automatically created by the system. */
  SUBNET = 1,
  /**
   * STATIC - Static route created by the user, including the default route to the
   * internet.
   */
  STATIC = 2,
  /** DYNAMIC - Dynamic route exchanged between BGP peers. */
  DYNAMIC = 3,
  /** PEERING_SUBNET - A subnet route received from peering network. */
  PEERING_SUBNET = 4,
  /** PEERING_STATIC - A static route received from peering network. */
  PEERING_STATIC = 5,
  /** PEERING_DYNAMIC - A dynamic route received from peering network. */
  PEERING_DYNAMIC = 6,
  /** POLICY_BASED - Policy based route. */
  POLICY_BASED = 7,
  UNRECOGNIZED = -1,
}

export function routeInfo_RouteTypeFromJSON(object: any): RouteInfo_RouteType {
  switch (object) {
    case 0:
    case "ROUTE_TYPE_UNSPECIFIED":
      return RouteInfo_RouteType.ROUTE_TYPE_UNSPECIFIED;
    case 1:
    case "SUBNET":
      return RouteInfo_RouteType.SUBNET;
    case 2:
    case "STATIC":
      return RouteInfo_RouteType.STATIC;
    case 3:
    case "DYNAMIC":
      return RouteInfo_RouteType.DYNAMIC;
    case 4:
    case "PEERING_SUBNET":
      return RouteInfo_RouteType.PEERING_SUBNET;
    case 5:
    case "PEERING_STATIC":
      return RouteInfo_RouteType.PEERING_STATIC;
    case 6:
    case "PEERING_DYNAMIC":
      return RouteInfo_RouteType.PEERING_DYNAMIC;
    case 7:
    case "POLICY_BASED":
      return RouteInfo_RouteType.POLICY_BASED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RouteInfo_RouteType.UNRECOGNIZED;
  }
}

export function routeInfo_RouteTypeToJSON(object: RouteInfo_RouteType): string {
  switch (object) {
    case RouteInfo_RouteType.ROUTE_TYPE_UNSPECIFIED:
      return "ROUTE_TYPE_UNSPECIFIED";
    case RouteInfo_RouteType.SUBNET:
      return "SUBNET";
    case RouteInfo_RouteType.STATIC:
      return "STATIC";
    case RouteInfo_RouteType.DYNAMIC:
      return "DYNAMIC";
    case RouteInfo_RouteType.PEERING_SUBNET:
      return "PEERING_SUBNET";
    case RouteInfo_RouteType.PEERING_STATIC:
      return "PEERING_STATIC";
    case RouteInfo_RouteType.PEERING_DYNAMIC:
      return "PEERING_DYNAMIC";
    case RouteInfo_RouteType.POLICY_BASED:
      return "POLICY_BASED";
    case RouteInfo_RouteType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of next hop: */
export enum RouteInfo_NextHopType {
  /** NEXT_HOP_TYPE_UNSPECIFIED - Unspecified type. Default value. */
  NEXT_HOP_TYPE_UNSPECIFIED = 0,
  /** NEXT_HOP_IP - Next hop is an IP address. */
  NEXT_HOP_IP = 1,
  /** NEXT_HOP_INSTANCE - Next hop is a Compute Engine instance. */
  NEXT_HOP_INSTANCE = 2,
  /** NEXT_HOP_NETWORK - Next hop is a VPC network gateway. */
  NEXT_HOP_NETWORK = 3,
  /** NEXT_HOP_PEERING - Next hop is a peering VPC. */
  NEXT_HOP_PEERING = 4,
  /** NEXT_HOP_INTERCONNECT - Next hop is an interconnect. */
  NEXT_HOP_INTERCONNECT = 5,
  /** NEXT_HOP_VPN_TUNNEL - Next hop is a VPN tunnel. */
  NEXT_HOP_VPN_TUNNEL = 6,
  /**
   * NEXT_HOP_VPN_GATEWAY - Next hop is a VPN gateway. This scenario only happens when tracing
   * connectivity from an on-premises network to Google Cloud through a VPN.
   * The analysis simulates a packet departing from the on-premises network
   * through a VPN tunnel and arriving at a Cloud VPN gateway.
   */
  NEXT_HOP_VPN_GATEWAY = 7,
  /** NEXT_HOP_INTERNET_GATEWAY - Next hop is an internet gateway. */
  NEXT_HOP_INTERNET_GATEWAY = 8,
  /**
   * NEXT_HOP_BLACKHOLE - Next hop is blackhole; that is, the next hop either does not exist or is
   * not running.
   */
  NEXT_HOP_BLACKHOLE = 9,
  /** NEXT_HOP_ILB - Next hop is the forwarding rule of an Internal Load Balancer. */
  NEXT_HOP_ILB = 10,
  /**
   * NEXT_HOP_ROUTER_APPLIANCE - Next hop is a
   * [router appliance
   * instance](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/ra-overview).
   */
  NEXT_HOP_ROUTER_APPLIANCE = 11,
  UNRECOGNIZED = -1,
}

export function routeInfo_NextHopTypeFromJSON(object: any): RouteInfo_NextHopType {
  switch (object) {
    case 0:
    case "NEXT_HOP_TYPE_UNSPECIFIED":
      return RouteInfo_NextHopType.NEXT_HOP_TYPE_UNSPECIFIED;
    case 1:
    case "NEXT_HOP_IP":
      return RouteInfo_NextHopType.NEXT_HOP_IP;
    case 2:
    case "NEXT_HOP_INSTANCE":
      return RouteInfo_NextHopType.NEXT_HOP_INSTANCE;
    case 3:
    case "NEXT_HOP_NETWORK":
      return RouteInfo_NextHopType.NEXT_HOP_NETWORK;
    case 4:
    case "NEXT_HOP_PEERING":
      return RouteInfo_NextHopType.NEXT_HOP_PEERING;
    case 5:
    case "NEXT_HOP_INTERCONNECT":
      return RouteInfo_NextHopType.NEXT_HOP_INTERCONNECT;
    case 6:
    case "NEXT_HOP_VPN_TUNNEL":
      return RouteInfo_NextHopType.NEXT_HOP_VPN_TUNNEL;
    case 7:
    case "NEXT_HOP_VPN_GATEWAY":
      return RouteInfo_NextHopType.NEXT_HOP_VPN_GATEWAY;
    case 8:
    case "NEXT_HOP_INTERNET_GATEWAY":
      return RouteInfo_NextHopType.NEXT_HOP_INTERNET_GATEWAY;
    case 9:
    case "NEXT_HOP_BLACKHOLE":
      return RouteInfo_NextHopType.NEXT_HOP_BLACKHOLE;
    case 10:
    case "NEXT_HOP_ILB":
      return RouteInfo_NextHopType.NEXT_HOP_ILB;
    case 11:
    case "NEXT_HOP_ROUTER_APPLIANCE":
      return RouteInfo_NextHopType.NEXT_HOP_ROUTER_APPLIANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RouteInfo_NextHopType.UNRECOGNIZED;
  }
}

export function routeInfo_NextHopTypeToJSON(object: RouteInfo_NextHopType): string {
  switch (object) {
    case RouteInfo_NextHopType.NEXT_HOP_TYPE_UNSPECIFIED:
      return "NEXT_HOP_TYPE_UNSPECIFIED";
    case RouteInfo_NextHopType.NEXT_HOP_IP:
      return "NEXT_HOP_IP";
    case RouteInfo_NextHopType.NEXT_HOP_INSTANCE:
      return "NEXT_HOP_INSTANCE";
    case RouteInfo_NextHopType.NEXT_HOP_NETWORK:
      return "NEXT_HOP_NETWORK";
    case RouteInfo_NextHopType.NEXT_HOP_PEERING:
      return "NEXT_HOP_PEERING";
    case RouteInfo_NextHopType.NEXT_HOP_INTERCONNECT:
      return "NEXT_HOP_INTERCONNECT";
    case RouteInfo_NextHopType.NEXT_HOP_VPN_TUNNEL:
      return "NEXT_HOP_VPN_TUNNEL";
    case RouteInfo_NextHopType.NEXT_HOP_VPN_GATEWAY:
      return "NEXT_HOP_VPN_GATEWAY";
    case RouteInfo_NextHopType.NEXT_HOP_INTERNET_GATEWAY:
      return "NEXT_HOP_INTERNET_GATEWAY";
    case RouteInfo_NextHopType.NEXT_HOP_BLACKHOLE:
      return "NEXT_HOP_BLACKHOLE";
    case RouteInfo_NextHopType.NEXT_HOP_ILB:
      return "NEXT_HOP_ILB";
    case RouteInfo_NextHopType.NEXT_HOP_ROUTER_APPLIANCE:
      return "NEXT_HOP_ROUTER_APPLIANCE";
    case RouteInfo_NextHopType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * For display only. Details of a Google Service sending packets to a
 * VPC network. Although the source IP might be a publicly routable address,
 * some Google Services use special routes within Google production
 * infrastructure to reach Compute Engine Instances.
 * https://cloud.google.com/vpc/docs/routes#special_return_paths
 */
export interface GoogleServiceInfo {
  /** Source IP address. */
  sourceIp: string;
  /** Recognized type of a Google Service. */
  googleServiceType: GoogleServiceInfo_GoogleServiceType;
}

/** Recognized type of a Google Service. */
export enum GoogleServiceInfo_GoogleServiceType {
  /** GOOGLE_SERVICE_TYPE_UNSPECIFIED - Unspecified Google Service. Includes most of Google APIs and services. */
  GOOGLE_SERVICE_TYPE_UNSPECIFIED = 0,
  /**
   * IAP - Identity aware proxy.
   * https://cloud.google.com/iap/docs/using-tcp-forwarding
   */
  IAP = 1,
  /**
   * GFE_PROXY_OR_HEALTH_CHECK_PROBER - One of two services sharing IP ranges:
   * * Load Balancer proxy
   * * Centralized Health Check prober
   * https://cloud.google.com/load-balancing/docs/firewall-rules
   */
  GFE_PROXY_OR_HEALTH_CHECK_PROBER = 2,
  /**
   * CLOUD_DNS - Connectivity from Cloud DNS to forwarding targets or alternate name
   * servers that use private routing.
   * https://cloud.google.com/dns/docs/zones/forwarding-zones#firewall-rules
   * https://cloud.google.com/dns/docs/policies#firewall-rules
   */
  CLOUD_DNS = 3,
  UNRECOGNIZED = -1,
}

export function googleServiceInfo_GoogleServiceTypeFromJSON(object: any): GoogleServiceInfo_GoogleServiceType {
  switch (object) {
    case 0:
    case "GOOGLE_SERVICE_TYPE_UNSPECIFIED":
      return GoogleServiceInfo_GoogleServiceType.GOOGLE_SERVICE_TYPE_UNSPECIFIED;
    case 1:
    case "IAP":
      return GoogleServiceInfo_GoogleServiceType.IAP;
    case 2:
    case "GFE_PROXY_OR_HEALTH_CHECK_PROBER":
      return GoogleServiceInfo_GoogleServiceType.GFE_PROXY_OR_HEALTH_CHECK_PROBER;
    case 3:
    case "CLOUD_DNS":
      return GoogleServiceInfo_GoogleServiceType.CLOUD_DNS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GoogleServiceInfo_GoogleServiceType.UNRECOGNIZED;
  }
}

export function googleServiceInfo_GoogleServiceTypeToJSON(object: GoogleServiceInfo_GoogleServiceType): string {
  switch (object) {
    case GoogleServiceInfo_GoogleServiceType.GOOGLE_SERVICE_TYPE_UNSPECIFIED:
      return "GOOGLE_SERVICE_TYPE_UNSPECIFIED";
    case GoogleServiceInfo_GoogleServiceType.IAP:
      return "IAP";
    case GoogleServiceInfo_GoogleServiceType.GFE_PROXY_OR_HEALTH_CHECK_PROBER:
      return "GFE_PROXY_OR_HEALTH_CHECK_PROBER";
    case GoogleServiceInfo_GoogleServiceType.CLOUD_DNS:
      return "CLOUD_DNS";
    case GoogleServiceInfo_GoogleServiceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a Compute Engine forwarding rule. */
export interface ForwardingRuleInfo {
  /** Name of a Compute Engine forwarding rule. */
  displayName: string;
  /** URI of a Compute Engine forwarding rule. */
  uri: string;
  /** Protocol defined in the forwarding rule that matches the test. */
  matchedProtocol: string;
  /** Port range defined in the forwarding rule that matches the test. */
  matchedPortRange: string;
  /** VIP of the forwarding rule. */
  vip: string;
  /** Target type of the forwarding rule. */
  target: string;
  /** Network URI. Only valid for Internal Load Balancer. */
  networkUri: string;
}

/** For display only. Metadata associated with a load balancer. */
export interface LoadBalancerInfo {
  /** Type of the load balancer. */
  loadBalancerType: LoadBalancerInfo_LoadBalancerType;
  /** URI of the health check for the load balancer. */
  healthCheckUri: string;
  /** Information for the loadbalancer backends. */
  backends: LoadBalancerBackend[];
  /** Type of load balancer's backend configuration. */
  backendType: LoadBalancerInfo_BackendType;
  /** Backend configuration URI. */
  backendUri: string;
}

/** The type definition for a load balancer: */
export enum LoadBalancerInfo_LoadBalancerType {
  /** LOAD_BALANCER_TYPE_UNSPECIFIED - Type is unspecified. */
  LOAD_BALANCER_TYPE_UNSPECIFIED = 0,
  /** INTERNAL_TCP_UDP - Internal TCP/UDP load balancer. */
  INTERNAL_TCP_UDP = 1,
  /** NETWORK_TCP_UDP - Network TCP/UDP load balancer. */
  NETWORK_TCP_UDP = 2,
  /** HTTP_PROXY - HTTP(S) proxy load balancer. */
  HTTP_PROXY = 3,
  /** TCP_PROXY - TCP proxy load balancer. */
  TCP_PROXY = 4,
  /** SSL_PROXY - SSL proxy load balancer. */
  SSL_PROXY = 5,
  UNRECOGNIZED = -1,
}

export function loadBalancerInfo_LoadBalancerTypeFromJSON(object: any): LoadBalancerInfo_LoadBalancerType {
  switch (object) {
    case 0:
    case "LOAD_BALANCER_TYPE_UNSPECIFIED":
      return LoadBalancerInfo_LoadBalancerType.LOAD_BALANCER_TYPE_UNSPECIFIED;
    case 1:
    case "INTERNAL_TCP_UDP":
      return LoadBalancerInfo_LoadBalancerType.INTERNAL_TCP_UDP;
    case 2:
    case "NETWORK_TCP_UDP":
      return LoadBalancerInfo_LoadBalancerType.NETWORK_TCP_UDP;
    case 3:
    case "HTTP_PROXY":
      return LoadBalancerInfo_LoadBalancerType.HTTP_PROXY;
    case 4:
    case "TCP_PROXY":
      return LoadBalancerInfo_LoadBalancerType.TCP_PROXY;
    case 5:
    case "SSL_PROXY":
      return LoadBalancerInfo_LoadBalancerType.SSL_PROXY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancerInfo_LoadBalancerType.UNRECOGNIZED;
  }
}

export function loadBalancerInfo_LoadBalancerTypeToJSON(object: LoadBalancerInfo_LoadBalancerType): string {
  switch (object) {
    case LoadBalancerInfo_LoadBalancerType.LOAD_BALANCER_TYPE_UNSPECIFIED:
      return "LOAD_BALANCER_TYPE_UNSPECIFIED";
    case LoadBalancerInfo_LoadBalancerType.INTERNAL_TCP_UDP:
      return "INTERNAL_TCP_UDP";
    case LoadBalancerInfo_LoadBalancerType.NETWORK_TCP_UDP:
      return "NETWORK_TCP_UDP";
    case LoadBalancerInfo_LoadBalancerType.HTTP_PROXY:
      return "HTTP_PROXY";
    case LoadBalancerInfo_LoadBalancerType.TCP_PROXY:
      return "TCP_PROXY";
    case LoadBalancerInfo_LoadBalancerType.SSL_PROXY:
      return "SSL_PROXY";
    case LoadBalancerInfo_LoadBalancerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type definition for a load balancer backend configuration: */
export enum LoadBalancerInfo_BackendType {
  /** BACKEND_TYPE_UNSPECIFIED - Type is unspecified. */
  BACKEND_TYPE_UNSPECIFIED = 0,
  /** BACKEND_SERVICE - Backend Service as the load balancer's backend. */
  BACKEND_SERVICE = 1,
  /** TARGET_POOL - Target Pool as the load balancer's backend. */
  TARGET_POOL = 2,
  /** TARGET_INSTANCE - Target Instance as the load balancer's backend. */
  TARGET_INSTANCE = 3,
  UNRECOGNIZED = -1,
}

export function loadBalancerInfo_BackendTypeFromJSON(object: any): LoadBalancerInfo_BackendType {
  switch (object) {
    case 0:
    case "BACKEND_TYPE_UNSPECIFIED":
      return LoadBalancerInfo_BackendType.BACKEND_TYPE_UNSPECIFIED;
    case 1:
    case "BACKEND_SERVICE":
      return LoadBalancerInfo_BackendType.BACKEND_SERVICE;
    case 2:
    case "TARGET_POOL":
      return LoadBalancerInfo_BackendType.TARGET_POOL;
    case 3:
    case "TARGET_INSTANCE":
      return LoadBalancerInfo_BackendType.TARGET_INSTANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancerInfo_BackendType.UNRECOGNIZED;
  }
}

export function loadBalancerInfo_BackendTypeToJSON(object: LoadBalancerInfo_BackendType): string {
  switch (object) {
    case LoadBalancerInfo_BackendType.BACKEND_TYPE_UNSPECIFIED:
      return "BACKEND_TYPE_UNSPECIFIED";
    case LoadBalancerInfo_BackendType.BACKEND_SERVICE:
      return "BACKEND_SERVICE";
    case LoadBalancerInfo_BackendType.TARGET_POOL:
      return "TARGET_POOL";
    case LoadBalancerInfo_BackendType.TARGET_INSTANCE:
      return "TARGET_INSTANCE";
    case LoadBalancerInfo_BackendType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a specific load balancer backend. */
export interface LoadBalancerBackend {
  /** Name of a Compute Engine instance or network endpoint. */
  displayName: string;
  /** URI of a Compute Engine instance or network endpoint. */
  uri: string;
  /** State of the health check firewall configuration. */
  healthCheckFirewallState: LoadBalancerBackend_HealthCheckFirewallState;
  /** A list of firewall rule URIs allowing probes from health check IP ranges. */
  healthCheckAllowingFirewallRules: string[];
  /** A list of firewall rule URIs blocking probes from health check IP ranges. */
  healthCheckBlockingFirewallRules: string[];
}

/** State of a health check firewall configuration: */
export enum LoadBalancerBackend_HealthCheckFirewallState {
  /** HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED - State is unspecified. Default state if not populated. */
  HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED = 0,
  /**
   * CONFIGURED - There are configured firewall rules to allow health check probes to the
   * backend.
   */
  CONFIGURED = 1,
  /**
   * MISCONFIGURED - There are firewall rules configured to allow partial health check ranges
   * or block all health check ranges.
   * If a health check probe is sent from denied IP ranges,
   * the health check to the backend will fail. Then, the backend will be
   * marked unhealthy and will not receive traffic sent to the load balancer.
   */
  MISCONFIGURED = 2,
  UNRECOGNIZED = -1,
}

export function loadBalancerBackend_HealthCheckFirewallStateFromJSON(
  object: any,
): LoadBalancerBackend_HealthCheckFirewallState {
  switch (object) {
    case 0:
    case "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED":
      return LoadBalancerBackend_HealthCheckFirewallState.HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED;
    case 1:
    case "CONFIGURED":
      return LoadBalancerBackend_HealthCheckFirewallState.CONFIGURED;
    case 2:
    case "MISCONFIGURED":
      return LoadBalancerBackend_HealthCheckFirewallState.MISCONFIGURED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancerBackend_HealthCheckFirewallState.UNRECOGNIZED;
  }
}

export function loadBalancerBackend_HealthCheckFirewallStateToJSON(
  object: LoadBalancerBackend_HealthCheckFirewallState,
): string {
  switch (object) {
    case LoadBalancerBackend_HealthCheckFirewallState.HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED:
      return "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED";
    case LoadBalancerBackend_HealthCheckFirewallState.CONFIGURED:
      return "CONFIGURED";
    case LoadBalancerBackend_HealthCheckFirewallState.MISCONFIGURED:
      return "MISCONFIGURED";
    case LoadBalancerBackend_HealthCheckFirewallState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a Compute Engine VPN gateway. */
export interface VpnGatewayInfo {
  /** Name of a VPN gateway. */
  displayName: string;
  /** URI of a VPN gateway. */
  uri: string;
  /** URI of a Compute Engine network where the VPN gateway is configured. */
  networkUri: string;
  /** IP address of the VPN gateway. */
  ipAddress: string;
  /**
   * A VPN tunnel that is associated with this VPN gateway.
   * There may be multiple VPN tunnels configured on a VPN gateway, and only
   * the one relevant to the test is displayed.
   */
  vpnTunnelUri: string;
  /** Name of a Google Cloud region where this VPN gateway is configured. */
  region: string;
}

/** For display only. Metadata associated with a Compute Engine VPN tunnel. */
export interface VpnTunnelInfo {
  /** Name of a VPN tunnel. */
  displayName: string;
  /** URI of a VPN tunnel. */
  uri: string;
  /** URI of the VPN gateway at local end of the tunnel. */
  sourceGateway: string;
  /** URI of a VPN gateway at remote end of the tunnel. */
  remoteGateway: string;
  /** Remote VPN gateway's IP address. */
  remoteGatewayIp: string;
  /** Local VPN gateway's IP address. */
  sourceGatewayIp: string;
  /** URI of a Compute Engine network where the VPN tunnel is configured. */
  networkUri: string;
  /** Name of a Google Cloud region where this VPN tunnel is configured. */
  region: string;
  /** Type of the routing policy. */
  routingType: VpnTunnelInfo_RoutingType;
}

/**
 * Types of VPN routing policy. For details, refer to [Networks and Tunnel
 * routing](https://cloud.google.com/network-connectivity/docs/vpn/concepts/choosing-networks-routing/).
 */
export enum VpnTunnelInfo_RoutingType {
  /** ROUTING_TYPE_UNSPECIFIED - Unspecified type. Default value. */
  ROUTING_TYPE_UNSPECIFIED = 0,
  /** ROUTE_BASED - Route based VPN. */
  ROUTE_BASED = 1,
  /** POLICY_BASED - Policy based routing. */
  POLICY_BASED = 2,
  /** DYNAMIC - Dynamic (BGP) routing. */
  DYNAMIC = 3,
  UNRECOGNIZED = -1,
}

export function vpnTunnelInfo_RoutingTypeFromJSON(object: any): VpnTunnelInfo_RoutingType {
  switch (object) {
    case 0:
    case "ROUTING_TYPE_UNSPECIFIED":
      return VpnTunnelInfo_RoutingType.ROUTING_TYPE_UNSPECIFIED;
    case 1:
    case "ROUTE_BASED":
      return VpnTunnelInfo_RoutingType.ROUTE_BASED;
    case 2:
    case "POLICY_BASED":
      return VpnTunnelInfo_RoutingType.POLICY_BASED;
    case 3:
    case "DYNAMIC":
      return VpnTunnelInfo_RoutingType.DYNAMIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VpnTunnelInfo_RoutingType.UNRECOGNIZED;
  }
}

export function vpnTunnelInfo_RoutingTypeToJSON(object: VpnTunnelInfo_RoutingType): string {
  switch (object) {
    case VpnTunnelInfo_RoutingType.ROUTING_TYPE_UNSPECIFIED:
      return "ROUTING_TYPE_UNSPECIFIED";
    case VpnTunnelInfo_RoutingType.ROUTE_BASED:
      return "ROUTE_BASED";
    case VpnTunnelInfo_RoutingType.POLICY_BASED:
      return "POLICY_BASED";
    case VpnTunnelInfo_RoutingType.DYNAMIC:
      return "DYNAMIC";
    case VpnTunnelInfo_RoutingType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * For display only. The specification of the endpoints for the test.
 * EndpointInfo is derived from source and destination Endpoint and validated
 * by the backend data plane model.
 */
export interface EndpointInfo {
  /** Source IP address. */
  sourceIp: string;
  /** Destination IP address. */
  destinationIp: string;
  /** IP protocol in string format, for example: "TCP", "UDP", "ICMP". */
  protocol: string;
  /** Source port. Only valid when protocol is TCP or UDP. */
  sourcePort: number;
  /** Destination port. Only valid when protocol is TCP or UDP. */
  destinationPort: number;
  /** URI of the network where this packet originates from. */
  sourceNetworkUri: string;
  /** URI of the network where this packet is sent to. */
  destinationNetworkUri: string;
}

/** Details of the final state "deliver" and associated resource. */
export interface DeliverInfo {
  /** Target type where the packet is delivered to. */
  target: DeliverInfo_Target;
  /** URI of the resource that the packet is delivered to. */
  resourceUri: string;
}

/** Deliver target types: */
export enum DeliverInfo_Target {
  /** TARGET_UNSPECIFIED - Target not specified. */
  TARGET_UNSPECIFIED = 0,
  /** INSTANCE - Target is a Compute Engine instance. */
  INSTANCE = 1,
  /** INTERNET - Target is the internet. */
  INTERNET = 2,
  /** GOOGLE_API - Target is a Google API. */
  GOOGLE_API = 3,
  /** GKE_MASTER - Target is a Google Kubernetes Engine cluster master. */
  GKE_MASTER = 4,
  /** CLOUD_SQL_INSTANCE - Target is a Cloud SQL instance. */
  CLOUD_SQL_INSTANCE = 5,
  /**
   * PSC_PUBLISHED_SERVICE - Target is a published service that uses [Private Service
   * Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
   */
  PSC_PUBLISHED_SERVICE = 6,
  /**
   * PSC_GOOGLE_API - Target is all Google APIs that use [Private Service
   * Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-apis).
   */
  PSC_GOOGLE_API = 7,
  /**
   * PSC_VPC_SC - Target is a VPC-SC that uses [Private Service
   * Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-apis).
   */
  PSC_VPC_SC = 8,
  UNRECOGNIZED = -1,
}

export function deliverInfo_TargetFromJSON(object: any): DeliverInfo_Target {
  switch (object) {
    case 0:
    case "TARGET_UNSPECIFIED":
      return DeliverInfo_Target.TARGET_UNSPECIFIED;
    case 1:
    case "INSTANCE":
      return DeliverInfo_Target.INSTANCE;
    case 2:
    case "INTERNET":
      return DeliverInfo_Target.INTERNET;
    case 3:
    case "GOOGLE_API":
      return DeliverInfo_Target.GOOGLE_API;
    case 4:
    case "GKE_MASTER":
      return DeliverInfo_Target.GKE_MASTER;
    case 5:
    case "CLOUD_SQL_INSTANCE":
      return DeliverInfo_Target.CLOUD_SQL_INSTANCE;
    case 6:
    case "PSC_PUBLISHED_SERVICE":
      return DeliverInfo_Target.PSC_PUBLISHED_SERVICE;
    case 7:
    case "PSC_GOOGLE_API":
      return DeliverInfo_Target.PSC_GOOGLE_API;
    case 8:
    case "PSC_VPC_SC":
      return DeliverInfo_Target.PSC_VPC_SC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeliverInfo_Target.UNRECOGNIZED;
  }
}

export function deliverInfo_TargetToJSON(object: DeliverInfo_Target): string {
  switch (object) {
    case DeliverInfo_Target.TARGET_UNSPECIFIED:
      return "TARGET_UNSPECIFIED";
    case DeliverInfo_Target.INSTANCE:
      return "INSTANCE";
    case DeliverInfo_Target.INTERNET:
      return "INTERNET";
    case DeliverInfo_Target.GOOGLE_API:
      return "GOOGLE_API";
    case DeliverInfo_Target.GKE_MASTER:
      return "GKE_MASTER";
    case DeliverInfo_Target.CLOUD_SQL_INSTANCE:
      return "CLOUD_SQL_INSTANCE";
    case DeliverInfo_Target.PSC_PUBLISHED_SERVICE:
      return "PSC_PUBLISHED_SERVICE";
    case DeliverInfo_Target.PSC_GOOGLE_API:
      return "PSC_GOOGLE_API";
    case DeliverInfo_Target.PSC_VPC_SC:
      return "PSC_VPC_SC";
    case DeliverInfo_Target.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of the final state "forward" and associated resource. */
export interface ForwardInfo {
  /** Target type where this packet is forwarded to. */
  target: ForwardInfo_Target;
  /** URI of the resource that the packet is forwarded to. */
  resourceUri: string;
}

/** Forward target types. */
export enum ForwardInfo_Target {
  /** TARGET_UNSPECIFIED - Target not specified. */
  TARGET_UNSPECIFIED = 0,
  /** PEERING_VPC - Forwarded to a VPC peering network. */
  PEERING_VPC = 1,
  /** VPN_GATEWAY - Forwarded to a Cloud VPN gateway. */
  VPN_GATEWAY = 2,
  /** INTERCONNECT - Forwarded to a Cloud Interconnect connection. */
  INTERCONNECT = 3,
  /** GKE_MASTER - Forwarded to a Google Kubernetes Engine Container cluster master. */
  GKE_MASTER = 4,
  /** IMPORTED_CUSTOM_ROUTE_NEXT_HOP - Forwarded to the next hop of a custom route imported from a peering VPC. */
  IMPORTED_CUSTOM_ROUTE_NEXT_HOP = 5,
  /** CLOUD_SQL_INSTANCE - Forwarded to a Cloud SQL instance. */
  CLOUD_SQL_INSTANCE = 6,
  /** ANOTHER_PROJECT - Forwarded to a VPC network in another project. */
  ANOTHER_PROJECT = 7,
  UNRECOGNIZED = -1,
}

export function forwardInfo_TargetFromJSON(object: any): ForwardInfo_Target {
  switch (object) {
    case 0:
    case "TARGET_UNSPECIFIED":
      return ForwardInfo_Target.TARGET_UNSPECIFIED;
    case 1:
    case "PEERING_VPC":
      return ForwardInfo_Target.PEERING_VPC;
    case 2:
    case "VPN_GATEWAY":
      return ForwardInfo_Target.VPN_GATEWAY;
    case 3:
    case "INTERCONNECT":
      return ForwardInfo_Target.INTERCONNECT;
    case 4:
    case "GKE_MASTER":
      return ForwardInfo_Target.GKE_MASTER;
    case 5:
    case "IMPORTED_CUSTOM_ROUTE_NEXT_HOP":
      return ForwardInfo_Target.IMPORTED_CUSTOM_ROUTE_NEXT_HOP;
    case 6:
    case "CLOUD_SQL_INSTANCE":
      return ForwardInfo_Target.CLOUD_SQL_INSTANCE;
    case 7:
    case "ANOTHER_PROJECT":
      return ForwardInfo_Target.ANOTHER_PROJECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ForwardInfo_Target.UNRECOGNIZED;
  }
}

export function forwardInfo_TargetToJSON(object: ForwardInfo_Target): string {
  switch (object) {
    case ForwardInfo_Target.TARGET_UNSPECIFIED:
      return "TARGET_UNSPECIFIED";
    case ForwardInfo_Target.PEERING_VPC:
      return "PEERING_VPC";
    case ForwardInfo_Target.VPN_GATEWAY:
      return "VPN_GATEWAY";
    case ForwardInfo_Target.INTERCONNECT:
      return "INTERCONNECT";
    case ForwardInfo_Target.GKE_MASTER:
      return "GKE_MASTER";
    case ForwardInfo_Target.IMPORTED_CUSTOM_ROUTE_NEXT_HOP:
      return "IMPORTED_CUSTOM_ROUTE_NEXT_HOP";
    case ForwardInfo_Target.CLOUD_SQL_INSTANCE:
      return "CLOUD_SQL_INSTANCE";
    case ForwardInfo_Target.ANOTHER_PROJECT:
      return "ANOTHER_PROJECT";
    case ForwardInfo_Target.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of the final state "abort" and associated resource. */
export interface AbortInfo {
  /** Causes that the analysis is aborted. */
  cause: AbortInfo_Cause;
  /** URI of the resource that caused the abort. */
  resourceUri: string;
  /**
   * List of project IDs that the user has specified in the request but does
   * not have permission to access network configs. Analysis is aborted in this
   * case with the PERMISSION_DENIED cause.
   */
  projectsMissingPermission: string[];
}

/** Abort cause types: */
export enum AbortInfo_Cause {
  /** CAUSE_UNSPECIFIED - Cause is unspecified. */
  CAUSE_UNSPECIFIED = 0,
  /**
   * UNKNOWN_NETWORK - Aborted due to unknown network.
   * The reachability analysis cannot proceed because the user does not have
   * access to the host project's network configurations, including firewall
   * rules and routes. This happens when the project is a service project and
   * the endpoints being traced are in the host project's network.
   */
  UNKNOWN_NETWORK = 1,
  /** UNKNOWN_IP - Aborted because the IP address(es) are unknown. */
  UNKNOWN_IP = 2,
  /**
   * UNKNOWN_PROJECT - Aborted because no project information can be derived from the test
   * input.
   */
  UNKNOWN_PROJECT = 3,
  /**
   * PERMISSION_DENIED - Aborted because the user lacks the permission to access all or part of
   * the network configurations required to run the test.
   */
  PERMISSION_DENIED = 4,
  /**
   * NO_SOURCE_LOCATION - Aborted because no valid source endpoint is derived from the input test
   * request.
   */
  NO_SOURCE_LOCATION = 5,
  /**
   * INVALID_ARGUMENT - Aborted because the source and/or destination endpoint specified in
   * the test are invalid. The possible reasons that an endpoint is
   * invalid include: malformed IP address; nonexistent instance or
   * network URI; IP address not in the range of specified network URI; and
   * instance not owning the network interface in the specified network.
   */
  INVALID_ARGUMENT = 6,
  /**
   * NO_EXTERNAL_IP - Aborted because traffic is sent from a public IP to an instance without
   * an external IP.
   */
  NO_EXTERNAL_IP = 7,
  /**
   * UNINTENDED_DESTINATION - Aborted because none of the traces matches destination information
   * specified in the input test request.
   */
  UNINTENDED_DESTINATION = 8,
  /**
   * TRACE_TOO_LONG - Aborted because the number of steps in the trace exceeding a certain
   * limit which may be caused by routing loop.
   */
  TRACE_TOO_LONG = 9,
  /** INTERNAL_ERROR - Aborted due to internal server error. */
  INTERNAL_ERROR = 10,
  /** SOURCE_ENDPOINT_NOT_FOUND - Aborted because the source endpoint could not be found. */
  SOURCE_ENDPOINT_NOT_FOUND = 11,
  /** MISMATCHED_SOURCE_NETWORK - Aborted because the source network does not match the source endpoint. */
  MISMATCHED_SOURCE_NETWORK = 12,
  /** DESTINATION_ENDPOINT_NOT_FOUND - Aborted because the destination endpoint could not be found. */
  DESTINATION_ENDPOINT_NOT_FOUND = 13,
  /**
   * MISMATCHED_DESTINATION_NETWORK - Aborted because the destination network does not match the destination
   * endpoint.
   */
  MISMATCHED_DESTINATION_NETWORK = 14,
  /** UNSUPPORTED - Aborted because the test scenario is not supported. */
  UNSUPPORTED = 15,
  /**
   * MISMATCHED_IP_VERSION - Aborted because the source and destination resources have no common IP
   * version.
   */
  MISMATCHED_IP_VERSION = 16,
  /**
   * GKE_KONNECTIVITY_PROXY_UNSUPPORTED - Aborted because the connection between the control plane and the node of
   * the source cluster is initiated by the node and managed by the
   * Konnectivity proxy.
   */
  GKE_KONNECTIVITY_PROXY_UNSUPPORTED = 17,
  /** RESOURCE_CONFIG_NOT_FOUND - Aborted because expected resource configuration was missing. */
  RESOURCE_CONFIG_NOT_FOUND = 18,
  UNRECOGNIZED = -1,
}

export function abortInfo_CauseFromJSON(object: any): AbortInfo_Cause {
  switch (object) {
    case 0:
    case "CAUSE_UNSPECIFIED":
      return AbortInfo_Cause.CAUSE_UNSPECIFIED;
    case 1:
    case "UNKNOWN_NETWORK":
      return AbortInfo_Cause.UNKNOWN_NETWORK;
    case 2:
    case "UNKNOWN_IP":
      return AbortInfo_Cause.UNKNOWN_IP;
    case 3:
    case "UNKNOWN_PROJECT":
      return AbortInfo_Cause.UNKNOWN_PROJECT;
    case 4:
    case "PERMISSION_DENIED":
      return AbortInfo_Cause.PERMISSION_DENIED;
    case 5:
    case "NO_SOURCE_LOCATION":
      return AbortInfo_Cause.NO_SOURCE_LOCATION;
    case 6:
    case "INVALID_ARGUMENT":
      return AbortInfo_Cause.INVALID_ARGUMENT;
    case 7:
    case "NO_EXTERNAL_IP":
      return AbortInfo_Cause.NO_EXTERNAL_IP;
    case 8:
    case "UNINTENDED_DESTINATION":
      return AbortInfo_Cause.UNINTENDED_DESTINATION;
    case 9:
    case "TRACE_TOO_LONG":
      return AbortInfo_Cause.TRACE_TOO_LONG;
    case 10:
    case "INTERNAL_ERROR":
      return AbortInfo_Cause.INTERNAL_ERROR;
    case 11:
    case "SOURCE_ENDPOINT_NOT_FOUND":
      return AbortInfo_Cause.SOURCE_ENDPOINT_NOT_FOUND;
    case 12:
    case "MISMATCHED_SOURCE_NETWORK":
      return AbortInfo_Cause.MISMATCHED_SOURCE_NETWORK;
    case 13:
    case "DESTINATION_ENDPOINT_NOT_FOUND":
      return AbortInfo_Cause.DESTINATION_ENDPOINT_NOT_FOUND;
    case 14:
    case "MISMATCHED_DESTINATION_NETWORK":
      return AbortInfo_Cause.MISMATCHED_DESTINATION_NETWORK;
    case 15:
    case "UNSUPPORTED":
      return AbortInfo_Cause.UNSUPPORTED;
    case 16:
    case "MISMATCHED_IP_VERSION":
      return AbortInfo_Cause.MISMATCHED_IP_VERSION;
    case 17:
    case "GKE_KONNECTIVITY_PROXY_UNSUPPORTED":
      return AbortInfo_Cause.GKE_KONNECTIVITY_PROXY_UNSUPPORTED;
    case 18:
    case "RESOURCE_CONFIG_NOT_FOUND":
      return AbortInfo_Cause.RESOURCE_CONFIG_NOT_FOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AbortInfo_Cause.UNRECOGNIZED;
  }
}

export function abortInfo_CauseToJSON(object: AbortInfo_Cause): string {
  switch (object) {
    case AbortInfo_Cause.CAUSE_UNSPECIFIED:
      return "CAUSE_UNSPECIFIED";
    case AbortInfo_Cause.UNKNOWN_NETWORK:
      return "UNKNOWN_NETWORK";
    case AbortInfo_Cause.UNKNOWN_IP:
      return "UNKNOWN_IP";
    case AbortInfo_Cause.UNKNOWN_PROJECT:
      return "UNKNOWN_PROJECT";
    case AbortInfo_Cause.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case AbortInfo_Cause.NO_SOURCE_LOCATION:
      return "NO_SOURCE_LOCATION";
    case AbortInfo_Cause.INVALID_ARGUMENT:
      return "INVALID_ARGUMENT";
    case AbortInfo_Cause.NO_EXTERNAL_IP:
      return "NO_EXTERNAL_IP";
    case AbortInfo_Cause.UNINTENDED_DESTINATION:
      return "UNINTENDED_DESTINATION";
    case AbortInfo_Cause.TRACE_TOO_LONG:
      return "TRACE_TOO_LONG";
    case AbortInfo_Cause.INTERNAL_ERROR:
      return "INTERNAL_ERROR";
    case AbortInfo_Cause.SOURCE_ENDPOINT_NOT_FOUND:
      return "SOURCE_ENDPOINT_NOT_FOUND";
    case AbortInfo_Cause.MISMATCHED_SOURCE_NETWORK:
      return "MISMATCHED_SOURCE_NETWORK";
    case AbortInfo_Cause.DESTINATION_ENDPOINT_NOT_FOUND:
      return "DESTINATION_ENDPOINT_NOT_FOUND";
    case AbortInfo_Cause.MISMATCHED_DESTINATION_NETWORK:
      return "MISMATCHED_DESTINATION_NETWORK";
    case AbortInfo_Cause.UNSUPPORTED:
      return "UNSUPPORTED";
    case AbortInfo_Cause.MISMATCHED_IP_VERSION:
      return "MISMATCHED_IP_VERSION";
    case AbortInfo_Cause.GKE_KONNECTIVITY_PROXY_UNSUPPORTED:
      return "GKE_KONNECTIVITY_PROXY_UNSUPPORTED";
    case AbortInfo_Cause.RESOURCE_CONFIG_NOT_FOUND:
      return "RESOURCE_CONFIG_NOT_FOUND";
    case AbortInfo_Cause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of the final state "drop" and associated resource. */
export interface DropInfo {
  /** Cause that the packet is dropped. */
  cause: DropInfo_Cause;
  /** URI of the resource that caused the drop. */
  resourceUri: string;
}

/** Drop cause types: */
export enum DropInfo_Cause {
  /** CAUSE_UNSPECIFIED - Cause is unspecified. */
  CAUSE_UNSPECIFIED = 0,
  /**
   * UNKNOWN_EXTERNAL_ADDRESS - Destination external address cannot be resolved to a known target. If
   * the address is used in a Google Cloud project, provide the project ID
   * as test input.
   */
  UNKNOWN_EXTERNAL_ADDRESS = 1,
  /**
   * FOREIGN_IP_DISALLOWED - A Compute Engine instance can only send or receive a packet with a
   * foreign IP address if ip_forward is enabled.
   */
  FOREIGN_IP_DISALLOWED = 2,
  /**
   * FIREWALL_RULE - Dropped due to a firewall rule, unless allowed due to connection
   * tracking.
   */
  FIREWALL_RULE = 3,
  /** NO_ROUTE - Dropped due to no routes. */
  NO_ROUTE = 4,
  /** ROUTE_BLACKHOLE - Dropped due to invalid route. Route's next hop is a blackhole. */
  ROUTE_BLACKHOLE = 5,
  /**
   * ROUTE_WRONG_NETWORK - Packet is sent to a wrong (unintended) network. Example: you trace a
   * packet from VM1:Network1 to VM2:Network2, however, the route configured
   * in Network1 sends the packet destined for VM2's IP addresss to Network3.
   */
  ROUTE_WRONG_NETWORK = 6,
  /** PRIVATE_TRAFFIC_TO_INTERNET - Packet with internal destination address sent to the internet gateway. */
  PRIVATE_TRAFFIC_TO_INTERNET = 7,
  /**
   * PRIVATE_GOOGLE_ACCESS_DISALLOWED - Instance with only an internal IP address tries to access Google API and
   * services, but private Google access is not enabled.
   */
  PRIVATE_GOOGLE_ACCESS_DISALLOWED = 8,
  /**
   * NO_EXTERNAL_ADDRESS - Instance with only an internal IP address tries to access external hosts,
   * but Cloud NAT is not enabled in the subnet, unless special configurations
   * on a VM allow this connection.
   */
  NO_EXTERNAL_ADDRESS = 9,
  /**
   * UNKNOWN_INTERNAL_ADDRESS - Destination internal address cannot be resolved to a known target. If
   * this is a shared VPC scenario, verify if the service project ID is
   * provided as test input. Otherwise, verify if the IP address is being
   * used in the project.
   */
  UNKNOWN_INTERNAL_ADDRESS = 10,
  /** FORWARDING_RULE_MISMATCH - Forwarding rule's protocol and ports do not match the packet header. */
  FORWARDING_RULE_MISMATCH = 11,
  /**
   * FORWARDING_RULE_REGION_MISMATCH - Packet could be dropped because it was sent from a different region
   * to a regional forwarding without global access.
   */
  FORWARDING_RULE_REGION_MISMATCH = 25,
  /** FORWARDING_RULE_NO_INSTANCES - Forwarding rule does not have backends configured. */
  FORWARDING_RULE_NO_INSTANCES = 12,
  /**
   * FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK - Firewalls block the health check probes to the backends and cause
   * the backends to be unavailable for traffic from the load balancer.
   * For more details, see [Health check firewall
   * rules](https://cloud.google.com/load-balancing/docs/health-checks#firewall_rules).
   */
  FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK = 13,
  /**
   * INSTANCE_NOT_RUNNING - Packet is sent from or to a Compute Engine instance that is not in a
   * running state.
   */
  INSTANCE_NOT_RUNNING = 14,
  /** GKE_CLUSTER_NOT_RUNNING - Packet sent from or to a GKE cluster that is not in running state. */
  GKE_CLUSTER_NOT_RUNNING = 27,
  /** CLOUD_SQL_INSTANCE_NOT_RUNNING - Packet sent from or to a Cloud SQL instance that is not in running state. */
  CLOUD_SQL_INSTANCE_NOT_RUNNING = 28,
  /**
   * TRAFFIC_TYPE_BLOCKED - The type of traffic is blocked and the user cannot configure a firewall
   * rule to enable it. See [Always blocked
   * traffic](https://cloud.google.com/vpc/docs/firewalls#blockedtraffic) for
   * more details.
   */
  TRAFFIC_TYPE_BLOCKED = 15,
  /**
   * GKE_MASTER_UNAUTHORIZED_ACCESS - Access to Google Kubernetes Engine cluster master's endpoint is not
   * authorized. See [Access to the cluster
   * endpoints](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#access_to_the_cluster_endpoints)
   * for more details.
   */
  GKE_MASTER_UNAUTHORIZED_ACCESS = 16,
  /**
   * CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS - Access to the Cloud SQL instance endpoint is not authorized.
   * See [Authorizing with authorized
   * networks](https://cloud.google.com/sql/docs/mysql/authorize-networks) for
   * more details.
   */
  CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS = 17,
  /** DROPPED_INSIDE_GKE_SERVICE - Packet was dropped inside Google Kubernetes Engine Service. */
  DROPPED_INSIDE_GKE_SERVICE = 18,
  /** DROPPED_INSIDE_CLOUD_SQL_SERVICE - Packet was dropped inside Cloud SQL Service. */
  DROPPED_INSIDE_CLOUD_SQL_SERVICE = 19,
  /**
   * GOOGLE_MANAGED_SERVICE_NO_PEERING - Packet was dropped because there is no peering between the originating
   * network and the Google Managed Services Network.
   */
  GOOGLE_MANAGED_SERVICE_NO_PEERING = 20,
  /**
   * GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT - Packet was dropped because the Google-managed service uses Private
   * Service Connect (PSC), but the PSC endpoint is not found in the project.
   */
  GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT = 38,
  /**
   * GKE_PSC_ENDPOINT_MISSING - Packet was dropped because the GKE cluster uses Private Service Connect
   * (PSC), but the PSC endpoint is not found in the project.
   */
  GKE_PSC_ENDPOINT_MISSING = 36,
  /**
   * CLOUD_SQL_INSTANCE_NO_IP_ADDRESS - Packet was dropped because the Cloud SQL instance has neither a private
   * nor a public IP address.
   */
  CLOUD_SQL_INSTANCE_NO_IP_ADDRESS = 21,
  /**
   * GKE_CONTROL_PLANE_REGION_MISMATCH - Packet was dropped because a GKE cluster private endpoint is
   * unreachable from a region different from the cluster's region.
   */
  GKE_CONTROL_PLANE_REGION_MISMATCH = 30,
  /**
   * PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION - Packet sent from a public GKE cluster control plane to a private
   * IP address.
   */
  PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION = 31,
  /**
   * GKE_CONTROL_PLANE_NO_ROUTE - Packet was dropped because there is no route from a GKE cluster
   * control plane to a destination network.
   */
  GKE_CONTROL_PLANE_NO_ROUTE = 32,
  /**
   * CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC - Packet sent from a Cloud SQL instance to an external IP address is not
   * allowed. The Cloud SQL instance is not configured to send packets to
   * external IP addresses.
   */
  CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC = 33,
  /**
   * PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION - Packet sent from a Cloud SQL instance with only a public IP address to a
   * private IP address.
   */
  PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION = 34,
  /**
   * CLOUD_SQL_INSTANCE_NO_ROUTE - Packet was dropped because there is no route from a Cloud SQL
   * instance to a destination network.
   */
  CLOUD_SQL_INSTANCE_NO_ROUTE = 35,
  /**
   * CLOUD_FUNCTION_NOT_ACTIVE - Packet could be dropped because the Cloud Function is not in an active
   * status.
   */
  CLOUD_FUNCTION_NOT_ACTIVE = 22,
  /** VPC_CONNECTOR_NOT_SET - Packet could be dropped because no VPC connector is set. */
  VPC_CONNECTOR_NOT_SET = 23,
  /**
   * VPC_CONNECTOR_NOT_RUNNING - Packet could be dropped because the VPC connector is not in a running
   * state.
   */
  VPC_CONNECTOR_NOT_RUNNING = 24,
  /**
   * PSC_CONNECTION_NOT_ACCEPTED - The Private Service Connect endpoint is in a project that is not approved
   * to connect to the service.
   */
  PSC_CONNECTION_NOT_ACCEPTED = 26,
  /** CLOUD_RUN_REVISION_NOT_READY - Packet sent from a Cloud Run revision that is not ready. */
  CLOUD_RUN_REVISION_NOT_READY = 29,
  /** DROPPED_INSIDE_PSC_SERVICE_PRODUCER - Packet was dropped inside Private Service Connect service producer. */
  DROPPED_INSIDE_PSC_SERVICE_PRODUCER = 37,
  /**
   * LOAD_BALANCER_HAS_NO_PROXY_SUBNET - Packet sent to a load balancer, which requires a proxy-only subnet and
   * the subnet is not found.
   */
  LOAD_BALANCER_HAS_NO_PROXY_SUBNET = 39,
  UNRECOGNIZED = -1,
}

export function dropInfo_CauseFromJSON(object: any): DropInfo_Cause {
  switch (object) {
    case 0:
    case "CAUSE_UNSPECIFIED":
      return DropInfo_Cause.CAUSE_UNSPECIFIED;
    case 1:
    case "UNKNOWN_EXTERNAL_ADDRESS":
      return DropInfo_Cause.UNKNOWN_EXTERNAL_ADDRESS;
    case 2:
    case "FOREIGN_IP_DISALLOWED":
      return DropInfo_Cause.FOREIGN_IP_DISALLOWED;
    case 3:
    case "FIREWALL_RULE":
      return DropInfo_Cause.FIREWALL_RULE;
    case 4:
    case "NO_ROUTE":
      return DropInfo_Cause.NO_ROUTE;
    case 5:
    case "ROUTE_BLACKHOLE":
      return DropInfo_Cause.ROUTE_BLACKHOLE;
    case 6:
    case "ROUTE_WRONG_NETWORK":
      return DropInfo_Cause.ROUTE_WRONG_NETWORK;
    case 7:
    case "PRIVATE_TRAFFIC_TO_INTERNET":
      return DropInfo_Cause.PRIVATE_TRAFFIC_TO_INTERNET;
    case 8:
    case "PRIVATE_GOOGLE_ACCESS_DISALLOWED":
      return DropInfo_Cause.PRIVATE_GOOGLE_ACCESS_DISALLOWED;
    case 9:
    case "NO_EXTERNAL_ADDRESS":
      return DropInfo_Cause.NO_EXTERNAL_ADDRESS;
    case 10:
    case "UNKNOWN_INTERNAL_ADDRESS":
      return DropInfo_Cause.UNKNOWN_INTERNAL_ADDRESS;
    case 11:
    case "FORWARDING_RULE_MISMATCH":
      return DropInfo_Cause.FORWARDING_RULE_MISMATCH;
    case 25:
    case "FORWARDING_RULE_REGION_MISMATCH":
      return DropInfo_Cause.FORWARDING_RULE_REGION_MISMATCH;
    case 12:
    case "FORWARDING_RULE_NO_INSTANCES":
      return DropInfo_Cause.FORWARDING_RULE_NO_INSTANCES;
    case 13:
    case "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK":
      return DropInfo_Cause.FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK;
    case 14:
    case "INSTANCE_NOT_RUNNING":
      return DropInfo_Cause.INSTANCE_NOT_RUNNING;
    case 27:
    case "GKE_CLUSTER_NOT_RUNNING":
      return DropInfo_Cause.GKE_CLUSTER_NOT_RUNNING;
    case 28:
    case "CLOUD_SQL_INSTANCE_NOT_RUNNING":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_NOT_RUNNING;
    case 15:
    case "TRAFFIC_TYPE_BLOCKED":
      return DropInfo_Cause.TRAFFIC_TYPE_BLOCKED;
    case 16:
    case "GKE_MASTER_UNAUTHORIZED_ACCESS":
      return DropInfo_Cause.GKE_MASTER_UNAUTHORIZED_ACCESS;
    case 17:
    case "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS;
    case 18:
    case "DROPPED_INSIDE_GKE_SERVICE":
      return DropInfo_Cause.DROPPED_INSIDE_GKE_SERVICE;
    case 19:
    case "DROPPED_INSIDE_CLOUD_SQL_SERVICE":
      return DropInfo_Cause.DROPPED_INSIDE_CLOUD_SQL_SERVICE;
    case 20:
    case "GOOGLE_MANAGED_SERVICE_NO_PEERING":
      return DropInfo_Cause.GOOGLE_MANAGED_SERVICE_NO_PEERING;
    case 38:
    case "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT":
      return DropInfo_Cause.GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT;
    case 36:
    case "GKE_PSC_ENDPOINT_MISSING":
      return DropInfo_Cause.GKE_PSC_ENDPOINT_MISSING;
    case 21:
    case "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_NO_IP_ADDRESS;
    case 30:
    case "GKE_CONTROL_PLANE_REGION_MISMATCH":
      return DropInfo_Cause.GKE_CONTROL_PLANE_REGION_MISMATCH;
    case 31:
    case "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION":
      return DropInfo_Cause.PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION;
    case 32:
    case "GKE_CONTROL_PLANE_NO_ROUTE":
      return DropInfo_Cause.GKE_CONTROL_PLANE_NO_ROUTE;
    case 33:
    case "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC;
    case 34:
    case "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION":
      return DropInfo_Cause.PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION;
    case 35:
    case "CLOUD_SQL_INSTANCE_NO_ROUTE":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_NO_ROUTE;
    case 22:
    case "CLOUD_FUNCTION_NOT_ACTIVE":
      return DropInfo_Cause.CLOUD_FUNCTION_NOT_ACTIVE;
    case 23:
    case "VPC_CONNECTOR_NOT_SET":
      return DropInfo_Cause.VPC_CONNECTOR_NOT_SET;
    case 24:
    case "VPC_CONNECTOR_NOT_RUNNING":
      return DropInfo_Cause.VPC_CONNECTOR_NOT_RUNNING;
    case 26:
    case "PSC_CONNECTION_NOT_ACCEPTED":
      return DropInfo_Cause.PSC_CONNECTION_NOT_ACCEPTED;
    case 29:
    case "CLOUD_RUN_REVISION_NOT_READY":
      return DropInfo_Cause.CLOUD_RUN_REVISION_NOT_READY;
    case 37:
    case "DROPPED_INSIDE_PSC_SERVICE_PRODUCER":
      return DropInfo_Cause.DROPPED_INSIDE_PSC_SERVICE_PRODUCER;
    case 39:
    case "LOAD_BALANCER_HAS_NO_PROXY_SUBNET":
      return DropInfo_Cause.LOAD_BALANCER_HAS_NO_PROXY_SUBNET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DropInfo_Cause.UNRECOGNIZED;
  }
}

export function dropInfo_CauseToJSON(object: DropInfo_Cause): string {
  switch (object) {
    case DropInfo_Cause.CAUSE_UNSPECIFIED:
      return "CAUSE_UNSPECIFIED";
    case DropInfo_Cause.UNKNOWN_EXTERNAL_ADDRESS:
      return "UNKNOWN_EXTERNAL_ADDRESS";
    case DropInfo_Cause.FOREIGN_IP_DISALLOWED:
      return "FOREIGN_IP_DISALLOWED";
    case DropInfo_Cause.FIREWALL_RULE:
      return "FIREWALL_RULE";
    case DropInfo_Cause.NO_ROUTE:
      return "NO_ROUTE";
    case DropInfo_Cause.ROUTE_BLACKHOLE:
      return "ROUTE_BLACKHOLE";
    case DropInfo_Cause.ROUTE_WRONG_NETWORK:
      return "ROUTE_WRONG_NETWORK";
    case DropInfo_Cause.PRIVATE_TRAFFIC_TO_INTERNET:
      return "PRIVATE_TRAFFIC_TO_INTERNET";
    case DropInfo_Cause.PRIVATE_GOOGLE_ACCESS_DISALLOWED:
      return "PRIVATE_GOOGLE_ACCESS_DISALLOWED";
    case DropInfo_Cause.NO_EXTERNAL_ADDRESS:
      return "NO_EXTERNAL_ADDRESS";
    case DropInfo_Cause.UNKNOWN_INTERNAL_ADDRESS:
      return "UNKNOWN_INTERNAL_ADDRESS";
    case DropInfo_Cause.FORWARDING_RULE_MISMATCH:
      return "FORWARDING_RULE_MISMATCH";
    case DropInfo_Cause.FORWARDING_RULE_REGION_MISMATCH:
      return "FORWARDING_RULE_REGION_MISMATCH";
    case DropInfo_Cause.FORWARDING_RULE_NO_INSTANCES:
      return "FORWARDING_RULE_NO_INSTANCES";
    case DropInfo_Cause.FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK:
      return "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK";
    case DropInfo_Cause.INSTANCE_NOT_RUNNING:
      return "INSTANCE_NOT_RUNNING";
    case DropInfo_Cause.GKE_CLUSTER_NOT_RUNNING:
      return "GKE_CLUSTER_NOT_RUNNING";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_NOT_RUNNING:
      return "CLOUD_SQL_INSTANCE_NOT_RUNNING";
    case DropInfo_Cause.TRAFFIC_TYPE_BLOCKED:
      return "TRAFFIC_TYPE_BLOCKED";
    case DropInfo_Cause.GKE_MASTER_UNAUTHORIZED_ACCESS:
      return "GKE_MASTER_UNAUTHORIZED_ACCESS";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS:
      return "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS";
    case DropInfo_Cause.DROPPED_INSIDE_GKE_SERVICE:
      return "DROPPED_INSIDE_GKE_SERVICE";
    case DropInfo_Cause.DROPPED_INSIDE_CLOUD_SQL_SERVICE:
      return "DROPPED_INSIDE_CLOUD_SQL_SERVICE";
    case DropInfo_Cause.GOOGLE_MANAGED_SERVICE_NO_PEERING:
      return "GOOGLE_MANAGED_SERVICE_NO_PEERING";
    case DropInfo_Cause.GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT:
      return "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT";
    case DropInfo_Cause.GKE_PSC_ENDPOINT_MISSING:
      return "GKE_PSC_ENDPOINT_MISSING";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_NO_IP_ADDRESS:
      return "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS";
    case DropInfo_Cause.GKE_CONTROL_PLANE_REGION_MISMATCH:
      return "GKE_CONTROL_PLANE_REGION_MISMATCH";
    case DropInfo_Cause.PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION:
      return "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION";
    case DropInfo_Cause.GKE_CONTROL_PLANE_NO_ROUTE:
      return "GKE_CONTROL_PLANE_NO_ROUTE";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC:
      return "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC";
    case DropInfo_Cause.PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION:
      return "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_NO_ROUTE:
      return "CLOUD_SQL_INSTANCE_NO_ROUTE";
    case DropInfo_Cause.CLOUD_FUNCTION_NOT_ACTIVE:
      return "CLOUD_FUNCTION_NOT_ACTIVE";
    case DropInfo_Cause.VPC_CONNECTOR_NOT_SET:
      return "VPC_CONNECTOR_NOT_SET";
    case DropInfo_Cause.VPC_CONNECTOR_NOT_RUNNING:
      return "VPC_CONNECTOR_NOT_RUNNING";
    case DropInfo_Cause.PSC_CONNECTION_NOT_ACCEPTED:
      return "PSC_CONNECTION_NOT_ACCEPTED";
    case DropInfo_Cause.CLOUD_RUN_REVISION_NOT_READY:
      return "CLOUD_RUN_REVISION_NOT_READY";
    case DropInfo_Cause.DROPPED_INSIDE_PSC_SERVICE_PRODUCER:
      return "DROPPED_INSIDE_PSC_SERVICE_PRODUCER";
    case DropInfo_Cause.LOAD_BALANCER_HAS_NO_PROXY_SUBNET:
      return "LOAD_BALANCER_HAS_NO_PROXY_SUBNET";
    case DropInfo_Cause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * For display only. Metadata associated with a Google Kubernetes Engine (GKE)
 * cluster master.
 */
export interface GKEMasterInfo {
  /** URI of a GKE cluster. */
  clusterUri: string;
  /** URI of a GKE cluster network. */
  clusterNetworkUri: string;
  /** Internal IP address of a GKE cluster master. */
  internalIp: string;
  /** External IP address of a GKE cluster master. */
  externalIp: string;
}

/** For display only. Metadata associated with a Cloud SQL instance. */
export interface CloudSQLInstanceInfo {
  /** Name of a Cloud SQL instance. */
  displayName: string;
  /** URI of a Cloud SQL instance. */
  uri: string;
  /**
   * URI of a Cloud SQL instance network or empty string if the instance does
   * not have one.
   */
  networkUri: string;
  /** Internal IP address of a Cloud SQL instance. */
  internalIp: string;
  /** External IP address of a Cloud SQL instance. */
  externalIp: string;
  /** Region in which the Cloud SQL instance is running. */
  region: string;
}

/** For display only. Metadata associated with a Cloud Function. */
export interface CloudFunctionInfo {
  /** Name of a Cloud Function. */
  displayName: string;
  /** URI of a Cloud Function. */
  uri: string;
  /** Location in which the Cloud Function is deployed. */
  location: string;
  /** Latest successfully deployed version id of the Cloud Function. */
  versionId: Long;
}

/** For display only. Metadata associated with a Cloud Run revision. */
export interface CloudRunRevisionInfo {
  /** Name of a Cloud Run revision. */
  displayName: string;
  /** URI of a Cloud Run revision. */
  uri: string;
  /** Location in which this revision is deployed. */
  location: string;
  /** URI of Cloud Run service this revision belongs to. */
  serviceUri: string;
}

/** For display only. Metadata associated with an App Engine version. */
export interface AppEngineVersionInfo {
  /** Name of an App Engine version. */
  displayName: string;
  /** URI of an App Engine version. */
  uri: string;
  /** Runtime of the App Engine version. */
  runtime: string;
  /** App Engine execution environment for a version. */
  environment: string;
}

/** For display only. Metadata associated with a VPC connector. */
export interface VpcConnectorInfo {
  /** Name of a VPC connector. */
  displayName: string;
  /** URI of a VPC connector. */
  uri: string;
  /** Location in which the VPC connector is deployed. */
  location: string;
}

/** A Connectivity Test for a network reachability analysis. */
export interface ConnectivityTest {
  /**
   * Required. Unique name of the resource using the form:
   *     `projects/{project_id}/locations/global/connectivityTests/{test_id}`
   */
  name: string;
  /**
   * The user-supplied description of the Connectivity Test.
   * Maximum of 512 characters.
   */
  description: string;
  /**
   * Required. Source specification of the Connectivity Test.
   *
   * You can use a combination of source IP address, virtual machine
   * (VM) instance, or Compute Engine network to uniquely identify
   * the source location.
   *
   * Examples:
   * If the source IP address is an internal IP address within a Google Cloud
   * Virtual Private Cloud (VPC) network, then you must also specify the VPC
   * network. Otherwise, specify the VM instance, which already contains its
   * internal IP address and VPC network information.
   *
   * If the source of the test is within an on-premises network, then you must
   * provide the destination VPC network.
   *
   * If the source endpoint is a Compute Engine VM instance with multiple
   * network interfaces, the instance itself is not sufficient to identify the
   * endpoint. So, you must also specify the source IP address or VPC network.
   *
   * A reachability analysis proceeds even if the source location is
   * ambiguous. However, the test result may include endpoints that you don't
   * intend to test.
   */
  source?:
    | Endpoint
    | undefined;
  /**
   * Required. Destination specification of the Connectivity Test.
   *
   * You can use a combination of destination IP address, Compute Engine
   * VM instance, or VPC network to uniquely identify the destination
   * location.
   *
   * Even if the destination IP address is not unique, the source IP
   * location is unique. Usually, the analysis can infer the destination
   * endpoint from route information.
   *
   * If the destination you specify is a VM instance and the instance has
   * multiple network interfaces, then you must also specify either
   * a destination IP address  or VPC network to identify the destination
   * interface.
   *
   * A reachability analysis proceeds even if the destination location is
   * ambiguous. However, the result can include endpoints that you don't
   * intend to test.
   */
  destination?:
    | Endpoint
    | undefined;
  /** IP Protocol of the test. When not provided, "TCP" is assumed. */
  protocol: string;
  /**
   * Other projects that may be relevant for reachability analysis.
   * This is applicable to scenarios where a test can cross project boundaries.
   */
  relatedProjects: string[];
  /** Output only. The display name of a Connectivity Test. */
  displayName: string;
  /** Resource labels to represent user-provided metadata. */
  labels: { [key: string]: string };
  /** Output only. The time the test was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time the test's configuration was updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Output only. The reachability details of this test from the latest run.
   * The details are updated when creating a new test, updating an
   * existing test, or triggering a one-time rerun of an existing test.
   */
  reachabilityDetails?: ReachabilityDetails | undefined;
}

export interface ConnectivityTest_LabelsEntry {
  key: string;
  value: string;
}

/** Source or destination of the Connectivity Test. */
export interface Endpoint {
  /**
   * The IP address of the endpoint, which can be an external or internal IP.
   * An IPv6 address is only allowed when the test's destination is a
   * [global load balancer VIP](/load-balancing/docs/load-balancing-overview).
   */
  ipAddress: string;
  /**
   * The IP protocol port of the endpoint.
   * Only applicable when protocol is TCP or UDP.
   */
  port: number;
  /** A Compute Engine instance URI. */
  instance: string;
  /**
   * A cluster URI for [Google Kubernetes Engine
   * master](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).
   */
  gkeMasterCluster: string;
  /** A [Cloud SQL](https://cloud.google.com/sql) instance URI. */
  cloudSqlInstance: string;
  /** A [Cloud Function](https://cloud.google.com/functions). */
  cloudFunction?:
    | Endpoint_CloudFunctionEndpoint
    | undefined;
  /**
   * An [App Engine](https://cloud.google.com/appengine) [service
   * version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions).
   */
  appEngineVersion?:
    | Endpoint_AppEngineVersionEndpoint
    | undefined;
  /**
   * A [Cloud Run](https://cloud.google.com/run)
   * [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
   */
  cloudRunRevision?:
    | Endpoint_CloudRunRevisionEndpoint
    | undefined;
  /** A Compute Engine network URI. */
  network: string;
  /**
   * Type of the network where the endpoint is located.
   * Applicable only to source endpoint, as destination network type can be
   * inferred from the source.
   */
  networkType: Endpoint_NetworkType;
  /**
   * Project ID where the endpoint is located.
   * The Project ID can be derived from the URI if you provide a VM instance or
   * network URI.
   * The following are two cases where you must provide the project ID:
   * 1. Only the IP address is specified, and the IP address is within a Google
   * Cloud project.
   * 2. When you are using Shared VPC and the IP address that you provide is
   * from the service project. In this case, the network that the IP address
   * resides in is defined in the host project.
   */
  projectId: string;
}

/**
 * The type definition of an endpoint's network. Use one of the
 * following choices:
 */
export enum Endpoint_NetworkType {
  /** NETWORK_TYPE_UNSPECIFIED - Default type if unspecified. */
  NETWORK_TYPE_UNSPECIFIED = 0,
  /**
   * GCP_NETWORK - A network hosted within Google Cloud.
   * To receive more detailed output, specify the URI for the source or
   * destination network.
   */
  GCP_NETWORK = 1,
  /**
   * NON_GCP_NETWORK - A network hosted outside of Google Cloud.
   * This can be an on-premises network, or a network hosted by another cloud
   * provider.
   */
  NON_GCP_NETWORK = 2,
  UNRECOGNIZED = -1,
}

export function endpoint_NetworkTypeFromJSON(object: any): Endpoint_NetworkType {
  switch (object) {
    case 0:
    case "NETWORK_TYPE_UNSPECIFIED":
      return Endpoint_NetworkType.NETWORK_TYPE_UNSPECIFIED;
    case 1:
    case "GCP_NETWORK":
      return Endpoint_NetworkType.GCP_NETWORK;
    case 2:
    case "NON_GCP_NETWORK":
      return Endpoint_NetworkType.NON_GCP_NETWORK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Endpoint_NetworkType.UNRECOGNIZED;
  }
}

export function endpoint_NetworkTypeToJSON(object: Endpoint_NetworkType): string {
  switch (object) {
    case Endpoint_NetworkType.NETWORK_TYPE_UNSPECIFIED:
      return "NETWORK_TYPE_UNSPECIFIED";
    case Endpoint_NetworkType.GCP_NETWORK:
      return "GCP_NETWORK";
    case Endpoint_NetworkType.NON_GCP_NETWORK:
      return "NON_GCP_NETWORK";
    case Endpoint_NetworkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Wrapper for Cloud Function attributes. */
export interface Endpoint_CloudFunctionEndpoint {
  /** A [Cloud Function](https://cloud.google.com/functions) name. */
  uri: string;
}

/** Wrapper for the App Engine service version attributes. */
export interface Endpoint_AppEngineVersionEndpoint {
  /**
   * An [App Engine](https://cloud.google.com/appengine) [service
   * version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions)
   * name.
   */
  uri: string;
}

/** Wrapper for Cloud Run revision attributes. */
export interface Endpoint_CloudRunRevisionEndpoint {
  /**
   * A [Cloud Run](https://cloud.google.com/run)
   * [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
   * URI. The format is:
   * projects/{project}/locations/{location}/revisions/{revision}
   */
  uri: string;
}

/** Results of the configuration analysis from the last run of the test. */
export interface ReachabilityDetails {
  /** The overall result of the test's configuration analysis. */
  result: ReachabilityDetails_Result;
  /** The time of the configuration analysis. */
  verifyTime?:
    | Date
    | undefined;
  /** The details of a failure or a cancellation of reachability analysis. */
  error?:
    | Status
    | undefined;
  /**
   * Result may contain a list of traces if a test has multiple possible
   * paths in the network, such as when destination endpoint is a load balancer
   * with multiple backends.
   */
  traces: Trace[];
}

/** The overall result of the test's configuration analysis. */
export enum ReachabilityDetails_Result {
  /** RESULT_UNSPECIFIED - No result was specified. */
  RESULT_UNSPECIFIED = 0,
  /**
   * REACHABLE - Possible scenarios are:
   *
   * * The configuration analysis determined that a packet originating from
   *   the source is expected to reach the destination.
   * * The analysis didn't complete because the user lacks permission for
   *   some of the resources in the trace. However, at the time the user's
   *   permission became insufficient, the trace had been successful so far.
   */
  REACHABLE = 1,
  /**
   * UNREACHABLE - A packet originating from the source is expected to be dropped before
   * reaching the destination.
   */
  UNREACHABLE = 2,
  /**
   * AMBIGUOUS - The source and destination endpoints do not uniquely identify
   * the test location in the network, and the reachability result contains
   * multiple traces. For some traces, a packet could be delivered, and for
   * others, it would not be.
   */
  AMBIGUOUS = 4,
  /**
   * UNDETERMINED - The configuration analysis did not complete. Possible reasons are:
   *
   * * A permissions error occurred--for example, the user might not have
   *   read permission for all of the resources named in the test.
   * * An internal error occurred.
   * * The analyzer received an invalid or unsupported argument or was unable
   *   to identify a known endpoint.
   */
  UNDETERMINED = 5,
  UNRECOGNIZED = -1,
}

export function reachabilityDetails_ResultFromJSON(object: any): ReachabilityDetails_Result {
  switch (object) {
    case 0:
    case "RESULT_UNSPECIFIED":
      return ReachabilityDetails_Result.RESULT_UNSPECIFIED;
    case 1:
    case "REACHABLE":
      return ReachabilityDetails_Result.REACHABLE;
    case 2:
    case "UNREACHABLE":
      return ReachabilityDetails_Result.UNREACHABLE;
    case 4:
    case "AMBIGUOUS":
      return ReachabilityDetails_Result.AMBIGUOUS;
    case 5:
    case "UNDETERMINED":
      return ReachabilityDetails_Result.UNDETERMINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReachabilityDetails_Result.UNRECOGNIZED;
  }
}

export function reachabilityDetails_ResultToJSON(object: ReachabilityDetails_Result): string {
  switch (object) {
    case ReachabilityDetails_Result.RESULT_UNSPECIFIED:
      return "RESULT_UNSPECIFIED";
    case ReachabilityDetails_Result.REACHABLE:
      return "REACHABLE";
    case ReachabilityDetails_Result.UNREACHABLE:
      return "UNREACHABLE";
    case ReachabilityDetails_Result.AMBIGUOUS:
      return "AMBIGUOUS";
    case ReachabilityDetails_Result.UNDETERMINED:
      return "UNDETERMINED";
    case ReachabilityDetails_Result.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The data within all ConnectivityTest events. */
export interface ConnectivityTestEventData {
  /** Optional. The ConnectivityTest event payload. Unset for deletion events. */
  payload?: ConnectivityTest | undefined;
}

function createBaseTrace(): Trace {
  return { endpointInfo: undefined, steps: [] };
}

export const Trace: MessageFns<Trace> = {
  encode(message: Trace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpointInfo !== undefined) {
      EndpointInfo.encode(message.endpointInfo, writer.uint32(10).fork()).join();
    }
    for (const v of message.steps) {
      Step.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpointInfo = EndpointInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.steps.push(Step.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trace {
    return {
      endpointInfo: isSet(object.endpointInfo) ? EndpointInfo.fromJSON(object.endpointInfo) : undefined,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => Step.fromJSON(e)) : [],
    };
  },

  toJSON(message: Trace): unknown {
    const obj: any = {};
    if (message.endpointInfo !== undefined) {
      obj.endpointInfo = EndpointInfo.toJSON(message.endpointInfo);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => Step.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trace>, I>>(base?: I): Trace {
    return Trace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trace>, I>>(object: I): Trace {
    const message = createBaseTrace();
    message.endpointInfo = (object.endpointInfo !== undefined && object.endpointInfo !== null)
      ? EndpointInfo.fromPartial(object.endpointInfo)
      : undefined;
    message.steps = object.steps?.map((e) => Step.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStep(): Step {
  return {
    description: "",
    state: 0,
    causesDrop: false,
    projectId: "",
    instance: undefined,
    firewall: undefined,
    route: undefined,
    endpoint: undefined,
    googleService: undefined,
    forwardingRule: undefined,
    vpnGateway: undefined,
    vpnTunnel: undefined,
    vpcConnector: undefined,
    deliver: undefined,
    forward: undefined,
    abort: undefined,
    drop: undefined,
    loadBalancer: undefined,
    network: undefined,
    gkeMaster: undefined,
    cloudSqlInstance: undefined,
    cloudFunction: undefined,
    appEngineVersion: undefined,
    cloudRunRevision: undefined,
  };
}

export const Step: MessageFns<Step> = {
  encode(message: Step, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.causesDrop !== false) {
      writer.uint32(24).bool(message.causesDrop);
    }
    if (message.projectId !== "") {
      writer.uint32(34).string(message.projectId);
    }
    if (message.instance !== undefined) {
      InstanceInfo.encode(message.instance, writer.uint32(42).fork()).join();
    }
    if (message.firewall !== undefined) {
      FirewallInfo.encode(message.firewall, writer.uint32(50).fork()).join();
    }
    if (message.route !== undefined) {
      RouteInfo.encode(message.route, writer.uint32(58).fork()).join();
    }
    if (message.endpoint !== undefined) {
      EndpointInfo.encode(message.endpoint, writer.uint32(66).fork()).join();
    }
    if (message.googleService !== undefined) {
      GoogleServiceInfo.encode(message.googleService, writer.uint32(194).fork()).join();
    }
    if (message.forwardingRule !== undefined) {
      ForwardingRuleInfo.encode(message.forwardingRule, writer.uint32(74).fork()).join();
    }
    if (message.vpnGateway !== undefined) {
      VpnGatewayInfo.encode(message.vpnGateway, writer.uint32(82).fork()).join();
    }
    if (message.vpnTunnel !== undefined) {
      VpnTunnelInfo.encode(message.vpnTunnel, writer.uint32(90).fork()).join();
    }
    if (message.vpcConnector !== undefined) {
      VpcConnectorInfo.encode(message.vpcConnector, writer.uint32(170).fork()).join();
    }
    if (message.deliver !== undefined) {
      DeliverInfo.encode(message.deliver, writer.uint32(98).fork()).join();
    }
    if (message.forward !== undefined) {
      ForwardInfo.encode(message.forward, writer.uint32(106).fork()).join();
    }
    if (message.abort !== undefined) {
      AbortInfo.encode(message.abort, writer.uint32(114).fork()).join();
    }
    if (message.drop !== undefined) {
      DropInfo.encode(message.drop, writer.uint32(122).fork()).join();
    }
    if (message.loadBalancer !== undefined) {
      LoadBalancerInfo.encode(message.loadBalancer, writer.uint32(130).fork()).join();
    }
    if (message.network !== undefined) {
      NetworkInfo.encode(message.network, writer.uint32(138).fork()).join();
    }
    if (message.gkeMaster !== undefined) {
      GKEMasterInfo.encode(message.gkeMaster, writer.uint32(146).fork()).join();
    }
    if (message.cloudSqlInstance !== undefined) {
      CloudSQLInstanceInfo.encode(message.cloudSqlInstance, writer.uint32(154).fork()).join();
    }
    if (message.cloudFunction !== undefined) {
      CloudFunctionInfo.encode(message.cloudFunction, writer.uint32(162).fork()).join();
    }
    if (message.appEngineVersion !== undefined) {
      AppEngineVersionInfo.encode(message.appEngineVersion, writer.uint32(178).fork()).join();
    }
    if (message.cloudRunRevision !== undefined) {
      CloudRunRevisionInfo.encode(message.cloudRunRevision, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Step {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.causesDrop = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.instance = InstanceInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.firewall = FirewallInfo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.route = RouteInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.endpoint = EndpointInfo.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.googleService = GoogleServiceInfo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.forwardingRule = ForwardingRuleInfo.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.vpnGateway = VpnGatewayInfo.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.vpnTunnel = VpnTunnelInfo.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.vpcConnector = VpcConnectorInfo.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.deliver = DeliverInfo.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.forward = ForwardInfo.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.abort = AbortInfo.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.drop = DropInfo.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.loadBalancer = LoadBalancerInfo.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.network = NetworkInfo.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.gkeMaster = GKEMasterInfo.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.cloudSqlInstance = CloudSQLInstanceInfo.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.cloudFunction = CloudFunctionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.appEngineVersion = AppEngineVersionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.cloudRunRevision = CloudRunRevisionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Step {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? step_StateFromJSON(object.state) : 0,
      causesDrop: isSet(object.causesDrop) ? globalThis.Boolean(object.causesDrop) : false,
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instance: isSet(object.instance) ? InstanceInfo.fromJSON(object.instance) : undefined,
      firewall: isSet(object.firewall) ? FirewallInfo.fromJSON(object.firewall) : undefined,
      route: isSet(object.route) ? RouteInfo.fromJSON(object.route) : undefined,
      endpoint: isSet(object.endpoint) ? EndpointInfo.fromJSON(object.endpoint) : undefined,
      googleService: isSet(object.googleService) ? GoogleServiceInfo.fromJSON(object.googleService) : undefined,
      forwardingRule: isSet(object.forwardingRule) ? ForwardingRuleInfo.fromJSON(object.forwardingRule) : undefined,
      vpnGateway: isSet(object.vpnGateway) ? VpnGatewayInfo.fromJSON(object.vpnGateway) : undefined,
      vpnTunnel: isSet(object.vpnTunnel) ? VpnTunnelInfo.fromJSON(object.vpnTunnel) : undefined,
      vpcConnector: isSet(object.vpcConnector) ? VpcConnectorInfo.fromJSON(object.vpcConnector) : undefined,
      deliver: isSet(object.deliver) ? DeliverInfo.fromJSON(object.deliver) : undefined,
      forward: isSet(object.forward) ? ForwardInfo.fromJSON(object.forward) : undefined,
      abort: isSet(object.abort) ? AbortInfo.fromJSON(object.abort) : undefined,
      drop: isSet(object.drop) ? DropInfo.fromJSON(object.drop) : undefined,
      loadBalancer: isSet(object.loadBalancer) ? LoadBalancerInfo.fromJSON(object.loadBalancer) : undefined,
      network: isSet(object.network) ? NetworkInfo.fromJSON(object.network) : undefined,
      gkeMaster: isSet(object.gkeMaster) ? GKEMasterInfo.fromJSON(object.gkeMaster) : undefined,
      cloudSqlInstance: isSet(object.cloudSqlInstance)
        ? CloudSQLInstanceInfo.fromJSON(object.cloudSqlInstance)
        : undefined,
      cloudFunction: isSet(object.cloudFunction) ? CloudFunctionInfo.fromJSON(object.cloudFunction) : undefined,
      appEngineVersion: isSet(object.appEngineVersion)
        ? AppEngineVersionInfo.fromJSON(object.appEngineVersion)
        : undefined,
      cloudRunRevision: isSet(object.cloudRunRevision)
        ? CloudRunRevisionInfo.fromJSON(object.cloudRunRevision)
        : undefined,
    };
  },

  toJSON(message: Step): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = step_StateToJSON(message.state);
    }
    if (message.causesDrop !== false) {
      obj.causesDrop = message.causesDrop;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instance !== undefined) {
      obj.instance = InstanceInfo.toJSON(message.instance);
    }
    if (message.firewall !== undefined) {
      obj.firewall = FirewallInfo.toJSON(message.firewall);
    }
    if (message.route !== undefined) {
      obj.route = RouteInfo.toJSON(message.route);
    }
    if (message.endpoint !== undefined) {
      obj.endpoint = EndpointInfo.toJSON(message.endpoint);
    }
    if (message.googleService !== undefined) {
      obj.googleService = GoogleServiceInfo.toJSON(message.googleService);
    }
    if (message.forwardingRule !== undefined) {
      obj.forwardingRule = ForwardingRuleInfo.toJSON(message.forwardingRule);
    }
    if (message.vpnGateway !== undefined) {
      obj.vpnGateway = VpnGatewayInfo.toJSON(message.vpnGateway);
    }
    if (message.vpnTunnel !== undefined) {
      obj.vpnTunnel = VpnTunnelInfo.toJSON(message.vpnTunnel);
    }
    if (message.vpcConnector !== undefined) {
      obj.vpcConnector = VpcConnectorInfo.toJSON(message.vpcConnector);
    }
    if (message.deliver !== undefined) {
      obj.deliver = DeliverInfo.toJSON(message.deliver);
    }
    if (message.forward !== undefined) {
      obj.forward = ForwardInfo.toJSON(message.forward);
    }
    if (message.abort !== undefined) {
      obj.abort = AbortInfo.toJSON(message.abort);
    }
    if (message.drop !== undefined) {
      obj.drop = DropInfo.toJSON(message.drop);
    }
    if (message.loadBalancer !== undefined) {
      obj.loadBalancer = LoadBalancerInfo.toJSON(message.loadBalancer);
    }
    if (message.network !== undefined) {
      obj.network = NetworkInfo.toJSON(message.network);
    }
    if (message.gkeMaster !== undefined) {
      obj.gkeMaster = GKEMasterInfo.toJSON(message.gkeMaster);
    }
    if (message.cloudSqlInstance !== undefined) {
      obj.cloudSqlInstance = CloudSQLInstanceInfo.toJSON(message.cloudSqlInstance);
    }
    if (message.cloudFunction !== undefined) {
      obj.cloudFunction = CloudFunctionInfo.toJSON(message.cloudFunction);
    }
    if (message.appEngineVersion !== undefined) {
      obj.appEngineVersion = AppEngineVersionInfo.toJSON(message.appEngineVersion);
    }
    if (message.cloudRunRevision !== undefined) {
      obj.cloudRunRevision = CloudRunRevisionInfo.toJSON(message.cloudRunRevision);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Step>, I>>(base?: I): Step {
    return Step.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Step>, I>>(object: I): Step {
    const message = createBaseStep();
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.causesDrop = object.causesDrop ?? false;
    message.projectId = object.projectId ?? "";
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? InstanceInfo.fromPartial(object.instance)
      : undefined;
    message.firewall = (object.firewall !== undefined && object.firewall !== null)
      ? FirewallInfo.fromPartial(object.firewall)
      : undefined;
    message.route = (object.route !== undefined && object.route !== null)
      ? RouteInfo.fromPartial(object.route)
      : undefined;
    message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
      ? EndpointInfo.fromPartial(object.endpoint)
      : undefined;
    message.googleService = (object.googleService !== undefined && object.googleService !== null)
      ? GoogleServiceInfo.fromPartial(object.googleService)
      : undefined;
    message.forwardingRule = (object.forwardingRule !== undefined && object.forwardingRule !== null)
      ? ForwardingRuleInfo.fromPartial(object.forwardingRule)
      : undefined;
    message.vpnGateway = (object.vpnGateway !== undefined && object.vpnGateway !== null)
      ? VpnGatewayInfo.fromPartial(object.vpnGateway)
      : undefined;
    message.vpnTunnel = (object.vpnTunnel !== undefined && object.vpnTunnel !== null)
      ? VpnTunnelInfo.fromPartial(object.vpnTunnel)
      : undefined;
    message.vpcConnector = (object.vpcConnector !== undefined && object.vpcConnector !== null)
      ? VpcConnectorInfo.fromPartial(object.vpcConnector)
      : undefined;
    message.deliver = (object.deliver !== undefined && object.deliver !== null)
      ? DeliverInfo.fromPartial(object.deliver)
      : undefined;
    message.forward = (object.forward !== undefined && object.forward !== null)
      ? ForwardInfo.fromPartial(object.forward)
      : undefined;
    message.abort = (object.abort !== undefined && object.abort !== null)
      ? AbortInfo.fromPartial(object.abort)
      : undefined;
    message.drop = (object.drop !== undefined && object.drop !== null) ? DropInfo.fromPartial(object.drop) : undefined;
    message.loadBalancer = (object.loadBalancer !== undefined && object.loadBalancer !== null)
      ? LoadBalancerInfo.fromPartial(object.loadBalancer)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? NetworkInfo.fromPartial(object.network)
      : undefined;
    message.gkeMaster = (object.gkeMaster !== undefined && object.gkeMaster !== null)
      ? GKEMasterInfo.fromPartial(object.gkeMaster)
      : undefined;
    message.cloudSqlInstance = (object.cloudSqlInstance !== undefined && object.cloudSqlInstance !== null)
      ? CloudSQLInstanceInfo.fromPartial(object.cloudSqlInstance)
      : undefined;
    message.cloudFunction = (object.cloudFunction !== undefined && object.cloudFunction !== null)
      ? CloudFunctionInfo.fromPartial(object.cloudFunction)
      : undefined;
    message.appEngineVersion = (object.appEngineVersion !== undefined && object.appEngineVersion !== null)
      ? AppEngineVersionInfo.fromPartial(object.appEngineVersion)
      : undefined;
    message.cloudRunRevision = (object.cloudRunRevision !== undefined && object.cloudRunRevision !== null)
      ? CloudRunRevisionInfo.fromPartial(object.cloudRunRevision)
      : undefined;
    return message;
  },
};

function createBaseInstanceInfo(): InstanceInfo {
  return {
    displayName: "",
    uri: "",
    interface: "",
    networkUri: "",
    internalIp: "",
    externalIp: "",
    networkTags: [],
    serviceAccount: "",
  };
}

export const InstanceInfo: MessageFns<InstanceInfo> = {
  encode(message: InstanceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.interface !== "") {
      writer.uint32(26).string(message.interface);
    }
    if (message.networkUri !== "") {
      writer.uint32(34).string(message.networkUri);
    }
    if (message.internalIp !== "") {
      writer.uint32(42).string(message.internalIp);
    }
    if (message.externalIp !== "") {
      writer.uint32(50).string(message.externalIp);
    }
    for (const v of message.networkTags) {
      writer.uint32(58).string(v!);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(66).string(message.serviceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.interface = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalIp = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.networkTags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      interface: isSet(object.interface) ? globalThis.String(object.interface) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "",
      networkTags: globalThis.Array.isArray(object?.networkTags)
        ? object.networkTags.map((e: any) => globalThis.String(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
    };
  },

  toJSON(message: InstanceInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.interface !== "") {
      obj.interface = message.interface;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    if (message.networkTags?.length) {
      obj.networkTags = message.networkTags;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceInfo>, I>>(base?: I): InstanceInfo {
    return InstanceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceInfo>, I>>(object: I): InstanceInfo {
    const message = createBaseInstanceInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.interface = object.interface ?? "";
    message.networkUri = object.networkUri ?? "";
    message.internalIp = object.internalIp ?? "";
    message.externalIp = object.externalIp ?? "";
    message.networkTags = object.networkTags?.map((e) => e) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    return message;
  },
};

function createBaseNetworkInfo(): NetworkInfo {
  return { displayName: "", uri: "", matchedIpRange: "" };
}

export const NetworkInfo: MessageFns<NetworkInfo> = {
  encode(message: NetworkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.matchedIpRange !== "") {
      writer.uint32(34).string(message.matchedIpRange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.matchedIpRange = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      matchedIpRange: isSet(object.matchedIpRange) ? globalThis.String(object.matchedIpRange) : "",
    };
  },

  toJSON(message: NetworkInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.matchedIpRange !== "") {
      obj.matchedIpRange = message.matchedIpRange;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkInfo>, I>>(base?: I): NetworkInfo {
    return NetworkInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkInfo>, I>>(object: I): NetworkInfo {
    const message = createBaseNetworkInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.matchedIpRange = object.matchedIpRange ?? "";
    return message;
  },
};

function createBaseFirewallInfo(): FirewallInfo {
  return {
    displayName: "",
    uri: "",
    direction: "",
    action: "",
    priority: 0,
    networkUri: "",
    targetTags: [],
    targetServiceAccounts: [],
    policy: "",
    firewallRuleType: 0,
  };
}

export const FirewallInfo: MessageFns<FirewallInfo> = {
  encode(message: FirewallInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.priority !== 0) {
      writer.uint32(40).int32(message.priority);
    }
    if (message.networkUri !== "") {
      writer.uint32(50).string(message.networkUri);
    }
    for (const v of message.targetTags) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.targetServiceAccounts) {
      writer.uint32(66).string(v!);
    }
    if (message.policy !== "") {
      writer.uint32(74).string(message.policy);
    }
    if (message.firewallRuleType !== 0) {
      writer.uint32(80).int32(message.firewallRuleType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.direction = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.targetTags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.targetServiceAccounts.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.policy = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.firewallRuleType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FirewallInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      targetTags: globalThis.Array.isArray(object?.targetTags)
        ? object.targetTags.map((e: any) => globalThis.String(e))
        : [],
      targetServiceAccounts: globalThis.Array.isArray(object?.targetServiceAccounts)
        ? object.targetServiceAccounts.map((e: any) => globalThis.String(e))
        : [],
      policy: isSet(object.policy) ? globalThis.String(object.policy) : "",
      firewallRuleType: isSet(object.firewallRuleType)
        ? firewallInfo_FirewallRuleTypeFromJSON(object.firewallRuleType)
        : 0,
    };
  },

  toJSON(message: FirewallInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.direction !== "") {
      obj.direction = message.direction;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.targetTags?.length) {
      obj.targetTags = message.targetTags;
    }
    if (message.targetServiceAccounts?.length) {
      obj.targetServiceAccounts = message.targetServiceAccounts;
    }
    if (message.policy !== "") {
      obj.policy = message.policy;
    }
    if (message.firewallRuleType !== 0) {
      obj.firewallRuleType = firewallInfo_FirewallRuleTypeToJSON(message.firewallRuleType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FirewallInfo>, I>>(base?: I): FirewallInfo {
    return FirewallInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FirewallInfo>, I>>(object: I): FirewallInfo {
    const message = createBaseFirewallInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.direction = object.direction ?? "";
    message.action = object.action ?? "";
    message.priority = object.priority ?? 0;
    message.networkUri = object.networkUri ?? "";
    message.targetTags = object.targetTags?.map((e) => e) || [];
    message.targetServiceAccounts = object.targetServiceAccounts?.map((e) => e) || [];
    message.policy = object.policy ?? "";
    message.firewallRuleType = object.firewallRuleType ?? 0;
    return message;
  },
};

function createBaseRouteInfo(): RouteInfo {
  return {
    routeType: 0,
    nextHopType: 0,
    displayName: "",
    uri: "",
    destIpRange: "",
    nextHop: "",
    networkUri: "",
    priority: 0,
    instanceTags: [],
    srcIpRange: "",
    destPortRanges: [],
    srcPortRanges: [],
    protocols: [],
  };
}

export const RouteInfo: MessageFns<RouteInfo> = {
  encode(message: RouteInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routeType !== 0) {
      writer.uint32(64).int32(message.routeType);
    }
    if (message.nextHopType !== 0) {
      writer.uint32(72).int32(message.nextHopType);
    }
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.destIpRange !== "") {
      writer.uint32(26).string(message.destIpRange);
    }
    if (message.nextHop !== "") {
      writer.uint32(34).string(message.nextHop);
    }
    if (message.networkUri !== "") {
      writer.uint32(42).string(message.networkUri);
    }
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    for (const v of message.instanceTags) {
      writer.uint32(58).string(v!);
    }
    if (message.srcIpRange !== "") {
      writer.uint32(82).string(message.srcIpRange);
    }
    for (const v of message.destPortRanges) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.srcPortRanges) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.protocols) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.routeType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.nextHopType = reader.int32() as any;
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destIpRange = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nextHop = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.instanceTags.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.srcIpRange = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.destPortRanges.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.srcPortRanges.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.protocols.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteInfo {
    return {
      routeType: isSet(object.routeType) ? routeInfo_RouteTypeFromJSON(object.routeType) : 0,
      nextHopType: isSet(object.nextHopType) ? routeInfo_NextHopTypeFromJSON(object.nextHopType) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      destIpRange: isSet(object.destIpRange) ? globalThis.String(object.destIpRange) : "",
      nextHop: isSet(object.nextHop) ? globalThis.String(object.nextHop) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      instanceTags: globalThis.Array.isArray(object?.instanceTags)
        ? object.instanceTags.map((e: any) => globalThis.String(e))
        : [],
      srcIpRange: isSet(object.srcIpRange) ? globalThis.String(object.srcIpRange) : "",
      destPortRanges: globalThis.Array.isArray(object?.destPortRanges)
        ? object.destPortRanges.map((e: any) => globalThis.String(e))
        : [],
      srcPortRanges: globalThis.Array.isArray(object?.srcPortRanges)
        ? object.srcPortRanges.map((e: any) => globalThis.String(e))
        : [],
      protocols: globalThis.Array.isArray(object?.protocols)
        ? object.protocols.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RouteInfo): unknown {
    const obj: any = {};
    if (message.routeType !== 0) {
      obj.routeType = routeInfo_RouteTypeToJSON(message.routeType);
    }
    if (message.nextHopType !== 0) {
      obj.nextHopType = routeInfo_NextHopTypeToJSON(message.nextHopType);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.destIpRange !== "") {
      obj.destIpRange = message.destIpRange;
    }
    if (message.nextHop !== "") {
      obj.nextHop = message.nextHop;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.instanceTags?.length) {
      obj.instanceTags = message.instanceTags;
    }
    if (message.srcIpRange !== "") {
      obj.srcIpRange = message.srcIpRange;
    }
    if (message.destPortRanges?.length) {
      obj.destPortRanges = message.destPortRanges;
    }
    if (message.srcPortRanges?.length) {
      obj.srcPortRanges = message.srcPortRanges;
    }
    if (message.protocols?.length) {
      obj.protocols = message.protocols;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteInfo>, I>>(base?: I): RouteInfo {
    return RouteInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteInfo>, I>>(object: I): RouteInfo {
    const message = createBaseRouteInfo();
    message.routeType = object.routeType ?? 0;
    message.nextHopType = object.nextHopType ?? 0;
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.destIpRange = object.destIpRange ?? "";
    message.nextHop = object.nextHop ?? "";
    message.networkUri = object.networkUri ?? "";
    message.priority = object.priority ?? 0;
    message.instanceTags = object.instanceTags?.map((e) => e) || [];
    message.srcIpRange = object.srcIpRange ?? "";
    message.destPortRanges = object.destPortRanges?.map((e) => e) || [];
    message.srcPortRanges = object.srcPortRanges?.map((e) => e) || [];
    message.protocols = object.protocols?.map((e) => e) || [];
    return message;
  },
};

function createBaseGoogleServiceInfo(): GoogleServiceInfo {
  return { sourceIp: "", googleServiceType: 0 };
}

export const GoogleServiceInfo: MessageFns<GoogleServiceInfo> = {
  encode(message: GoogleServiceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceIp !== "") {
      writer.uint32(10).string(message.sourceIp);
    }
    if (message.googleServiceType !== 0) {
      writer.uint32(16).int32(message.googleServiceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleServiceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleServiceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceIp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.googleServiceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleServiceInfo {
    return {
      sourceIp: isSet(object.sourceIp) ? globalThis.String(object.sourceIp) : "",
      googleServiceType: isSet(object.googleServiceType)
        ? googleServiceInfo_GoogleServiceTypeFromJSON(object.googleServiceType)
        : 0,
    };
  },

  toJSON(message: GoogleServiceInfo): unknown {
    const obj: any = {};
    if (message.sourceIp !== "") {
      obj.sourceIp = message.sourceIp;
    }
    if (message.googleServiceType !== 0) {
      obj.googleServiceType = googleServiceInfo_GoogleServiceTypeToJSON(message.googleServiceType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoogleServiceInfo>, I>>(base?: I): GoogleServiceInfo {
    return GoogleServiceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoogleServiceInfo>, I>>(object: I): GoogleServiceInfo {
    const message = createBaseGoogleServiceInfo();
    message.sourceIp = object.sourceIp ?? "";
    message.googleServiceType = object.googleServiceType ?? 0;
    return message;
  },
};

function createBaseForwardingRuleInfo(): ForwardingRuleInfo {
  return { displayName: "", uri: "", matchedProtocol: "", matchedPortRange: "", vip: "", target: "", networkUri: "" };
}

export const ForwardingRuleInfo: MessageFns<ForwardingRuleInfo> = {
  encode(message: ForwardingRuleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.matchedProtocol !== "") {
      writer.uint32(26).string(message.matchedProtocol);
    }
    if (message.matchedPortRange !== "") {
      writer.uint32(50).string(message.matchedPortRange);
    }
    if (message.vip !== "") {
      writer.uint32(34).string(message.vip);
    }
    if (message.target !== "") {
      writer.uint32(42).string(message.target);
    }
    if (message.networkUri !== "") {
      writer.uint32(58).string(message.networkUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardingRuleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardingRuleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.matchedProtocol = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.matchedPortRange = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vip = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForwardingRuleInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      matchedProtocol: isSet(object.matchedProtocol) ? globalThis.String(object.matchedProtocol) : "",
      matchedPortRange: isSet(object.matchedPortRange) ? globalThis.String(object.matchedPortRange) : "",
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
    };
  },

  toJSON(message: ForwardingRuleInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.matchedProtocol !== "") {
      obj.matchedProtocol = message.matchedProtocol;
    }
    if (message.matchedPortRange !== "") {
      obj.matchedPortRange = message.matchedPortRange;
    }
    if (message.vip !== "") {
      obj.vip = message.vip;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForwardingRuleInfo>, I>>(base?: I): ForwardingRuleInfo {
    return ForwardingRuleInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForwardingRuleInfo>, I>>(object: I): ForwardingRuleInfo {
    const message = createBaseForwardingRuleInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.matchedProtocol = object.matchedProtocol ?? "";
    message.matchedPortRange = object.matchedPortRange ?? "";
    message.vip = object.vip ?? "";
    message.target = object.target ?? "";
    message.networkUri = object.networkUri ?? "";
    return message;
  },
};

function createBaseLoadBalancerInfo(): LoadBalancerInfo {
  return { loadBalancerType: 0, healthCheckUri: "", backends: [], backendType: 0, backendUri: "" };
}

export const LoadBalancerInfo: MessageFns<LoadBalancerInfo> = {
  encode(message: LoadBalancerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loadBalancerType !== 0) {
      writer.uint32(8).int32(message.loadBalancerType);
    }
    if (message.healthCheckUri !== "") {
      writer.uint32(18).string(message.healthCheckUri);
    }
    for (const v of message.backends) {
      LoadBalancerBackend.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.backendType !== 0) {
      writer.uint32(32).int32(message.backendType);
    }
    if (message.backendUri !== "") {
      writer.uint32(42).string(message.backendUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.loadBalancerType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.healthCheckUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.backends.push(LoadBalancerBackend.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.backendType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.backendUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancerInfo {
    return {
      loadBalancerType: isSet(object.loadBalancerType)
        ? loadBalancerInfo_LoadBalancerTypeFromJSON(object.loadBalancerType)
        : 0,
      healthCheckUri: isSet(object.healthCheckUri) ? globalThis.String(object.healthCheckUri) : "",
      backends: globalThis.Array.isArray(object?.backends)
        ? object.backends.map((e: any) => LoadBalancerBackend.fromJSON(e))
        : [],
      backendType: isSet(object.backendType) ? loadBalancerInfo_BackendTypeFromJSON(object.backendType) : 0,
      backendUri: isSet(object.backendUri) ? globalThis.String(object.backendUri) : "",
    };
  },

  toJSON(message: LoadBalancerInfo): unknown {
    const obj: any = {};
    if (message.loadBalancerType !== 0) {
      obj.loadBalancerType = loadBalancerInfo_LoadBalancerTypeToJSON(message.loadBalancerType);
    }
    if (message.healthCheckUri !== "") {
      obj.healthCheckUri = message.healthCheckUri;
    }
    if (message.backends?.length) {
      obj.backends = message.backends.map((e) => LoadBalancerBackend.toJSON(e));
    }
    if (message.backendType !== 0) {
      obj.backendType = loadBalancerInfo_BackendTypeToJSON(message.backendType);
    }
    if (message.backendUri !== "") {
      obj.backendUri = message.backendUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadBalancerInfo>, I>>(base?: I): LoadBalancerInfo {
    return LoadBalancerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadBalancerInfo>, I>>(object: I): LoadBalancerInfo {
    const message = createBaseLoadBalancerInfo();
    message.loadBalancerType = object.loadBalancerType ?? 0;
    message.healthCheckUri = object.healthCheckUri ?? "";
    message.backends = object.backends?.map((e) => LoadBalancerBackend.fromPartial(e)) || [];
    message.backendType = object.backendType ?? 0;
    message.backendUri = object.backendUri ?? "";
    return message;
  },
};

function createBaseLoadBalancerBackend(): LoadBalancerBackend {
  return {
    displayName: "",
    uri: "",
    healthCheckFirewallState: 0,
    healthCheckAllowingFirewallRules: [],
    healthCheckBlockingFirewallRules: [],
  };
}

export const LoadBalancerBackend: MessageFns<LoadBalancerBackend> = {
  encode(message: LoadBalancerBackend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.healthCheckFirewallState !== 0) {
      writer.uint32(24).int32(message.healthCheckFirewallState);
    }
    for (const v of message.healthCheckAllowingFirewallRules) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.healthCheckBlockingFirewallRules) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancerBackend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancerBackend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.healthCheckFirewallState = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.healthCheckAllowingFirewallRules.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.healthCheckBlockingFirewallRules.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancerBackend {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      healthCheckFirewallState: isSet(object.healthCheckFirewallState)
        ? loadBalancerBackend_HealthCheckFirewallStateFromJSON(object.healthCheckFirewallState)
        : 0,
      healthCheckAllowingFirewallRules: globalThis.Array.isArray(object?.healthCheckAllowingFirewallRules)
        ? object.healthCheckAllowingFirewallRules.map((e: any) => globalThis.String(e))
        : [],
      healthCheckBlockingFirewallRules: globalThis.Array.isArray(object?.healthCheckBlockingFirewallRules)
        ? object.healthCheckBlockingFirewallRules.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LoadBalancerBackend): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.healthCheckFirewallState !== 0) {
      obj.healthCheckFirewallState = loadBalancerBackend_HealthCheckFirewallStateToJSON(
        message.healthCheckFirewallState,
      );
    }
    if (message.healthCheckAllowingFirewallRules?.length) {
      obj.healthCheckAllowingFirewallRules = message.healthCheckAllowingFirewallRules;
    }
    if (message.healthCheckBlockingFirewallRules?.length) {
      obj.healthCheckBlockingFirewallRules = message.healthCheckBlockingFirewallRules;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadBalancerBackend>, I>>(base?: I): LoadBalancerBackend {
    return LoadBalancerBackend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadBalancerBackend>, I>>(object: I): LoadBalancerBackend {
    const message = createBaseLoadBalancerBackend();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.healthCheckFirewallState = object.healthCheckFirewallState ?? 0;
    message.healthCheckAllowingFirewallRules = object.healthCheckAllowingFirewallRules?.map((e) => e) || [];
    message.healthCheckBlockingFirewallRules = object.healthCheckBlockingFirewallRules?.map((e) => e) || [];
    return message;
  },
};

function createBaseVpnGatewayInfo(): VpnGatewayInfo {
  return { displayName: "", uri: "", networkUri: "", ipAddress: "", vpnTunnelUri: "", region: "" };
}

export const VpnGatewayInfo: MessageFns<VpnGatewayInfo> = {
  encode(message: VpnGatewayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.networkUri !== "") {
      writer.uint32(26).string(message.networkUri);
    }
    if (message.ipAddress !== "") {
      writer.uint32(34).string(message.ipAddress);
    }
    if (message.vpnTunnelUri !== "") {
      writer.uint32(42).string(message.vpnTunnelUri);
    }
    if (message.region !== "") {
      writer.uint32(50).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnGatewayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnGatewayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.vpnTunnelUri = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.region = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnGatewayInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      vpnTunnelUri: isSet(object.vpnTunnelUri) ? globalThis.String(object.vpnTunnelUri) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: VpnGatewayInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.vpnTunnelUri !== "") {
      obj.vpnTunnelUri = message.vpnTunnelUri;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VpnGatewayInfo>, I>>(base?: I): VpnGatewayInfo {
    return VpnGatewayInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VpnGatewayInfo>, I>>(object: I): VpnGatewayInfo {
    const message = createBaseVpnGatewayInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.networkUri = object.networkUri ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.vpnTunnelUri = object.vpnTunnelUri ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseVpnTunnelInfo(): VpnTunnelInfo {
  return {
    displayName: "",
    uri: "",
    sourceGateway: "",
    remoteGateway: "",
    remoteGatewayIp: "",
    sourceGatewayIp: "",
    networkUri: "",
    region: "",
    routingType: 0,
  };
}

export const VpnTunnelInfo: MessageFns<VpnTunnelInfo> = {
  encode(message: VpnTunnelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.sourceGateway !== "") {
      writer.uint32(26).string(message.sourceGateway);
    }
    if (message.remoteGateway !== "") {
      writer.uint32(34).string(message.remoteGateway);
    }
    if (message.remoteGatewayIp !== "") {
      writer.uint32(42).string(message.remoteGatewayIp);
    }
    if (message.sourceGatewayIp !== "") {
      writer.uint32(50).string(message.sourceGatewayIp);
    }
    if (message.networkUri !== "") {
      writer.uint32(58).string(message.networkUri);
    }
    if (message.region !== "") {
      writer.uint32(66).string(message.region);
    }
    if (message.routingType !== 0) {
      writer.uint32(72).int32(message.routingType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnTunnelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnTunnelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceGateway = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remoteGateway = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.remoteGatewayIp = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceGatewayIp = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.routingType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnTunnelInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      sourceGateway: isSet(object.sourceGateway) ? globalThis.String(object.sourceGateway) : "",
      remoteGateway: isSet(object.remoteGateway) ? globalThis.String(object.remoteGateway) : "",
      remoteGatewayIp: isSet(object.remoteGatewayIp) ? globalThis.String(object.remoteGatewayIp) : "",
      sourceGatewayIp: isSet(object.sourceGatewayIp) ? globalThis.String(object.sourceGatewayIp) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      routingType: isSet(object.routingType) ? vpnTunnelInfo_RoutingTypeFromJSON(object.routingType) : 0,
    };
  },

  toJSON(message: VpnTunnelInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.sourceGateway !== "") {
      obj.sourceGateway = message.sourceGateway;
    }
    if (message.remoteGateway !== "") {
      obj.remoteGateway = message.remoteGateway;
    }
    if (message.remoteGatewayIp !== "") {
      obj.remoteGatewayIp = message.remoteGatewayIp;
    }
    if (message.sourceGatewayIp !== "") {
      obj.sourceGatewayIp = message.sourceGatewayIp;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.routingType !== 0) {
      obj.routingType = vpnTunnelInfo_RoutingTypeToJSON(message.routingType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VpnTunnelInfo>, I>>(base?: I): VpnTunnelInfo {
    return VpnTunnelInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VpnTunnelInfo>, I>>(object: I): VpnTunnelInfo {
    const message = createBaseVpnTunnelInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.sourceGateway = object.sourceGateway ?? "";
    message.remoteGateway = object.remoteGateway ?? "";
    message.remoteGatewayIp = object.remoteGatewayIp ?? "";
    message.sourceGatewayIp = object.sourceGatewayIp ?? "";
    message.networkUri = object.networkUri ?? "";
    message.region = object.region ?? "";
    message.routingType = object.routingType ?? 0;
    return message;
  },
};

function createBaseEndpointInfo(): EndpointInfo {
  return {
    sourceIp: "",
    destinationIp: "",
    protocol: "",
    sourcePort: 0,
    destinationPort: 0,
    sourceNetworkUri: "",
    destinationNetworkUri: "",
  };
}

export const EndpointInfo: MessageFns<EndpointInfo> = {
  encode(message: EndpointInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceIp !== "") {
      writer.uint32(10).string(message.sourceIp);
    }
    if (message.destinationIp !== "") {
      writer.uint32(18).string(message.destinationIp);
    }
    if (message.protocol !== "") {
      writer.uint32(26).string(message.protocol);
    }
    if (message.sourcePort !== 0) {
      writer.uint32(32).int32(message.sourcePort);
    }
    if (message.destinationPort !== 0) {
      writer.uint32(40).int32(message.destinationPort);
    }
    if (message.sourceNetworkUri !== "") {
      writer.uint32(50).string(message.sourceNetworkUri);
    }
    if (message.destinationNetworkUri !== "") {
      writer.uint32(58).string(message.destinationNetworkUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceIp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destinationIp = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.protocol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sourcePort = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.destinationPort = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceNetworkUri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.destinationNetworkUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointInfo {
    return {
      sourceIp: isSet(object.sourceIp) ? globalThis.String(object.sourceIp) : "",
      destinationIp: isSet(object.destinationIp) ? globalThis.String(object.destinationIp) : "",
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      sourcePort: isSet(object.sourcePort) ? globalThis.Number(object.sourcePort) : 0,
      destinationPort: isSet(object.destinationPort) ? globalThis.Number(object.destinationPort) : 0,
      sourceNetworkUri: isSet(object.sourceNetworkUri) ? globalThis.String(object.sourceNetworkUri) : "",
      destinationNetworkUri: isSet(object.destinationNetworkUri) ? globalThis.String(object.destinationNetworkUri) : "",
    };
  },

  toJSON(message: EndpointInfo): unknown {
    const obj: any = {};
    if (message.sourceIp !== "") {
      obj.sourceIp = message.sourceIp;
    }
    if (message.destinationIp !== "") {
      obj.destinationIp = message.destinationIp;
    }
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.sourcePort !== 0) {
      obj.sourcePort = Math.round(message.sourcePort);
    }
    if (message.destinationPort !== 0) {
      obj.destinationPort = Math.round(message.destinationPort);
    }
    if (message.sourceNetworkUri !== "") {
      obj.sourceNetworkUri = message.sourceNetworkUri;
    }
    if (message.destinationNetworkUri !== "") {
      obj.destinationNetworkUri = message.destinationNetworkUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointInfo>, I>>(base?: I): EndpointInfo {
    return EndpointInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointInfo>, I>>(object: I): EndpointInfo {
    const message = createBaseEndpointInfo();
    message.sourceIp = object.sourceIp ?? "";
    message.destinationIp = object.destinationIp ?? "";
    message.protocol = object.protocol ?? "";
    message.sourcePort = object.sourcePort ?? 0;
    message.destinationPort = object.destinationPort ?? 0;
    message.sourceNetworkUri = object.sourceNetworkUri ?? "";
    message.destinationNetworkUri = object.destinationNetworkUri ?? "";
    return message;
  },
};

function createBaseDeliverInfo(): DeliverInfo {
  return { target: 0, resourceUri: "" };
}

export const DeliverInfo: MessageFns<DeliverInfo> = {
  encode(message: DeliverInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== 0) {
      writer.uint32(8).int32(message.target);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliverInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliverInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliverInfo {
    return {
      target: isSet(object.target) ? deliverInfo_TargetFromJSON(object.target) : 0,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
    };
  },

  toJSON(message: DeliverInfo): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = deliverInfo_TargetToJSON(message.target);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeliverInfo>, I>>(base?: I): DeliverInfo {
    return DeliverInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeliverInfo>, I>>(object: I): DeliverInfo {
    const message = createBaseDeliverInfo();
    message.target = object.target ?? 0;
    message.resourceUri = object.resourceUri ?? "";
    return message;
  },
};

function createBaseForwardInfo(): ForwardInfo {
  return { target: 0, resourceUri: "" };
}

export const ForwardInfo: MessageFns<ForwardInfo> = {
  encode(message: ForwardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== 0) {
      writer.uint32(8).int32(message.target);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForwardInfo {
    return {
      target: isSet(object.target) ? forwardInfo_TargetFromJSON(object.target) : 0,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
    };
  },

  toJSON(message: ForwardInfo): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = forwardInfo_TargetToJSON(message.target);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForwardInfo>, I>>(base?: I): ForwardInfo {
    return ForwardInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForwardInfo>, I>>(object: I): ForwardInfo {
    const message = createBaseForwardInfo();
    message.target = object.target ?? 0;
    message.resourceUri = object.resourceUri ?? "";
    return message;
  },
};

function createBaseAbortInfo(): AbortInfo {
  return { cause: 0, resourceUri: "", projectsMissingPermission: [] };
}

export const AbortInfo: MessageFns<AbortInfo> = {
  encode(message: AbortInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cause !== 0) {
      writer.uint32(8).int32(message.cause);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    for (const v of message.projectsMissingPermission) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AbortInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbortInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cause = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.projectsMissingPermission.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AbortInfo {
    return {
      cause: isSet(object.cause) ? abortInfo_CauseFromJSON(object.cause) : 0,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
      projectsMissingPermission: globalThis.Array.isArray(object?.projectsMissingPermission)
        ? object.projectsMissingPermission.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AbortInfo): unknown {
    const obj: any = {};
    if (message.cause !== 0) {
      obj.cause = abortInfo_CauseToJSON(message.cause);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    if (message.projectsMissingPermission?.length) {
      obj.projectsMissingPermission = message.projectsMissingPermission;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AbortInfo>, I>>(base?: I): AbortInfo {
    return AbortInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AbortInfo>, I>>(object: I): AbortInfo {
    const message = createBaseAbortInfo();
    message.cause = object.cause ?? 0;
    message.resourceUri = object.resourceUri ?? "";
    message.projectsMissingPermission = object.projectsMissingPermission?.map((e) => e) || [];
    return message;
  },
};

function createBaseDropInfo(): DropInfo {
  return { cause: 0, resourceUri: "" };
}

export const DropInfo: MessageFns<DropInfo> = {
  encode(message: DropInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cause !== 0) {
      writer.uint32(8).int32(message.cause);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DropInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cause = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropInfo {
    return {
      cause: isSet(object.cause) ? dropInfo_CauseFromJSON(object.cause) : 0,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
    };
  },

  toJSON(message: DropInfo): unknown {
    const obj: any = {};
    if (message.cause !== 0) {
      obj.cause = dropInfo_CauseToJSON(message.cause);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DropInfo>, I>>(base?: I): DropInfo {
    return DropInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DropInfo>, I>>(object: I): DropInfo {
    const message = createBaseDropInfo();
    message.cause = object.cause ?? 0;
    message.resourceUri = object.resourceUri ?? "";
    return message;
  },
};

function createBaseGKEMasterInfo(): GKEMasterInfo {
  return { clusterUri: "", clusterNetworkUri: "", internalIp: "", externalIp: "" };
}

export const GKEMasterInfo: MessageFns<GKEMasterInfo> = {
  encode(message: GKEMasterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterUri !== "") {
      writer.uint32(18).string(message.clusterUri);
    }
    if (message.clusterNetworkUri !== "") {
      writer.uint32(34).string(message.clusterNetworkUri);
    }
    if (message.internalIp !== "") {
      writer.uint32(42).string(message.internalIp);
    }
    if (message.externalIp !== "") {
      writer.uint32(50).string(message.externalIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GKEMasterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGKEMasterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clusterUri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clusterNetworkUri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalIp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GKEMasterInfo {
    return {
      clusterUri: isSet(object.clusterUri) ? globalThis.String(object.clusterUri) : "",
      clusterNetworkUri: isSet(object.clusterNetworkUri) ? globalThis.String(object.clusterNetworkUri) : "",
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "",
    };
  },

  toJSON(message: GKEMasterInfo): unknown {
    const obj: any = {};
    if (message.clusterUri !== "") {
      obj.clusterUri = message.clusterUri;
    }
    if (message.clusterNetworkUri !== "") {
      obj.clusterNetworkUri = message.clusterNetworkUri;
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GKEMasterInfo>, I>>(base?: I): GKEMasterInfo {
    return GKEMasterInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GKEMasterInfo>, I>>(object: I): GKEMasterInfo {
    const message = createBaseGKEMasterInfo();
    message.clusterUri = object.clusterUri ?? "";
    message.clusterNetworkUri = object.clusterNetworkUri ?? "";
    message.internalIp = object.internalIp ?? "";
    message.externalIp = object.externalIp ?? "";
    return message;
  },
};

function createBaseCloudSQLInstanceInfo(): CloudSQLInstanceInfo {
  return { displayName: "", uri: "", networkUri: "", internalIp: "", externalIp: "", region: "" };
}

export const CloudSQLInstanceInfo: MessageFns<CloudSQLInstanceInfo> = {
  encode(message: CloudSQLInstanceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.networkUri !== "") {
      writer.uint32(34).string(message.networkUri);
    }
    if (message.internalIp !== "") {
      writer.uint32(42).string(message.internalIp);
    }
    if (message.externalIp !== "") {
      writer.uint32(50).string(message.externalIp);
    }
    if (message.region !== "") {
      writer.uint32(58).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSQLInstanceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSQLInstanceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalIp = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.region = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSQLInstanceInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: CloudSQLInstanceInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudSQLInstanceInfo>, I>>(base?: I): CloudSQLInstanceInfo {
    return CloudSQLInstanceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudSQLInstanceInfo>, I>>(object: I): CloudSQLInstanceInfo {
    const message = createBaseCloudSQLInstanceInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.networkUri = object.networkUri ?? "";
    message.internalIp = object.internalIp ?? "";
    message.externalIp = object.externalIp ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseCloudFunctionInfo(): CloudFunctionInfo {
  return { displayName: "", uri: "", location: "", versionId: Long.ZERO };
}

export const CloudFunctionInfo: MessageFns<CloudFunctionInfo> = {
  encode(message: CloudFunctionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    if (!message.versionId.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.versionId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudFunctionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudFunctionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.versionId = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudFunctionInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      versionId: isSet(object.versionId) ? Long.fromValue(object.versionId) : Long.ZERO,
    };
  },

  toJSON(message: CloudFunctionInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (!message.versionId.equals(Long.ZERO)) {
      obj.versionId = (message.versionId || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudFunctionInfo>, I>>(base?: I): CloudFunctionInfo {
    return CloudFunctionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudFunctionInfo>, I>>(object: I): CloudFunctionInfo {
    const message = createBaseCloudFunctionInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.location = object.location ?? "";
    message.versionId = (object.versionId !== undefined && object.versionId !== null)
      ? Long.fromValue(object.versionId)
      : Long.ZERO;
    return message;
  },
};

function createBaseCloudRunRevisionInfo(): CloudRunRevisionInfo {
  return { displayName: "", uri: "", location: "", serviceUri: "" };
}

export const CloudRunRevisionInfo: MessageFns<CloudRunRevisionInfo> = {
  encode(message: CloudRunRevisionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.location !== "") {
      writer.uint32(34).string(message.location);
    }
    if (message.serviceUri !== "") {
      writer.uint32(42).string(message.serviceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRunRevisionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRunRevisionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.serviceUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRunRevisionInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      serviceUri: isSet(object.serviceUri) ? globalThis.String(object.serviceUri) : "",
    };
  },

  toJSON(message: CloudRunRevisionInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.serviceUri !== "") {
      obj.serviceUri = message.serviceUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudRunRevisionInfo>, I>>(base?: I): CloudRunRevisionInfo {
    return CloudRunRevisionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudRunRevisionInfo>, I>>(object: I): CloudRunRevisionInfo {
    const message = createBaseCloudRunRevisionInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.location = object.location ?? "";
    message.serviceUri = object.serviceUri ?? "";
    return message;
  },
};

function createBaseAppEngineVersionInfo(): AppEngineVersionInfo {
  return { displayName: "", uri: "", runtime: "", environment: "" };
}

export const AppEngineVersionInfo: MessageFns<AppEngineVersionInfo> = {
  encode(message: AppEngineVersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.runtime !== "") {
      writer.uint32(26).string(message.runtime);
    }
    if (message.environment !== "") {
      writer.uint32(34).string(message.environment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineVersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineVersionInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
    };
  },

  toJSON(message: AppEngineVersionInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppEngineVersionInfo>, I>>(base?: I): AppEngineVersionInfo {
    return AppEngineVersionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppEngineVersionInfo>, I>>(object: I): AppEngineVersionInfo {
    const message = createBaseAppEngineVersionInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.runtime = object.runtime ?? "";
    message.environment = object.environment ?? "";
    return message;
  },
};

function createBaseVpcConnectorInfo(): VpcConnectorInfo {
  return { displayName: "", uri: "", location: "" };
}

export const VpcConnectorInfo: MessageFns<VpcConnectorInfo> = {
  encode(message: VpcConnectorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpcConnectorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpcConnectorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpcConnectorInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: VpcConnectorInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VpcConnectorInfo>, I>>(base?: I): VpcConnectorInfo {
    return VpcConnectorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VpcConnectorInfo>, I>>(object: I): VpcConnectorInfo {
    const message = createBaseVpcConnectorInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseConnectivityTest(): ConnectivityTest {
  return {
    name: "",
    description: "",
    source: undefined,
    destination: undefined,
    protocol: "",
    relatedProjects: [],
    displayName: "",
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    reachabilityDetails: undefined,
  };
}

export const ConnectivityTest: MessageFns<ConnectivityTest> = {
  encode(message: ConnectivityTest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.source !== undefined) {
      Endpoint.encode(message.source, writer.uint32(26).fork()).join();
    }
    if (message.destination !== undefined) {
      Endpoint.encode(message.destination, writer.uint32(34).fork()).join();
    }
    if (message.protocol !== "") {
      writer.uint32(42).string(message.protocol);
    }
    for (const v of message.relatedProjects) {
      writer.uint32(50).string(v!);
    }
    if (message.displayName !== "") {
      writer.uint32(58).string(message.displayName);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ConnectivityTest_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    if (message.reachabilityDetails !== undefined) {
      ReachabilityDetails.encode(message.reachabilityDetails, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectivityTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectivityTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = Endpoint.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destination = Endpoint.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.protocol = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.relatedProjects.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = ConnectivityTest_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.reachabilityDetails = ReachabilityDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectivityTest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      source: isSet(object.source) ? Endpoint.fromJSON(object.source) : undefined,
      destination: isSet(object.destination) ? Endpoint.fromJSON(object.destination) : undefined,
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      relatedProjects: globalThis.Array.isArray(object?.relatedProjects)
        ? object.relatedProjects.map((e: any) => globalThis.String(e))
        : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      reachabilityDetails: isSet(object.reachabilityDetails)
        ? ReachabilityDetails.fromJSON(object.reachabilityDetails)
        : undefined,
    };
  },

  toJSON(message: ConnectivityTest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.source !== undefined) {
      obj.source = Endpoint.toJSON(message.source);
    }
    if (message.destination !== undefined) {
      obj.destination = Endpoint.toJSON(message.destination);
    }
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.relatedProjects?.length) {
      obj.relatedProjects = message.relatedProjects;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.reachabilityDetails !== undefined) {
      obj.reachabilityDetails = ReachabilityDetails.toJSON(message.reachabilityDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectivityTest>, I>>(base?: I): ConnectivityTest {
    return ConnectivityTest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectivityTest>, I>>(object: I): ConnectivityTest {
    const message = createBaseConnectivityTest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? Endpoint.fromPartial(object.source)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? Endpoint.fromPartial(object.destination)
      : undefined;
    message.protocol = object.protocol ?? "";
    message.relatedProjects = object.relatedProjects?.map((e) => e) || [];
    message.displayName = object.displayName ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.reachabilityDetails = (object.reachabilityDetails !== undefined && object.reachabilityDetails !== null)
      ? ReachabilityDetails.fromPartial(object.reachabilityDetails)
      : undefined;
    return message;
  },
};

function createBaseConnectivityTest_LabelsEntry(): ConnectivityTest_LabelsEntry {
  return { key: "", value: "" };
}

export const ConnectivityTest_LabelsEntry: MessageFns<ConnectivityTest_LabelsEntry> = {
  encode(message: ConnectivityTest_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectivityTest_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectivityTest_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectivityTest_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConnectivityTest_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectivityTest_LabelsEntry>, I>>(base?: I): ConnectivityTest_LabelsEntry {
    return ConnectivityTest_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectivityTest_LabelsEntry>, I>>(object: I): ConnectivityTest_LabelsEntry {
    const message = createBaseConnectivityTest_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEndpoint(): Endpoint {
  return {
    ipAddress: "",
    port: 0,
    instance: "",
    gkeMasterCluster: "",
    cloudSqlInstance: "",
    cloudFunction: undefined,
    appEngineVersion: undefined,
    cloudRunRevision: undefined,
    network: "",
    networkType: 0,
    projectId: "",
  };
}

export const Endpoint: MessageFns<Endpoint> = {
  encode(message: Endpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.instance !== "") {
      writer.uint32(26).string(message.instance);
    }
    if (message.gkeMasterCluster !== "") {
      writer.uint32(58).string(message.gkeMasterCluster);
    }
    if (message.cloudSqlInstance !== "") {
      writer.uint32(66).string(message.cloudSqlInstance);
    }
    if (message.cloudFunction !== undefined) {
      Endpoint_CloudFunctionEndpoint.encode(message.cloudFunction, writer.uint32(82).fork()).join();
    }
    if (message.appEngineVersion !== undefined) {
      Endpoint_AppEngineVersionEndpoint.encode(message.appEngineVersion, writer.uint32(90).fork()).join();
    }
    if (message.cloudRunRevision !== undefined) {
      Endpoint_CloudRunRevisionEndpoint.encode(message.cloudRunRevision, writer.uint32(98).fork()).join();
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    if (message.networkType !== 0) {
      writer.uint32(40).int32(message.networkType);
    }
    if (message.projectId !== "") {
      writer.uint32(50).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instance = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gkeMasterCluster = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cloudSqlInstance = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cloudFunction = Endpoint_CloudFunctionEndpoint.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.appEngineVersion = Endpoint_AppEngineVersionEndpoint.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.cloudRunRevision = Endpoint_CloudRunRevisionEndpoint.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.networkType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      gkeMasterCluster: isSet(object.gkeMasterCluster) ? globalThis.String(object.gkeMasterCluster) : "",
      cloudSqlInstance: isSet(object.cloudSqlInstance) ? globalThis.String(object.cloudSqlInstance) : "",
      cloudFunction: isSet(object.cloudFunction)
        ? Endpoint_CloudFunctionEndpoint.fromJSON(object.cloudFunction)
        : undefined,
      appEngineVersion: isSet(object.appEngineVersion)
        ? Endpoint_AppEngineVersionEndpoint.fromJSON(object.appEngineVersion)
        : undefined,
      cloudRunRevision: isSet(object.cloudRunRevision)
        ? Endpoint_CloudRunRevisionEndpoint.fromJSON(object.cloudRunRevision)
        : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      networkType: isSet(object.networkType) ? endpoint_NetworkTypeFromJSON(object.networkType) : 0,
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.gkeMasterCluster !== "") {
      obj.gkeMasterCluster = message.gkeMasterCluster;
    }
    if (message.cloudSqlInstance !== "") {
      obj.cloudSqlInstance = message.cloudSqlInstance;
    }
    if (message.cloudFunction !== undefined) {
      obj.cloudFunction = Endpoint_CloudFunctionEndpoint.toJSON(message.cloudFunction);
    }
    if (message.appEngineVersion !== undefined) {
      obj.appEngineVersion = Endpoint_AppEngineVersionEndpoint.toJSON(message.appEngineVersion);
    }
    if (message.cloudRunRevision !== undefined) {
      obj.cloudRunRevision = Endpoint_CloudRunRevisionEndpoint.toJSON(message.cloudRunRevision);
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.networkType !== 0) {
      obj.networkType = endpoint_NetworkTypeToJSON(message.networkType);
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint>, I>>(base?: I): Endpoint {
    return Endpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint>, I>>(object: I): Endpoint {
    const message = createBaseEndpoint();
    message.ipAddress = object.ipAddress ?? "";
    message.port = object.port ?? 0;
    message.instance = object.instance ?? "";
    message.gkeMasterCluster = object.gkeMasterCluster ?? "";
    message.cloudSqlInstance = object.cloudSqlInstance ?? "";
    message.cloudFunction = (object.cloudFunction !== undefined && object.cloudFunction !== null)
      ? Endpoint_CloudFunctionEndpoint.fromPartial(object.cloudFunction)
      : undefined;
    message.appEngineVersion = (object.appEngineVersion !== undefined && object.appEngineVersion !== null)
      ? Endpoint_AppEngineVersionEndpoint.fromPartial(object.appEngineVersion)
      : undefined;
    message.cloudRunRevision = (object.cloudRunRevision !== undefined && object.cloudRunRevision !== null)
      ? Endpoint_CloudRunRevisionEndpoint.fromPartial(object.cloudRunRevision)
      : undefined;
    message.network = object.network ?? "";
    message.networkType = object.networkType ?? 0;
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseEndpoint_CloudFunctionEndpoint(): Endpoint_CloudFunctionEndpoint {
  return { uri: "" };
}

export const Endpoint_CloudFunctionEndpoint: MessageFns<Endpoint_CloudFunctionEndpoint> = {
  encode(message: Endpoint_CloudFunctionEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_CloudFunctionEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_CloudFunctionEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_CloudFunctionEndpoint {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Endpoint_CloudFunctionEndpoint): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint_CloudFunctionEndpoint>, I>>(base?: I): Endpoint_CloudFunctionEndpoint {
    return Endpoint_CloudFunctionEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint_CloudFunctionEndpoint>, I>>(
    object: I,
  ): Endpoint_CloudFunctionEndpoint {
    const message = createBaseEndpoint_CloudFunctionEndpoint();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseEndpoint_AppEngineVersionEndpoint(): Endpoint_AppEngineVersionEndpoint {
  return { uri: "" };
}

export const Endpoint_AppEngineVersionEndpoint: MessageFns<Endpoint_AppEngineVersionEndpoint> = {
  encode(message: Endpoint_AppEngineVersionEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_AppEngineVersionEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_AppEngineVersionEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_AppEngineVersionEndpoint {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Endpoint_AppEngineVersionEndpoint): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint_AppEngineVersionEndpoint>, I>>(
    base?: I,
  ): Endpoint_AppEngineVersionEndpoint {
    return Endpoint_AppEngineVersionEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint_AppEngineVersionEndpoint>, I>>(
    object: I,
  ): Endpoint_AppEngineVersionEndpoint {
    const message = createBaseEndpoint_AppEngineVersionEndpoint();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseEndpoint_CloudRunRevisionEndpoint(): Endpoint_CloudRunRevisionEndpoint {
  return { uri: "" };
}

export const Endpoint_CloudRunRevisionEndpoint: MessageFns<Endpoint_CloudRunRevisionEndpoint> = {
  encode(message: Endpoint_CloudRunRevisionEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_CloudRunRevisionEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_CloudRunRevisionEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_CloudRunRevisionEndpoint {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Endpoint_CloudRunRevisionEndpoint): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint_CloudRunRevisionEndpoint>, I>>(
    base?: I,
  ): Endpoint_CloudRunRevisionEndpoint {
    return Endpoint_CloudRunRevisionEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint_CloudRunRevisionEndpoint>, I>>(
    object: I,
  ): Endpoint_CloudRunRevisionEndpoint {
    const message = createBaseEndpoint_CloudRunRevisionEndpoint();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseReachabilityDetails(): ReachabilityDetails {
  return { result: 0, verifyTime: undefined, error: undefined, traces: [] };
}

export const ReachabilityDetails: MessageFns<ReachabilityDetails> = {
  encode(message: ReachabilityDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.verifyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.verifyTime), writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(26).fork()).join();
    }
    for (const v of message.traces) {
      Trace.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReachabilityDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReachabilityDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.traces.push(Trace.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReachabilityDetails {
    return {
      result: isSet(object.result) ? reachabilityDetails_ResultFromJSON(object.result) : 0,
      verifyTime: isSet(object.verifyTime) ? fromJsonTimestamp(object.verifyTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      traces: globalThis.Array.isArray(object?.traces) ? object.traces.map((e: any) => Trace.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReachabilityDetails): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = reachabilityDetails_ResultToJSON(message.result);
    }
    if (message.verifyTime !== undefined) {
      obj.verifyTime = message.verifyTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.traces?.length) {
      obj.traces = message.traces.map((e) => Trace.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReachabilityDetails>, I>>(base?: I): ReachabilityDetails {
    return ReachabilityDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReachabilityDetails>, I>>(object: I): ReachabilityDetails {
    const message = createBaseReachabilityDetails();
    message.result = object.result ?? 0;
    message.verifyTime = object.verifyTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.traces = object.traces?.map((e) => Trace.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConnectivityTestEventData(): ConnectivityTestEventData {
  return { payload: undefined };
}

export const ConnectivityTestEventData: MessageFns<ConnectivityTestEventData> = {
  encode(message: ConnectivityTestEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ConnectivityTest.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectivityTestEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectivityTestEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ConnectivityTest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectivityTestEventData {
    return { payload: isSet(object.payload) ? ConnectivityTest.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ConnectivityTestEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ConnectivityTest.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectivityTestEventData>, I>>(base?: I): ConnectivityTestEventData {
    return ConnectivityTestEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectivityTestEventData>, I>>(object: I): ConnectivityTestEventData {
    const message = createBaseConnectivityTestEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ConnectivityTest.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
