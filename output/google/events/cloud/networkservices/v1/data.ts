// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/networkservices/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration";
import { Timestamp } from "../../../../protobuf/timestamp";

export const protobufPackage = "google.events.cloud.networkservices.v1";

/** Specification of a port-based selector. */
export interface TrafficPortSelector {
  /**
   * Optional. A list of ports. Can be port numbers or port range
   * (example, [80-90] specifies all ports from 80 to 90, including
   * 80 and 90) or named ports or * to specify all ports. If the
   * list is empty, all ports are selected.
   */
  ports: string[];
}

/**
 * A definition of a matcher that selects endpoints to which the policies
 * should be applied.
 */
export interface EndpointMatcher {
  /** The matcher is based on node metadata presented by xDS clients. */
  metadataLabelMatcher?: EndpointMatcher_MetadataLabelMatcher | undefined;
}

/** The matcher that is based on node metadata presented by xDS clients. */
export interface EndpointMatcher_MetadataLabelMatcher {
  /**
   * Specifies how matching should be done.
   *
   * Supported values are:
   * MATCH_ANY: At least one of the Labels specified in the
   *   matcher should match the metadata presented by xDS client.
   * MATCH_ALL: The metadata presented by the xDS client should
   *   contain all of the labels specified here.
   *
   * The selection is determined based on the best match. For
   * example, suppose there are three EndpointPolicy
   * resources P1, P2 and P3 and if P1 has a the matcher as
   * MATCH_ANY <A:1, B:1>, P2 has MATCH_ALL <A:1,B:1>, and P3 has
   * MATCH_ALL <A:1,B:1,C:1>.
   *
   * If a client with label <A:1> connects, the config from P1
   * will be selected.
   *
   * If a client with label <A:1,B:1> connects, the config from P2
   * will be selected.
   *
   * If a client with label <A:1,B:1,C:1> connects, the config
   * from P3 will be selected.
   *
   * If there is more than one best match, (for example, if a
   * config P4 with selector <A:1,D:1> exists and if a client with
   * label <A:1,B:1,D:1> connects), an error will be thrown.
   */
  metadataLabelMatchCriteria: EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria;
  /**
   * The list of label value pairs that must match labels in the
   * provided metadata based on filterMatchCriteria This list can
   * have at most 64 entries. The list can be empty if the match
   * criteria is MATCH_ANY, to specify a wildcard match (i.e this
   * matches any client).
   */
  metadataLabels: EndpointMatcher_MetadataLabelMatcher_MetadataLabels[];
}

/** Possible criteria values that define logic of how matching is made. */
export enum EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria {
  /** METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED - Default value. Should not be used. */
  METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED = 0,
  /**
   * MATCH_ANY - At least one of the Labels specified in the matcher should match the
   * metadata presented by xDS client.
   */
  MATCH_ANY = 1,
  /**
   * MATCH_ALL - The metadata presented by the xDS client should contain all of the
   * labels specified here.
   */
  MATCH_ALL = 2,
  UNRECOGNIZED = -1,
}

export function endpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteriaFromJSON(
  object: any,
): EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria {
  switch (object) {
    case 0:
    case "METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED":
      return EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED;
    case 1:
    case "MATCH_ANY":
      return EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.MATCH_ANY;
    case 2:
    case "MATCH_ALL":
      return EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.MATCH_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.UNRECOGNIZED;
  }
}

export function endpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteriaToJSON(
  object: EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria,
): string {
  switch (object) {
    case EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED:
      return "METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED";
    case EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.MATCH_ANY:
      return "MATCH_ANY";
    case EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.MATCH_ALL:
      return "MATCH_ALL";
    case EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines a name-pair value for a single label. */
export interface EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
  /** Required. Label name presented as key in xDS Node Metadata. */
  labelName: string;
  /**
   * Required. Label value presented as value corresponding to the above
   * key, in xDS Node Metadata.
   */
  labelValue: string;
}

/**
 * EndpointPolicy is a resource that helps apply desired configuration
 * on the endpoints that match specific criteria.
 * For example, this resource can be used to apply "authentication config"
 * an all endpoints that serve on port 8080.
 */
export interface EndpointPolicy {
  /**
   * Required. Name of the EndpointPolicy resource. It matches pattern
   * `projects/{project}/locations/global/endpointPolicies/{endpoint_policy}`.
   */
  name: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime?:
    | Date
    | undefined;
  /** Optional. Set of label tags associated with the EndpointPolicy resource. */
  labels: { [key: string]: string };
  /**
   * Required. The type of endpoint policy. This is primarily used to validate
   * the configuration.
   */
  type: EndpointPolicy_EndpointPolicyType;
  /**
   * Optional. This field specifies the URL of AuthorizationPolicy resource that
   * applies authorization policies to the inbound traffic at the
   * matched endpoints. Refer to Authorization. If this field is not
   * specified, authorization is disabled(no authz checks) for this
   * endpoint.
   */
  authorizationPolicy: string;
  /**
   * Required. A matcher that selects endpoints to which the policies should be
   * applied.
   */
  endpointMatcher?:
    | EndpointMatcher
    | undefined;
  /**
   * Optional. Port selector for the (matched) endpoints. If no port selector is
   * provided, the matched config is applied to all ports.
   */
  trafficPortSelector?:
    | TrafficPortSelector
    | undefined;
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Optional. A URL referring to ServerTlsPolicy resource. ServerTlsPolicy is
   * used to determine the authentication policy to be applied to terminate the
   * inbound traffic at the identified backends. If this field is not set,
   * authentication is disabled(open) for this endpoint.
   */
  serverTlsPolicy: string;
  /**
   * Optional. A URL referring to a ClientTlsPolicy resource. ClientTlsPolicy
   * can be set to specify the authentication for traffic from the proxy to the
   * actual endpoints. More specifically, it is applied to the outgoing traffic
   * from the proxy to the endpoint. This is typically used for sidecar model
   * where the proxy identifies itself as endpoint to the control plane, with
   * the connection between sidecar and endpoint requiring authentication. If
   * this field is not set, authentication is disabled(open). Applicable only
   * when EndpointPolicyType is SIDECAR_PROXY.
   */
  clientTlsPolicy: string;
}

/** The type of endpoint policy. */
export enum EndpointPolicy_EndpointPolicyType {
  /** ENDPOINT_POLICY_TYPE_UNSPECIFIED - Default value. Must not be used. */
  ENDPOINT_POLICY_TYPE_UNSPECIFIED = 0,
  /** SIDECAR_PROXY - Represents a proxy deployed as a sidecar. */
  SIDECAR_PROXY = 1,
  /** GRPC_SERVER - Represents a proxyless gRPC backend. */
  GRPC_SERVER = 2,
  UNRECOGNIZED = -1,
}

export function endpointPolicy_EndpointPolicyTypeFromJSON(object: any): EndpointPolicy_EndpointPolicyType {
  switch (object) {
    case 0:
    case "ENDPOINT_POLICY_TYPE_UNSPECIFIED":
      return EndpointPolicy_EndpointPolicyType.ENDPOINT_POLICY_TYPE_UNSPECIFIED;
    case 1:
    case "SIDECAR_PROXY":
      return EndpointPolicy_EndpointPolicyType.SIDECAR_PROXY;
    case 2:
    case "GRPC_SERVER":
      return EndpointPolicy_EndpointPolicyType.GRPC_SERVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EndpointPolicy_EndpointPolicyType.UNRECOGNIZED;
  }
}

export function endpointPolicy_EndpointPolicyTypeToJSON(object: EndpointPolicy_EndpointPolicyType): string {
  switch (object) {
    case EndpointPolicy_EndpointPolicyType.ENDPOINT_POLICY_TYPE_UNSPECIFIED:
      return "ENDPOINT_POLICY_TYPE_UNSPECIFIED";
    case EndpointPolicy_EndpointPolicyType.SIDECAR_PROXY:
      return "SIDECAR_PROXY";
    case EndpointPolicy_EndpointPolicyType.GRPC_SERVER:
      return "GRPC_SERVER";
    case EndpointPolicy_EndpointPolicyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EndpointPolicy_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Gateway represents the configuration for a proxy, typically a load balancer.
 * It captures the ip:port over which the services are exposed by the proxy,
 * along with any policy configurations. Routes have reference to to Gateways to
 * dictate how requests should be routed by this Gateway.
 */
export interface Gateway {
  /**
   * Required. Name of the Gateway resource. It matches pattern
   * `projects/* /locations/* /gateways/<gateway_name>`.
   */
  name: string;
  /** Output only. Server-defined URL of this resource */
  selfLink: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime?:
    | Date
    | undefined;
  /** Optional. Set of label tags associated with the Gateway resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Immutable. The type of the customer managed gateway.
   * This field is required. If unspecified, an error is returned.
   */
  type: Gateway_Type;
  /**
   * Optional. Zero or one IPv4 or IPv6 address on which the Gateway will
   * receive the traffic. When no address is provided, an IP from the subnetwork
   * is allocated
   *
   * This field only applies to gateways of type 'SECURE_WEB_GATEWAY'.
   * Gateways of type 'OPEN_MESH' listen on 0.0.0.0 for IPv4 and :: for IPv6.
   */
  addresses: string[];
  /**
   * Required. One or more port numbers (1-65535), on which the Gateway will
   * receive traffic. The proxy binds to the specified ports.
   * Gateways of type 'SECURE_WEB_GATEWAY' are limited to 1 port.
   * Gateways of type 'OPEN_MESH' listen on 0.0.0.0 for IPv4 and :: for IPv6 and
   * support multiple ports.
   */
  ports: number[];
  /**
   * Optional. Scope determines how configuration across multiple Gateway
   * instances are merged. The configuration for multiple Gateway instances with
   * the same scope will be merged as presented as a single coniguration to the
   * proxy/load balancer.
   *
   * Max length 64 characters.
   * Scope should start with a letter and can only have letters, numbers,
   * hyphens.
   */
  scope: string;
  /**
   * Optional. A fully-qualified ServerTLSPolicy URL reference. Specifies how
   * TLS traffic is terminated. If empty, TLS termination is disabled.
   */
  serverTlsPolicy: string;
  /**
   * Optional. A fully-qualified Certificates URL reference. The proxy presents
   * a Certificate (selected based on SNI) when establishing a TLS connection.
   * This feature only applies to gateways of type 'SECURE_WEB_GATEWAY'.
   */
  certificateUrls: string[];
  /**
   * Optional. A fully-qualified GatewaySecurityPolicy URL reference.
   * Defines how a server should apply security policy to inbound
   * (VM to Proxy) initiated connections.
   *
   * For example:
   * `projects/* /locations/* /gatewaySecurityPolicies/swg-policy`.
   *
   * This policy is specific to gateways of type 'SECURE_WEB_GATEWAY'.
   */
  gatewaySecurityPolicy: string;
  /**
   * Optional. The relative resource name identifying the VPC network that is
   * using this configuration. For example:
   * `projects/* /global/networks/network-1`.
   *
   * Currently, this field is specific to gateways of type 'SECURE_WEB_GATEWAY'.
   */
  network: string;
  /**
   * Optional. The relative resource name identifying  the subnetwork in which
   * this SWG is allocated. For example:
   * `projects/* /regions/us-central1/subnetworks/network-1`
   *
   * Currently, this field is specific to gateways of type 'SECURE_WEB_GATEWAY".
   */
  subnetwork: string;
}

/**
 * The type of the customer-managed gateway.
 * Possible values are:
 * * OPEN_MESH
 * * SECURE_WEB_GATEWAY
 */
export enum Gateway_Type {
  /** TYPE_UNSPECIFIED - The type of the customer managed gateway is unspecified. */
  TYPE_UNSPECIFIED = 0,
  /**
   * OPEN_MESH - The type of the customer managed gateway is TrafficDirector Open
   * Mesh.
   */
  OPEN_MESH = 1,
  /** SECURE_WEB_GATEWAY - The type of the customer managed gateway is SecureWebGateway (SWG). */
  SECURE_WEB_GATEWAY = 2,
  UNRECOGNIZED = -1,
}

export function gateway_TypeFromJSON(object: any): Gateway_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Gateway_Type.TYPE_UNSPECIFIED;
    case 1:
    case "OPEN_MESH":
      return Gateway_Type.OPEN_MESH;
    case 2:
    case "SECURE_WEB_GATEWAY":
      return Gateway_Type.SECURE_WEB_GATEWAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Gateway_Type.UNRECOGNIZED;
  }
}

export function gateway_TypeToJSON(object: Gateway_Type): string {
  switch (object) {
    case Gateway_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Gateway_Type.OPEN_MESH:
      return "OPEN_MESH";
    case Gateway_Type.SECURE_WEB_GATEWAY:
      return "SECURE_WEB_GATEWAY";
    case Gateway_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Gateway_LabelsEntry {
  key: string;
  value: string;
}

/**
 * GrpcRoute is the resource defining how gRPC traffic routed by a Mesh
 * or Gateway resource is routed.
 */
export interface GrpcRoute {
  /**
   * Required. Name of the GrpcRoute resource. It matches pattern
   * `projects/* /locations/global/grpcRoutes/<grpc_route_name>`
   */
  name: string;
  /** Output only. Server-defined URL of this resource */
  selfLink: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime?:
    | Date
    | undefined;
  /** Optional. Set of label tags associated with the GrpcRoute resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Required. Service hostnames with an optional port for which this route
   * describes traffic.
   *
   * Format: <hostname>[:<port>]
   *
   * Hostname is the fully qualified domain name of a network host. This matches
   * the RFC 1123 definition of a hostname with 2 notable exceptions:
   *  - IPs are not allowed.
   *  - A hostname may be prefixed with a wildcard label (`*.`). The wildcard
   *    label must appear by itself as the first label.
   *
   * Hostname can be "precise" which is a domain name without the terminating
   * dot of a network host (e.g. `foo.example.com`) or "wildcard", which is a
   * domain name prefixed with a single wildcard label (e.g. `*.example.com`).
   *
   * Note that as per RFC1035 and RFC1123, a label must consist of lower case
   * alphanumeric characters or '-', and must start and end with an alphanumeric
   * character. No other punctuation is allowed.
   *
   * The routes associated with a Mesh or Gateway must have unique hostnames. If
   * you attempt to attach multiple routes with conflicting hostnames, the
   * configuration will be rejected.
   *
   * For example, while it is acceptable for routes for the hostnames
   * `*.foo.bar.com` and `*.bar.com` to be associated with the same route, it is
   * not possible to associate two routes both with `*.bar.com` or both with
   * `bar.com`.
   *
   * If a port is specified, then gRPC clients must use the channel URI with the
   * port to match this rule (i.e. "xds:///service:123"), otherwise they must
   * supply the URI without a port (i.e. "xds:///service").
   */
  hostnames: string[];
  /**
   * Optional. Meshes defines a list of meshes this GrpcRoute is attached to, as
   * one of the routing rules to route the requests served by the mesh.
   *
   * Each mesh reference should match the pattern:
   * `projects/* /locations/global/meshes/<mesh_name>`
   */
  meshes: string[];
  /**
   * Optional. Gateways defines a list of gateways this GrpcRoute is attached
   * to, as one of the routing rules to route the requests served by the
   * gateway.
   *
   * Each gateway reference should match the pattern:
   * `projects/* /locations/global/gateways/<gateway_name>`
   */
  gateways: string[];
  /**
   * Required. A list of detailed rules defining how to route traffic.
   *
   * Within a single GrpcRoute, the GrpcRoute.RouteAction associated with the
   * first matching GrpcRoute.RouteRule will be executed. At least one rule
   * must be supplied.
   */
  rules: GrpcRoute_RouteRule[];
}

/** Specifies a match against a method. */
export interface GrpcRoute_MethodMatch {
  /**
   * Optional. Specifies how to match against the name. If not specified, a
   * default value of "EXACT" is used.
   */
  type: GrpcRoute_MethodMatch_Type;
  /**
   * Required. Name of the service to match against. If unspecified, will
   * match all services.
   */
  grpcService: string;
  /**
   * Required. Name of the method to match against. If unspecified, will match
   * all methods.
   */
  grpcMethod: string;
  /**
   * Optional. Specifies that matches are case sensitive.  The default value
   * is true. case_sensitive must not be used with a type of
   * REGULAR_EXPRESSION.
   */
  caseSensitive?: boolean | undefined;
}

/** The type of the match. */
export enum GrpcRoute_MethodMatch_Type {
  /** TYPE_UNSPECIFIED - Unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** EXACT - Will only match the exact name provided. */
  EXACT = 1,
  /**
   * REGULAR_EXPRESSION - Will interpret grpc_method and grpc_service as regexes. RE2 syntax is
   * supported.
   */
  REGULAR_EXPRESSION = 2,
  UNRECOGNIZED = -1,
}

export function grpcRoute_MethodMatch_TypeFromJSON(object: any): GrpcRoute_MethodMatch_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return GrpcRoute_MethodMatch_Type.TYPE_UNSPECIFIED;
    case 1:
    case "EXACT":
      return GrpcRoute_MethodMatch_Type.EXACT;
    case 2:
    case "REGULAR_EXPRESSION":
      return GrpcRoute_MethodMatch_Type.REGULAR_EXPRESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GrpcRoute_MethodMatch_Type.UNRECOGNIZED;
  }
}

export function grpcRoute_MethodMatch_TypeToJSON(object: GrpcRoute_MethodMatch_Type): string {
  switch (object) {
    case GrpcRoute_MethodMatch_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case GrpcRoute_MethodMatch_Type.EXACT:
      return "EXACT";
    case GrpcRoute_MethodMatch_Type.REGULAR_EXPRESSION:
      return "REGULAR_EXPRESSION";
    case GrpcRoute_MethodMatch_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A match against a collection of headers. */
export interface GrpcRoute_HeaderMatch {
  /**
   * Optional. Specifies how to match against the value of the header. If not
   * specified, a default value of EXACT is used.
   */
  type: GrpcRoute_HeaderMatch_Type;
  /** Required. The key of the header. */
  key: string;
  /** Required. The value of the header. */
  value: string;
}

/** The type of match. */
export enum GrpcRoute_HeaderMatch_Type {
  /** TYPE_UNSPECIFIED - Unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** EXACT - Will only match the exact value provided. */
  EXACT = 1,
  /**
   * REGULAR_EXPRESSION - Will match paths conforming to the prefix specified by value. RE2
   * syntax is supported.
   */
  REGULAR_EXPRESSION = 2,
  UNRECOGNIZED = -1,
}

export function grpcRoute_HeaderMatch_TypeFromJSON(object: any): GrpcRoute_HeaderMatch_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return GrpcRoute_HeaderMatch_Type.TYPE_UNSPECIFIED;
    case 1:
    case "EXACT":
      return GrpcRoute_HeaderMatch_Type.EXACT;
    case 2:
    case "REGULAR_EXPRESSION":
      return GrpcRoute_HeaderMatch_Type.REGULAR_EXPRESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GrpcRoute_HeaderMatch_Type.UNRECOGNIZED;
  }
}

export function grpcRoute_HeaderMatch_TypeToJSON(object: GrpcRoute_HeaderMatch_Type): string {
  switch (object) {
    case GrpcRoute_HeaderMatch_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case GrpcRoute_HeaderMatch_Type.EXACT:
      return "EXACT";
    case GrpcRoute_HeaderMatch_Type.REGULAR_EXPRESSION:
      return "REGULAR_EXPRESSION";
    case GrpcRoute_HeaderMatch_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Criteria for matching traffic. A RouteMatch will be considered to match
 * when all supplied fields match.
 */
export interface GrpcRoute_RouteMatch {
  /**
   * Optional. A gRPC method to match against. If this field is empty or
   * omitted, will match all methods.
   */
  method?:
    | GrpcRoute_MethodMatch
    | undefined;
  /** Optional. Specifies a collection of headers to match. */
  headers: GrpcRoute_HeaderMatch[];
}

/** The destination to which traffic will be routed. */
export interface GrpcRoute_Destination {
  /**
   * Required. The URL of a destination service to which to route traffic.
   * Must refer to either a BackendService or ServiceDirectoryService.
   */
  serviceName?:
    | string
    | undefined;
  /**
   * Optional. Specifies the proportion of requests forwarded to the backend
   * referenced by the serviceName field. This is computed as:
   *         weight/Sum(weights in this destination list).
   * For non-zero values, there may be some epsilon from the exact proportion
   * defined here depending on the precision an implementation supports.
   *
   * If only one serviceName is specified and it has a weight greater than 0,
   * 100% of the traffic is forwarded to that backend.
   *
   * If weights are specified for any one service name, they need to be
   * specified for all of them.
   *
   * If weights are unspecified for all services, then, traffic is distributed
   * in equal proportions to all of them.
   */
  weight?: number | undefined;
}

/**
 * The specification for fault injection introduced into traffic to test the
 * resiliency of clients to destination service failure. As part of fault
 * injection, when clients send requests to a destination, delays can be
 * introduced on a percentage of requests before sending those requests to the
 * destination service. Similarly requests from clients can be aborted by for
 * a percentage of requests.
 */
export interface GrpcRoute_FaultInjectionPolicy {
  /** The specification for injecting delay to client requests. */
  delay?:
    | GrpcRoute_FaultInjectionPolicy_Delay
    | undefined;
  /** The specification for aborting to client requests. */
  abort?: GrpcRoute_FaultInjectionPolicy_Abort | undefined;
}

/**
 * Specification of how client requests are delayed as part of fault
 * injection before being sent to a destination.
 */
export interface GrpcRoute_FaultInjectionPolicy_Delay {
  /** Specify a fixed delay before forwarding the request. */
  fixedDelay?:
    | Duration
    | undefined;
  /**
   * The percentage of traffic on which delay will be injected.
   *
   * The value must be between [0, 100]
   */
  percentage?: number | undefined;
}

/**
 * Specification of how client requests are aborted as part of fault
 * injection before being sent to a destination.
 */
export interface GrpcRoute_FaultInjectionPolicy_Abort {
  /**
   * The HTTP status code used to abort the request.
   *
   * The value must be between 200 and 599 inclusive.
   */
  httpStatus?:
    | number
    | undefined;
  /**
   * The percentage of traffic which will be aborted.
   *
   * The value must be between [0, 100]
   */
  percentage?: number | undefined;
}

/** The specifications for retries. */
export interface GrpcRoute_RetryPolicy {
  /**
   * - connect-failure: Router will retry on failures connecting to Backend
   *    Services, for example due to connection timeouts.
   * - refused-stream: Router will retry if the backend service resets the
   * stream
   *    with a REFUSED_STREAM error code. This reset type indicates that it is
   *    safe to retry.
   * - cancelled: Router will retry if the gRPC status code in the response
   * header
   *    is set to cancelled
   * - deadline-exceeded: Router will retry if the gRPC status code in the
   * response
   *    header is set to deadline-exceeded
   * - resource-exhausted: Router will retry if the gRPC status code in the
   *    response header is set to resource-exhausted
   * - unavailable: Router will retry if the gRPC status code in the response
   *    header is set to unavailable
   */
  retryConditions: string[];
  /**
   * Specifies the allowed number of retries. This number must be > 0. If not
   * specified, default to 1.
   */
  numRetries: number;
}

/** Specifies how to route matched traffic. */
export interface GrpcRoute_RouteAction {
  /**
   * Optional. The destination services to which traffic should be forwarded.
   * If multiple destinations are specified, traffic will be split between
   * Backend Service(s) according to the weight field of these destinations.
   */
  destinations: GrpcRoute_Destination[];
  /**
   * Optional. The specification for fault injection introduced into traffic
   * to test the resiliency of clients to destination service failure. As part
   * of fault injection, when clients send requests to a destination, delays
   * can be introduced on a percentage of requests before sending those
   * requests to the destination service. Similarly requests from clients can
   * be aborted by for a percentage of requests.
   *
   * timeout and retry_policy will be ignored by clients that are configured
   * with a fault_injection_policy
   */
  faultInjectionPolicy?:
    | GrpcRoute_FaultInjectionPolicy
    | undefined;
  /**
   * Optional. Specifies the timeout for selected route. Timeout is computed
   * from the time the request has been fully processed (i.e. end of stream)
   * up until the response has been completely processed. Timeout includes all
   * retries.
   */
  timeout?:
    | Duration
    | undefined;
  /** Optional. Specifies the retry policy associated with this route. */
  retryPolicy?: GrpcRoute_RetryPolicy | undefined;
}

/** Describes how to route traffic. */
export interface GrpcRoute_RouteRule {
  /**
   * Optional. Matches define conditions used for matching the rule against
   * incoming gRPC requests. Each match is independent, i.e. this rule will be
   * matched if ANY one of the matches is satisfied.  If no matches field is
   * specified, this rule will unconditionally match traffic.
   */
  matches: GrpcRoute_RouteMatch[];
  /**
   * Required. A detailed rule defining how to route traffic. This field is
   * required.
   */
  action?: GrpcRoute_RouteAction | undefined;
}

export interface GrpcRoute_LabelsEntry {
  key: string;
  value: string;
}

/**
 * HttpRoute is the resource defining how HTTP traffic should be routed by a
 * Mesh or Gateway resource.
 */
export interface HttpRoute {
  /**
   * Required. Name of the HttpRoute resource. It matches pattern
   * `projects/* /locations/global/httpRoutes/http_route_name>`.
   */
  name: string;
  /** Output only. Server-defined URL of this resource */
  selfLink: string;
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Required. Hostnames define a set of hosts that should match against the
   * HTTP host header to select a HttpRoute to process the request. Hostname is
   * the fully qualified domain name of a network host, as defined by RFC 1123
   * with the exception that:
   *  - IPs are not allowed.
   *  - A hostname may be prefixed with a wildcard label (`*.`). The wildcard
   *    label must appear by itself as the first label.
   *
   * Hostname can be "precise" which is a domain name without the terminating
   * dot of a network host (e.g. `foo.example.com`) or "wildcard", which is a
   * domain name prefixed with a single wildcard label (e.g. `*.example.com`).
   *
   * Note that as per RFC1035 and RFC1123, a label must consist of lower case
   * alphanumeric characters or '-', and must start and end with an alphanumeric
   * character. No other punctuation is allowed.
   *
   * The routes associated with a Mesh or Gateways  must have unique hostnames.
   * If you attempt to attach multiple routes with conflicting hostnames,
   * the configuration will be rejected.
   *
   * For example, while it is acceptable for routes for the hostnames
   * `*.foo.bar.com` and `*.bar.com` to be associated with the same Mesh (or
   * Gateways under the same scope), it is not possible to associate two routes
   * both with `*.bar.com` or both with `bar.com`.
   */
  hostnames: string[];
  /**
   * Optional. Meshes defines a list of meshes this HttpRoute is attached to, as
   * one of the routing rules to route the requests served by the mesh.
   *
   * Each mesh reference should match the pattern:
   * `projects/* /locations/global/meshes/<mesh_name>`
   *
   * The attached Mesh should be of a type SIDECAR
   */
  meshes: string[];
  /**
   * Optional. Gateways defines a list of gateways this HttpRoute is attached
   * to, as one of the routing rules to route the requests served by the
   * gateway.
   *
   * Each gateway reference should match the pattern:
   * `projects/* /locations/global/gateways/<gateway_name>`
   */
  gateways: string[];
  /** Optional. Set of label tags associated with the HttpRoute resource. */
  labels: { [key: string]: string };
  /**
   * Required. Rules that define how traffic is routed and handled.
   * Rules will be matched sequentially based on the RouteMatch specified for
   * the rule.
   */
  rules: HttpRoute_RouteRule[];
}

/** Specifies how to select a route rule based on HTTP request headers. */
export interface HttpRoute_HeaderMatch {
  /**
   * The value of the header should match exactly the content of
   * exact_match.
   */
  exactMatch?:
    | string
    | undefined;
  /**
   * The value of the header must match the regular expression specified in
   * regex_match. For regular expression grammar, please see:
   * https://github.com/google/re2/wiki/Syntax
   */
  regexMatch?:
    | string
    | undefined;
  /** The value of the header must start with the contents of prefix_match. */
  prefixMatch?:
    | string
    | undefined;
  /**
   * A header with header_name must exist. The match takes place whether or
   * not the header has a value.
   */
  presentMatch?:
    | boolean
    | undefined;
  /** The value of the header must end with the contents of suffix_match. */
  suffixMatch?:
    | string
    | undefined;
  /**
   * If specified, the rule will match if the request header value is within
   * the range.
   */
  rangeMatch?:
    | HttpRoute_HeaderMatch_IntegerRange
    | undefined;
  /** The name of the HTTP header to match against. */
  header: string;
  /**
   * If specified, the match result will be inverted before checking. Default
   * value is set to false.
   */
  invertMatch: boolean;
}

/** Represents an integer value range. */
export interface HttpRoute_HeaderMatch_IntegerRange {
  /** Start of the range (inclusive) */
  start: number;
  /** End of the range (exclusive) */
  end: number;
}

/** Specifications to match a query parameter in the request. */
export interface HttpRoute_QueryParameterMatch {
  /**
   * The value of the query parameter must exactly match the contents of
   * exact_match.
   *
   * Only one of exact_match, regex_match, or present_match must be set.
   */
  exactMatch?:
    | string
    | undefined;
  /**
   * The value of the query parameter must match the regular expression
   * specified by regex_match. For regular expression grammar, please see
   * https://github.com/google/re2/wiki/Syntax
   *
   * Only one of exact_match, regex_match, or present_match must be set.
   */
  regexMatch?:
    | string
    | undefined;
  /**
   * Specifies that the QueryParameterMatcher matches if request contains
   * query parameter, irrespective of whether the parameter has a value or
   * not.
   *
   * Only one of exact_match, regex_match, or present_match must be set.
   */
  presentMatch?:
    | boolean
    | undefined;
  /** The name of the query parameter to match. */
  queryParameter: string;
}

/**
 * RouteMatch defines specifications used to match requests. If multiple match
 * types are set, this RouteMatch will match if ALL type of matches are
 * matched.
 */
export interface HttpRoute_RouteMatch {
  /**
   * The HTTP request path value should exactly match this value.
   *
   * Only one of full_path_match, prefix_match, or regex_match should be
   * used.
   */
  fullPathMatch?:
    | string
    | undefined;
  /**
   * The HTTP request path value must begin with specified prefix_match.
   * prefix_match must begin with a /.
   *
   * Only one of full_path_match, prefix_match, or regex_match should be
   * used.
   */
  prefixMatch?:
    | string
    | undefined;
  /**
   * The HTTP request path value must satisfy the regular expression
   * specified by regex_match after removing any query parameters and anchor
   * supplied with the original URL. For regular expression grammar, please
   * see https://github.com/google/re2/wiki/Syntax
   *
   * Only one of full_path_match, prefix_match, or regex_match should be
   * used.
   */
  regexMatch?:
    | string
    | undefined;
  /**
   * Specifies if prefix_match and full_path_match matches are case sensitive.
   * The default value is false.
   */
  ignoreCase: boolean;
  /**
   * Specifies a list of HTTP request headers to match against. ALL of the
   * supplied headers must be matched.
   */
  headers: HttpRoute_HeaderMatch[];
  /**
   * Specifies a list of query parameters to match against. ALL of the query
   * parameters must be matched.
   */
  queryParameters: HttpRoute_QueryParameterMatch[];
}

/** Specifications of a destination to which the request should be routed to. */
export interface HttpRoute_Destination {
  /** The URL of a BackendService to route traffic to. */
  serviceName: string;
  /**
   * Specifies the proportion of requests forwarded to the backend referenced
   * by the serviceName field. This is computed as:
   *         weight/Sum(weights in this destination list).
   * For non-zero values, there may be some epsilon from the exact proportion
   * defined here depending on the precision an implementation supports.
   *
   * If only one serviceName is specified and it has a weight greater than 0,
   * 100% of the traffic is forwarded to that backend.
   *
   * If weights are specified for any one service name, they need to be
   * specified for all of them.
   *
   * If weights are unspecified for all services, then, traffic is distributed
   * in equal proportions to all of them.
   */
  weight: number;
}

/** The specification for redirecting traffic. */
export interface HttpRoute_Redirect {
  /**
   * The host that will be used in the redirect response instead of the one
   * that was supplied in the request.
   */
  hostRedirect: string;
  /**
   * The path that will be used in the redirect response instead of the one
   * that was supplied in the request.
   * path_redirect can not be supplied together with prefix_redirect. Supply
   * one alone or neither. If neither is supplied, the path of the original
   * request will be used for the redirect.
   */
  pathRedirect: string;
  /**
   * Indicates that during redirection, the matched prefix (or path) should be
   * swapped with this value. This option allows URLs be dynamically created
   * based on the request.
   */
  prefixRewrite: string;
  /** The HTTP Status code to use for the redirect. */
  responseCode: HttpRoute_Redirect_ResponseCode;
  /**
   * If set to true, the URL scheme in the redirected request is set to https.
   * If set to false, the URL scheme of the redirected request will remain the
   * same as that of the request.
   *
   * The default is set to false.
   */
  httpsRedirect: boolean;
  /**
   * if set to true, any accompanying query portion of the original URL is
   * removed prior to redirecting the request. If set to false, the query
   * portion of the original URL is retained.
   *
   * The default is set to false.
   */
  stripQuery: boolean;
  /**
   * The port that will be used in the redirected request instead of the one
   * that was supplied in the request.
   */
  portRedirect: number;
}

/** Supported HTTP response code. */
export enum HttpRoute_Redirect_ResponseCode {
  /** RESPONSE_CODE_UNSPECIFIED - Default value */
  RESPONSE_CODE_UNSPECIFIED = 0,
  /** MOVED_PERMANENTLY_DEFAULT - Corresponds to 301. */
  MOVED_PERMANENTLY_DEFAULT = 1,
  /** FOUND - Corresponds to 302. */
  FOUND = 2,
  /** SEE_OTHER - Corresponds to 303. */
  SEE_OTHER = 3,
  /** TEMPORARY_REDIRECT - Corresponds to 307. In this case, the request method will be retained. */
  TEMPORARY_REDIRECT = 4,
  /** PERMANENT_REDIRECT - Corresponds to 308. In this case, the request method will be retained. */
  PERMANENT_REDIRECT = 5,
  UNRECOGNIZED = -1,
}

export function httpRoute_Redirect_ResponseCodeFromJSON(object: any): HttpRoute_Redirect_ResponseCode {
  switch (object) {
    case 0:
    case "RESPONSE_CODE_UNSPECIFIED":
      return HttpRoute_Redirect_ResponseCode.RESPONSE_CODE_UNSPECIFIED;
    case 1:
    case "MOVED_PERMANENTLY_DEFAULT":
      return HttpRoute_Redirect_ResponseCode.MOVED_PERMANENTLY_DEFAULT;
    case 2:
    case "FOUND":
      return HttpRoute_Redirect_ResponseCode.FOUND;
    case 3:
    case "SEE_OTHER":
      return HttpRoute_Redirect_ResponseCode.SEE_OTHER;
    case 4:
    case "TEMPORARY_REDIRECT":
      return HttpRoute_Redirect_ResponseCode.TEMPORARY_REDIRECT;
    case 5:
    case "PERMANENT_REDIRECT":
      return HttpRoute_Redirect_ResponseCode.PERMANENT_REDIRECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpRoute_Redirect_ResponseCode.UNRECOGNIZED;
  }
}

export function httpRoute_Redirect_ResponseCodeToJSON(object: HttpRoute_Redirect_ResponseCode): string {
  switch (object) {
    case HttpRoute_Redirect_ResponseCode.RESPONSE_CODE_UNSPECIFIED:
      return "RESPONSE_CODE_UNSPECIFIED";
    case HttpRoute_Redirect_ResponseCode.MOVED_PERMANENTLY_DEFAULT:
      return "MOVED_PERMANENTLY_DEFAULT";
    case HttpRoute_Redirect_ResponseCode.FOUND:
      return "FOUND";
    case HttpRoute_Redirect_ResponseCode.SEE_OTHER:
      return "SEE_OTHER";
    case HttpRoute_Redirect_ResponseCode.TEMPORARY_REDIRECT:
      return "TEMPORARY_REDIRECT";
    case HttpRoute_Redirect_ResponseCode.PERMANENT_REDIRECT:
      return "PERMANENT_REDIRECT";
    case HttpRoute_Redirect_ResponseCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The specification for fault injection introduced into traffic to test the
 * resiliency of clients to destination service failure. As part of fault
 * injection, when clients send requests to a destination, delays can be
 * introduced by client proxy on a percentage of requests before sending those
 * requests to the destination service. Similarly requests can be aborted by
 * client proxy for a percentage of requests.
 */
export interface HttpRoute_FaultInjectionPolicy {
  /** The specification for injecting delay to client requests. */
  delay?:
    | HttpRoute_FaultInjectionPolicy_Delay
    | undefined;
  /** The specification for aborting to client requests. */
  abort?: HttpRoute_FaultInjectionPolicy_Abort | undefined;
}

/**
 * Specification of how client requests are delayed as part of fault
 * injection before being sent to a destination.
 */
export interface HttpRoute_FaultInjectionPolicy_Delay {
  /** Specify a fixed delay before forwarding the request. */
  fixedDelay?:
    | Duration
    | undefined;
  /**
   * The percentage of traffic on which delay will be injected.
   *
   * The value must be between [0, 100]
   */
  percentage: number;
}

/**
 * Specification of how client requests are aborted as part of fault
 * injection before being sent to a destination.
 */
export interface HttpRoute_FaultInjectionPolicy_Abort {
  /**
   * The HTTP status code used to abort the request.
   *
   * The value must be between 200 and 599 inclusive.
   */
  httpStatus: number;
  /**
   * The percentage of traffic which will be aborted.
   *
   * The value must be between [0, 100]
   */
  percentage: number;
}

/**
 * The specification for modifying HTTP header in HTTP request and HTTP
 * response.
 */
export interface HttpRoute_HeaderModifier {
  /**
   * Completely overwrite/replace the headers with given map where key is the
   * name of the header, value is the value of the header.
   */
  set: { [key: string]: string };
  /**
   * Add the headers with given map where key is the name of the header, value
   * is the value of the header.
   */
  add: { [key: string]: string };
  /** Remove headers (matching by header names) specified in the list. */
  remove: string[];
}

export interface HttpRoute_HeaderModifier_SetEntry {
  key: string;
  value: string;
}

export interface HttpRoute_HeaderModifier_AddEntry {
  key: string;
  value: string;
}

/**
 * The specification for modifying the URL of the request, prior to forwarding
 * the request to the destination.
 */
export interface HttpRoute_URLRewrite {
  /**
   * Prior to forwarding the request to the selected destination, the matching
   * portion of the requests path is replaced by this value.
   */
  pathPrefixRewrite: string;
  /**
   * Prior to forwarding the request to the selected destination, the requests
   * host header is replaced by this value.
   */
  hostRewrite: string;
}

/** The specifications for retries. */
export interface HttpRoute_RetryPolicy {
  /**
   * Specifies one or more conditions when this retry policy applies. Valid
   * values are:
   *   5xx: Proxy will attempt a retry if the destination service responds
   *     with any 5xx response code, of if the destination service does not
   *     respond at all, example: disconnect, reset, read timeout, connection
   *     failure and refused streams.
   *
   *   gateway-error: Similar to 5xx, but only applies to response codes 502,
   *     503, 504.
   *
   *   reset: Proxy will attempt a retry if the destination service does not
   *     respond at all (disconnect/reset/read timeout)
   *
   *   connect-failure: Proxy will retry on failures connecting to destination
   *     for example due to connection timeouts.
   *
   *   retriable-4xx: Proxy will retry fro retriable 4xx response codes.
   *     Currently the only retriable error supported is 409.
   *
   *   refused-stream: Proxy will retry if the destination resets the stream
   *     with a REFUSED_STREAM error code. This reset type indicates that it
   *     is safe to retry.
   */
  retryConditions: string[];
  /**
   * Specifies the allowed number of retries. This number must be > 0. If not
   * specified, default to 1.
   */
  numRetries: number;
  /** Specifies a non-zero timeout per retry attempt. */
  perTryTimeout?: Duration | undefined;
}

/**
 * Specifies the policy on how requests are shadowed to a separate mirrored
 * destination service. The proxy does not wait for responses from the
 * shadow service. Prior to sending traffic to the shadow service, the
 * host/authority header is suffixed with -shadow.
 */
export interface HttpRoute_RequestMirrorPolicy {
  /**
   * The destination the requests will be mirrored to. The weight of the
   * destination will be ignored.
   */
  destination?: HttpRoute_Destination | undefined;
}

/** The Specification for allowing client side cross-origin requests. */
export interface HttpRoute_CorsPolicy {
  /**
   * Specifies the list of origins that will be allowed to do CORS requests.
   * An origin is allowed if it matches either an item in allow_origins or
   * an item in allow_origin_regexes.
   */
  allowOrigins: string[];
  /**
   * Specifies the regular expression patterns that match allowed origins. For
   * regular expression grammar, please see
   * https://github.com/google/re2/wiki/Syntax.
   */
  allowOriginRegexes: string[];
  /** Specifies the content for Access-Control-Allow-Methods header. */
  allowMethods: string[];
  /** Specifies the content for Access-Control-Allow-Headers header. */
  allowHeaders: string[];
  /** Specifies the content for Access-Control-Expose-Headers header. */
  exposeHeaders: string[];
  /**
   * Specifies how long result of a preflight request can be cached in
   * seconds. This translates to the Access-Control-Max-Age header.
   */
  maxAge: string;
  /**
   * In response to a preflight request, setting this to true indicates that
   * the actual request can include user credentials. This translates to the
   * Access-Control-Allow-Credentials header.
   *
   * Default value is false.
   */
  allowCredentials: boolean;
  /**
   * If true, the CORS policy is disabled. The default value is false, which
   * indicates that the CORS policy is in effect.
   */
  disabled: boolean;
}

/** The specifications for routing traffic and applying associated policies. */
export interface HttpRoute_RouteAction {
  /** The destination to which traffic should be forwarded. */
  destinations: HttpRoute_Destination[];
  /** If set, the request is directed as configured by this field. */
  redirect?:
    | HttpRoute_Redirect
    | undefined;
  /**
   * The specification for fault injection introduced into traffic to test the
   * resiliency of clients to backend service failure. As part of fault
   * injection, when clients send requests to a backend service, delays can be
   * introduced  on a percentage of requests before sending those requests to
   * the backend service. Similarly requests from clients can be aborted for a
   * percentage of requests.
   *
   * timeout and retry_policy will be ignored by clients that are configured
   * with a fault_injection_policy
   */
  faultInjectionPolicy?:
    | HttpRoute_FaultInjectionPolicy
    | undefined;
  /**
   * The specification for modifying the headers of a matching request prior
   * to delivery of the request to the destination.
   */
  requestHeaderModifier?:
    | HttpRoute_HeaderModifier
    | undefined;
  /**
   * The specification for modifying the headers of a response prior to
   * sending the response back to the client.
   */
  responseHeaderModifier?:
    | HttpRoute_HeaderModifier
    | undefined;
  /**
   * The specification for rewrite URL before forwarding requests to the
   * destination.
   */
  urlRewrite?:
    | HttpRoute_URLRewrite
    | undefined;
  /**
   * Specifies the timeout for selected route. Timeout is computed from the
   * time the request has been fully processed (i.e. end of stream) up until
   * the response has been completely processed. Timeout includes all retries.
   */
  timeout?:
    | Duration
    | undefined;
  /** Specifies the retry policy associated with this route. */
  retryPolicy?:
    | HttpRoute_RetryPolicy
    | undefined;
  /**
   * Specifies the policy on how requests intended for the routes destination
   * are shadowed to a separate mirrored destination. Proxy will not wait for
   * the shadow destination to respond before returning the response. Prior to
   * sending traffic to the shadow service, the host/authority header is
   * suffixed with -shadow.
   */
  requestMirrorPolicy?:
    | HttpRoute_RequestMirrorPolicy
    | undefined;
  /** The specification for allowing client side cross-origin requests. */
  corsPolicy?: HttpRoute_CorsPolicy | undefined;
}

/**
 * Specifies how to match traffic and how to route traffic when traffic is
 * matched.
 */
export interface HttpRoute_RouteRule {
  /**
   * A list of matches define conditions used for matching the rule against
   * incoming HTTP requests. Each match is independent, i.e. this rule will be
   * matched if ANY one of the matches is satisfied.
   *
   * If no matches field is specified, this rule will unconditionally match
   * traffic.
   *
   * If a default rule is desired to be configured, add a rule with no matches
   * specified to the end of the rules list.
   */
  matches: HttpRoute_RouteMatch[];
  /** The detailed rule defining how to route matched traffic. */
  action?: HttpRoute_RouteAction | undefined;
}

export interface HttpRoute_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Mesh represents a logical configuration grouping for workload to workload
 * communication within a service mesh. Routes that point to mesh dictate how
 * requests are routed within this logical mesh boundary.
 */
export interface Mesh {
  /**
   * Required. Name of the Mesh resource. It matches pattern
   * `projects/* /locations/global/meshes/<mesh_name>`.
   */
  name: string;
  /** Output only. Server-defined URL of this resource */
  selfLink: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime?:
    | Date
    | undefined;
  /** Optional. Set of label tags associated with the Mesh resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Optional. If set to a valid TCP port (1-65535), instructs the SIDECAR proxy
   * to listen on the specified port of localhost (127.0.0.1) address. The
   * SIDECAR proxy will expect all traffic to be redirected to this port
   * regardless of its actual ip:port destination. If unset, a port '15001' is
   * used as the interception port. This is applicable only for sidecar proxy
   * deployments.
   */
  interceptionPort: number;
}

export interface Mesh_LabelsEntry {
  key: string;
  value: string;
}

/**
 * ServiceBinding is the resource that defines a Service Directory Service to
 * be used in a BackendService resource.
 */
export interface ServiceBinding {
  /**
   * Required. Name of the ServiceBinding resource. It matches pattern
   * `projects/* /locations/global/serviceBindings/service_binding_name`.
   */
  name: string;
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Required. The full Service Directory Service name of the format
   * projects/* /locations/* /namespaces/* /services/*
   */
  service: string;
  /**
   * Output only. The unique identifier of the Service Directory Service against
   * which the Service Binding resource is validated. This is populated when the
   * Service Binding resource is used in another resource (like Backend
   * Service). This is of the UUID4 format.
   */
  serviceId: string;
  /** Optional. Set of label tags associated with the ServiceBinding resource. */
  labels: { [key: string]: string };
}

export interface ServiceBinding_LabelsEntry {
  key: string;
  value: string;
}

/**
 * TcpRoute is the resource defining how TCP traffic should be routed by a
 * Mesh/Gateway resource.
 */
export interface TcpRoute {
  /**
   * Required. Name of the TcpRoute resource. It matches pattern
   * `projects/* /locations/global/tcpRoutes/tcp_route_name>`.
   */
  name: string;
  /** Output only. Server-defined URL of this resource */
  selfLink: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Required. Rules that define how traffic is routed and handled. At least one
   * RouteRule must be supplied. If there are multiple rules then the action
   * taken will be the first rule to match.
   */
  rules: TcpRoute_RouteRule[];
  /**
   * Optional. Meshes defines a list of meshes this TcpRoute is attached to, as
   * one of the routing rules to route the requests served by the mesh.
   *
   * Each mesh reference should match the pattern:
   * `projects/* /locations/global/meshes/<mesh_name>`
   *
   * The attached Mesh should be of a type SIDECAR
   */
  meshes: string[];
  /**
   * Optional. Gateways defines a list of gateways this TcpRoute is attached to,
   * as one of the routing rules to route the requests served by the gateway.
   *
   * Each gateway reference should match the pattern:
   * `projects/* /locations/global/gateways/<gateway_name>`
   */
  gateways: string[];
  /** Optional. Set of label tags associated with the TcpRoute resource. */
  labels: { [key: string]: string };
}

/**
 * Specifies how to match traffic and how to route traffic when traffic is
 * matched.
 */
export interface TcpRoute_RouteRule {
  /**
   * Optional. RouteMatch defines the predicate used to match requests to a
   * given action. Multiple match types are "OR"ed for evaluation. If no
   * routeMatch field is specified, this rule will unconditionally match
   * traffic.
   */
  matches: TcpRoute_RouteMatch[];
  /** Required. The detailed rule defining how to route matched traffic. */
  action?: TcpRoute_RouteAction | undefined;
}

/**
 * RouteMatch defines the predicate used to match requests to a given action.
 * Multiple match types are "OR"ed for evaluation.
 * If no routeMatch field is specified, this rule will unconditionally match
 * traffic.
 */
export interface TcpRoute_RouteMatch {
  /**
   * Required. Must be specified in the CIDR range format. A CIDR range
   * consists of an IP Address and a prefix length to construct the subnet
   * mask. By default, the prefix length is 32 (i.e. matches a single IP
   * address). Only IPV4 addresses are supported. Examples: "10.0.0.1" -
   * matches against this exact IP address. "10.0.0.0/8" - matches against any
   * IP address within the 10.0.0.0 subnet and 255.255.255.0 mask. "0.0.0.0/0"
   * - matches against any IP address'.
   */
  address: string;
  /** Required. Specifies the destination port to match against. */
  port: string;
}

/** The specifications for routing traffic and applying associated policies. */
export interface TcpRoute_RouteAction {
  /**
   * Optional. The destination services to which traffic should be forwarded.
   * At least one destination service is required. Only one of route
   * destination or original destination can be set.
   */
  destinations: TcpRoute_RouteDestination[];
  /**
   * Optional. If true, Router will use the destination IP and port of the
   * original connection as the destination of the request. Default is false.
   * Only one of route destinations or original destination can be set.
   */
  originalDestination: boolean;
}

/** Describe the destination for traffic to be routed to. */
export interface TcpRoute_RouteDestination {
  /** Required. The URL of a BackendService to route traffic to. */
  serviceName: string;
  /**
   * Optional. Specifies the proportion of requests forwarded to the backend
   * referenced by the serviceName field. This is computed as:
   *         weight/Sum(weights in this destination list).
   * For non-zero values, there may be some epsilon from the exact proportion
   * defined here depending on the precision an implementation supports.
   *
   * If only one serviceName is specified and it has a weight greater than 0,
   * 100% of the traffic is forwarded to that backend.
   *
   * If weights are specified for any one service name, they need to be
   * specified for all of them.
   *
   * If weights are unspecified for all services, then, traffic is distributed
   * in equal proportions to all of them.
   */
  weight: number;
}

export interface TcpRoute_LabelsEntry {
  key: string;
  value: string;
}

/**
 * TlsRoute defines how traffic should be routed based on SNI and other matching
 * L3 attributes.
 */
export interface TlsRoute {
  /**
   * Required. Name of the TlsRoute resource. It matches pattern
   * `projects/* /locations/global/tlsRoutes/tls_route_name>`.
   */
  name: string;
  /** Output only. Server-defined URL of this resource */
  selfLink: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Required. Rules that define how traffic is routed and handled. At least one
   * RouteRule must be supplied. If there are multiple rules then the action
   * taken will be the first rule to match.
   */
  rules: TlsRoute_RouteRule[];
  /**
   * Optional. Meshes defines a list of meshes this TlsRoute is attached to, as
   * one of the routing rules to route the requests served by the mesh.
   *
   * Each mesh reference should match the pattern:
   * `projects/* /locations/global/meshes/<mesh_name>`
   *
   * The attached Mesh should be of a type SIDECAR
   */
  meshes: string[];
  /**
   * Optional. Gateways defines a list of gateways this TlsRoute is attached to,
   * as one of the routing rules to route the requests served by the gateway.
   *
   * Each gateway reference should match the pattern:
   * `projects/* /locations/global/gateways/<gateway_name>`
   */
  gateways: string[];
}

/**
 * Specifies how to match traffic and how to route traffic when traffic is
 * matched.
 */
export interface TlsRoute_RouteRule {
  /**
   * Required. RouteMatch defines the predicate used to match requests to a
   * given action. Multiple match types are "OR"ed for evaluation.
   */
  matches: TlsRoute_RouteMatch[];
  /** Required. The detailed rule defining how to route matched traffic. */
  action?: TlsRoute_RouteAction | undefined;
}

/**
 * RouteMatch defines the predicate used to match requests to a given action.
 * Multiple match types are "AND"ed for evaluation.
 * If no routeMatch field is specified, this rule will unconditionally match
 * traffic.
 */
export interface TlsRoute_RouteMatch {
  /**
   * Optional. SNI (server name indicator) to match against.
   * SNI will be matched against all wildcard domains, i.e. `www.example.com`
   * will be first matched against `www.example.com`, then `*.example.com`,
   * then `*.com.`
   * Partial wildcards are not supported, and values like *w.example.com are
   * invalid.
   * At least one of sni_host and alpn is required.
   * Up to 5 sni hosts across all matches can be set.
   */
  sniHost: string[];
  /**
   * Optional. ALPN (Application-Layer Protocol Negotiation) to match against.
   * Examples: "http/1.1", "h2".
   * At least one of sni_host and alpn is required.
   * Up to 5 alpns across all matches can be set.
   */
  alpn: string[];
}

/** The specifications for routing traffic and applying associated policies. */
export interface TlsRoute_RouteAction {
  /**
   * Required. The destination services to which traffic should be forwarded.
   * At least one destination service is required.
   */
  destinations: TlsRoute_RouteDestination[];
}

/** Describe the destination for traffic to be routed to. */
export interface TlsRoute_RouteDestination {
  /** Required. The URL of a BackendService to route traffic to. */
  serviceName: string;
  /**
   * Optional. Specifies the proportion of requests forwareded to the backend
   * referenced by the service_name field. This is computed as:
   *         weight/Sum(weights in destinations)
   * Weights in all destinations does not need to sum up to 100.
   */
  weight: number;
}

/** The data within all EndpointPolicy events. */
export interface EndpointPolicyEventData {
  /** Optional. The EndpointPolicy event payload. Unset for deletion events. */
  payload?: EndpointPolicy | undefined;
}

/** The data within all HttpRoute events. */
export interface HttpRouteEventData {
  /** Optional. The HttpRoute event payload. Unset for deletion events. */
  payload?: HttpRoute | undefined;
}

/** The data within all ServiceBinding events. */
export interface ServiceBindingEventData {
  /** Optional. The ServiceBinding event payload. Unset for deletion events. */
  payload?: ServiceBinding | undefined;
}

/** The data within all Gateway events. */
export interface GatewayEventData {
  /** Optional. The Gateway event payload. Unset for deletion events. */
  payload?: Gateway | undefined;
}

/** The data within all TlsRoute events. */
export interface TlsRouteEventData {
  /** Optional. The TlsRoute event payload. Unset for deletion events. */
  payload?: TlsRoute | undefined;
}

/** The data within all GrpcRoute events. */
export interface GrpcRouteEventData {
  /** Optional. The GrpcRoute event payload. Unset for deletion events. */
  payload?: GrpcRoute | undefined;
}

/** The data within all Mesh events. */
export interface MeshEventData {
  /** Optional. The Mesh event payload. Unset for deletion events. */
  payload?: Mesh | undefined;
}

/** The data within all TcpRoute events. */
export interface TcpRouteEventData {
  /** Optional. The TcpRoute event payload. Unset for deletion events. */
  payload?: TcpRoute | undefined;
}

function createBaseTrafficPortSelector(): TrafficPortSelector {
  return { ports: [] };
}

export const TrafficPortSelector: MessageFns<TrafficPortSelector> = {
  encode(message: TrafficPortSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ports) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrafficPortSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrafficPortSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ports.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrafficPortSelector {
    return { ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: TrafficPortSelector): unknown {
    const obj: any = {};
    if (message.ports?.length) {
      obj.ports = message.ports;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrafficPortSelector>, I>>(base?: I): TrafficPortSelector {
    return TrafficPortSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrafficPortSelector>, I>>(object: I): TrafficPortSelector {
    const message = createBaseTrafficPortSelector();
    message.ports = object.ports?.map((e) => e) || [];
    return message;
  },
};

function createBaseEndpointMatcher(): EndpointMatcher {
  return { metadataLabelMatcher: undefined };
}

export const EndpointMatcher: MessageFns<EndpointMatcher> = {
  encode(message: EndpointMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadataLabelMatcher !== undefined) {
      EndpointMatcher_MetadataLabelMatcher.encode(message.metadataLabelMatcher, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadataLabelMatcher = EndpointMatcher_MetadataLabelMatcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointMatcher {
    return {
      metadataLabelMatcher: isSet(object.metadataLabelMatcher)
        ? EndpointMatcher_MetadataLabelMatcher.fromJSON(object.metadataLabelMatcher)
        : undefined,
    };
  },

  toJSON(message: EndpointMatcher): unknown {
    const obj: any = {};
    if (message.metadataLabelMatcher !== undefined) {
      obj.metadataLabelMatcher = EndpointMatcher_MetadataLabelMatcher.toJSON(message.metadataLabelMatcher);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointMatcher>, I>>(base?: I): EndpointMatcher {
    return EndpointMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointMatcher>, I>>(object: I): EndpointMatcher {
    const message = createBaseEndpointMatcher();
    message.metadataLabelMatcher = (object.metadataLabelMatcher !== undefined && object.metadataLabelMatcher !== null)
      ? EndpointMatcher_MetadataLabelMatcher.fromPartial(object.metadataLabelMatcher)
      : undefined;
    return message;
  },
};

function createBaseEndpointMatcher_MetadataLabelMatcher(): EndpointMatcher_MetadataLabelMatcher {
  return { metadataLabelMatchCriteria: 0, metadataLabels: [] };
}

export const EndpointMatcher_MetadataLabelMatcher: MessageFns<EndpointMatcher_MetadataLabelMatcher> = {
  encode(message: EndpointMatcher_MetadataLabelMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadataLabelMatchCriteria !== 0) {
      writer.uint32(8).int32(message.metadataLabelMatchCriteria);
    }
    for (const v of message.metadataLabels) {
      EndpointMatcher_MetadataLabelMatcher_MetadataLabels.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointMatcher_MetadataLabelMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointMatcher_MetadataLabelMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.metadataLabelMatchCriteria = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadataLabels.push(
            EndpointMatcher_MetadataLabelMatcher_MetadataLabels.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointMatcher_MetadataLabelMatcher {
    return {
      metadataLabelMatchCriteria: isSet(object.metadataLabelMatchCriteria)
        ? endpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteriaFromJSON(object.metadataLabelMatchCriteria)
        : 0,
      metadataLabels: globalThis.Array.isArray(object?.metadataLabels)
        ? object.metadataLabels.map((e: any) => EndpointMatcher_MetadataLabelMatcher_MetadataLabels.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EndpointMatcher_MetadataLabelMatcher): unknown {
    const obj: any = {};
    if (message.metadataLabelMatchCriteria !== 0) {
      obj.metadataLabelMatchCriteria = endpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteriaToJSON(
        message.metadataLabelMatchCriteria,
      );
    }
    if (message.metadataLabels?.length) {
      obj.metadataLabels = message.metadataLabels.map((e) =>
        EndpointMatcher_MetadataLabelMatcher_MetadataLabels.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointMatcher_MetadataLabelMatcher>, I>>(
    base?: I,
  ): EndpointMatcher_MetadataLabelMatcher {
    return EndpointMatcher_MetadataLabelMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointMatcher_MetadataLabelMatcher>, I>>(
    object: I,
  ): EndpointMatcher_MetadataLabelMatcher {
    const message = createBaseEndpointMatcher_MetadataLabelMatcher();
    message.metadataLabelMatchCriteria = object.metadataLabelMatchCriteria ?? 0;
    message.metadataLabels =
      object.metadataLabels?.map((e) => EndpointMatcher_MetadataLabelMatcher_MetadataLabels.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEndpointMatcher_MetadataLabelMatcher_MetadataLabels(): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
  return { labelName: "", labelValue: "" };
}

export const EndpointMatcher_MetadataLabelMatcher_MetadataLabels: MessageFns<
  EndpointMatcher_MetadataLabelMatcher_MetadataLabels
> = {
  encode(
    message: EndpointMatcher_MetadataLabelMatcher_MetadataLabels,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.labelName !== "") {
      writer.uint32(10).string(message.labelName);
    }
    if (message.labelValue !== "") {
      writer.uint32(18).string(message.labelValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointMatcher_MetadataLabelMatcher_MetadataLabels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.labelName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
    return {
      labelName: isSet(object.labelName) ? globalThis.String(object.labelName) : "",
      labelValue: isSet(object.labelValue) ? globalThis.String(object.labelValue) : "",
    };
  },

  toJSON(message: EndpointMatcher_MetadataLabelMatcher_MetadataLabels): unknown {
    const obj: any = {};
    if (message.labelName !== "") {
      obj.labelName = message.labelName;
    }
    if (message.labelValue !== "") {
      obj.labelValue = message.labelValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointMatcher_MetadataLabelMatcher_MetadataLabels>, I>>(
    base?: I,
  ): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
    return EndpointMatcher_MetadataLabelMatcher_MetadataLabels.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointMatcher_MetadataLabelMatcher_MetadataLabels>, I>>(
    object: I,
  ): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
    const message = createBaseEndpointMatcher_MetadataLabelMatcher_MetadataLabels();
    message.labelName = object.labelName ?? "";
    message.labelValue = object.labelValue ?? "";
    return message;
  },
};

function createBaseEndpointPolicy(): EndpointPolicy {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    type: 0,
    authorizationPolicy: "",
    endpointMatcher: undefined,
    trafficPortSelector: undefined,
    description: "",
    serverTlsPolicy: "",
    clientTlsPolicy: "",
  };
}

export const EndpointPolicy: MessageFns<EndpointPolicy> = {
  encode(message: EndpointPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      EndpointPolicy_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.authorizationPolicy !== "") {
      writer.uint32(58).string(message.authorizationPolicy);
    }
    if (message.endpointMatcher !== undefined) {
      EndpointMatcher.encode(message.endpointMatcher, writer.uint32(74).fork()).join();
    }
    if (message.trafficPortSelector !== undefined) {
      TrafficPortSelector.encode(message.trafficPortSelector, writer.uint32(82).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.serverTlsPolicy !== "") {
      writer.uint32(98).string(message.serverTlsPolicy);
    }
    if (message.clientTlsPolicy !== "") {
      writer.uint32(106).string(message.clientTlsPolicy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = EndpointPolicy_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authorizationPolicy = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.endpointMatcher = EndpointMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.trafficPortSelector = TrafficPortSelector.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.serverTlsPolicy = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.clientTlsPolicy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointPolicy {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      type: isSet(object.type) ? endpointPolicy_EndpointPolicyTypeFromJSON(object.type) : 0,
      authorizationPolicy: isSet(object.authorizationPolicy) ? globalThis.String(object.authorizationPolicy) : "",
      endpointMatcher: isSet(object.endpointMatcher) ? EndpointMatcher.fromJSON(object.endpointMatcher) : undefined,
      trafficPortSelector: isSet(object.trafficPortSelector)
        ? TrafficPortSelector.fromJSON(object.trafficPortSelector)
        : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      serverTlsPolicy: isSet(object.serverTlsPolicy) ? globalThis.String(object.serverTlsPolicy) : "",
      clientTlsPolicy: isSet(object.clientTlsPolicy) ? globalThis.String(object.clientTlsPolicy) : "",
    };
  },

  toJSON(message: EndpointPolicy): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.type !== 0) {
      obj.type = endpointPolicy_EndpointPolicyTypeToJSON(message.type);
    }
    if (message.authorizationPolicy !== "") {
      obj.authorizationPolicy = message.authorizationPolicy;
    }
    if (message.endpointMatcher !== undefined) {
      obj.endpointMatcher = EndpointMatcher.toJSON(message.endpointMatcher);
    }
    if (message.trafficPortSelector !== undefined) {
      obj.trafficPortSelector = TrafficPortSelector.toJSON(message.trafficPortSelector);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.serverTlsPolicy !== "") {
      obj.serverTlsPolicy = message.serverTlsPolicy;
    }
    if (message.clientTlsPolicy !== "") {
      obj.clientTlsPolicy = message.clientTlsPolicy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointPolicy>, I>>(base?: I): EndpointPolicy {
    return EndpointPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointPolicy>, I>>(object: I): EndpointPolicy {
    const message = createBaseEndpointPolicy();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.type = object.type ?? 0;
    message.authorizationPolicy = object.authorizationPolicy ?? "";
    message.endpointMatcher = (object.endpointMatcher !== undefined && object.endpointMatcher !== null)
      ? EndpointMatcher.fromPartial(object.endpointMatcher)
      : undefined;
    message.trafficPortSelector = (object.trafficPortSelector !== undefined && object.trafficPortSelector !== null)
      ? TrafficPortSelector.fromPartial(object.trafficPortSelector)
      : undefined;
    message.description = object.description ?? "";
    message.serverTlsPolicy = object.serverTlsPolicy ?? "";
    message.clientTlsPolicy = object.clientTlsPolicy ?? "";
    return message;
  },
};

function createBaseEndpointPolicy_LabelsEntry(): EndpointPolicy_LabelsEntry {
  return { key: "", value: "" };
}

export const EndpointPolicy_LabelsEntry: MessageFns<EndpointPolicy_LabelsEntry> = {
  encode(message: EndpointPolicy_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointPolicy_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointPolicy_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointPolicy_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EndpointPolicy_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointPolicy_LabelsEntry>, I>>(base?: I): EndpointPolicy_LabelsEntry {
    return EndpointPolicy_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointPolicy_LabelsEntry>, I>>(object: I): EndpointPolicy_LabelsEntry {
    const message = createBaseEndpointPolicy_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGateway(): Gateway {
  return {
    name: "",
    selfLink: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    type: 0,
    addresses: [],
    ports: [],
    scope: "",
    serverTlsPolicy: "",
    certificateUrls: [],
    gatewaySecurityPolicy: "",
    network: "",
    subnetwork: "",
  };
}

export const Gateway: MessageFns<Gateway> = {
  encode(message: Gateway, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selfLink !== "") {
      writer.uint32(106).string(message.selfLink);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Gateway_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    for (const v of message.addresses) {
      writer.uint32(58).string(v!);
    }
    writer.uint32(90).fork();
    for (const v of message.ports) {
      writer.int32(v);
    }
    writer.join();
    if (message.scope !== "") {
      writer.uint32(66).string(message.scope);
    }
    if (message.serverTlsPolicy !== "") {
      writer.uint32(74).string(message.serverTlsPolicy);
    }
    for (const v of message.certificateUrls) {
      writer.uint32(114).string(v!);
    }
    if (message.gatewaySecurityPolicy !== "") {
      writer.uint32(146).string(message.gatewaySecurityPolicy);
    }
    if (message.network !== "") {
      writer.uint32(130).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(138).string(message.subnetwork);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gateway {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateway();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Gateway_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.ports.push(reader.int32());

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ports.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.serverTlsPolicy = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.certificateUrls.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.gatewaySecurityPolicy = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Gateway {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? gateway_TypeFromJSON(object.type) : 0,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
      ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => globalThis.Number(e)) : [],
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      serverTlsPolicy: isSet(object.serverTlsPolicy) ? globalThis.String(object.serverTlsPolicy) : "",
      certificateUrls: globalThis.Array.isArray(object?.certificateUrls)
        ? object.certificateUrls.map((e: any) => globalThis.String(e))
        : [],
      gatewaySecurityPolicy: isSet(object.gatewaySecurityPolicy) ? globalThis.String(object.gatewaySecurityPolicy) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
    };
  },

  toJSON(message: Gateway): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = gateway_TypeToJSON(message.type);
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => Math.round(e));
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.serverTlsPolicy !== "") {
      obj.serverTlsPolicy = message.serverTlsPolicy;
    }
    if (message.certificateUrls?.length) {
      obj.certificateUrls = message.certificateUrls;
    }
    if (message.gatewaySecurityPolicy !== "") {
      obj.gatewaySecurityPolicy = message.gatewaySecurityPolicy;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Gateway>, I>>(base?: I): Gateway {
    return Gateway.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gateway>, I>>(object: I): Gateway {
    const message = createBaseGateway();
    message.name = object.name ?? "";
    message.selfLink = object.selfLink ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.addresses = object.addresses?.map((e) => e) || [];
    message.ports = object.ports?.map((e) => e) || [];
    message.scope = object.scope ?? "";
    message.serverTlsPolicy = object.serverTlsPolicy ?? "";
    message.certificateUrls = object.certificateUrls?.map((e) => e) || [];
    message.gatewaySecurityPolicy = object.gatewaySecurityPolicy ?? "";
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    return message;
  },
};

function createBaseGateway_LabelsEntry(): Gateway_LabelsEntry {
  return { key: "", value: "" };
}

export const Gateway_LabelsEntry: MessageFns<Gateway_LabelsEntry> = {
  encode(message: Gateway_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gateway_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateway_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Gateway_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Gateway_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Gateway_LabelsEntry>, I>>(base?: I): Gateway_LabelsEntry {
    return Gateway_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gateway_LabelsEntry>, I>>(object: I): Gateway_LabelsEntry {
    const message = createBaseGateway_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGrpcRoute(): GrpcRoute {
  return {
    name: "",
    selfLink: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    hostnames: [],
    meshes: [],
    gateways: [],
    rules: [],
  };
}

export const GrpcRoute: MessageFns<GrpcRoute> = {
  encode(message: GrpcRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selfLink !== "") {
      writer.uint32(98).string(message.selfLink);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      GrpcRoute_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.hostnames) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.meshes) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.gateways) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.rules) {
      GrpcRoute_RouteRule.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = GrpcRoute_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.hostnames.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.meshes.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gateways.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rules.push(GrpcRoute_RouteRule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      hostnames: globalThis.Array.isArray(object?.hostnames)
        ? object.hostnames.map((e: any) => globalThis.String(e))
        : [],
      meshes: globalThis.Array.isArray(object?.meshes) ? object.meshes.map((e: any) => globalThis.String(e)) : [],
      gateways: globalThis.Array.isArray(object?.gateways) ? object.gateways.map((e: any) => globalThis.String(e)) : [],
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => GrpcRoute_RouteRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GrpcRoute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.hostnames?.length) {
      obj.hostnames = message.hostnames;
    }
    if (message.meshes?.length) {
      obj.meshes = message.meshes;
    }
    if (message.gateways?.length) {
      obj.gateways = message.gateways;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => GrpcRoute_RouteRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute>, I>>(base?: I): GrpcRoute {
    return GrpcRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute>, I>>(object: I): GrpcRoute {
    const message = createBaseGrpcRoute();
    message.name = object.name ?? "";
    message.selfLink = object.selfLink ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.hostnames = object.hostnames?.map((e) => e) || [];
    message.meshes = object.meshes?.map((e) => e) || [];
    message.gateways = object.gateways?.map((e) => e) || [];
    message.rules = object.rules?.map((e) => GrpcRoute_RouteRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGrpcRoute_MethodMatch(): GrpcRoute_MethodMatch {
  return { type: 0, grpcService: "", grpcMethod: "", caseSensitive: undefined };
}

export const GrpcRoute_MethodMatch: MessageFns<GrpcRoute_MethodMatch> = {
  encode(message: GrpcRoute_MethodMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.grpcService !== "") {
      writer.uint32(18).string(message.grpcService);
    }
    if (message.grpcMethod !== "") {
      writer.uint32(26).string(message.grpcMethod);
    }
    if (message.caseSensitive !== undefined) {
      writer.uint32(32).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_MethodMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_MethodMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grpcService = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.grpcMethod = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_MethodMatch {
    return {
      type: isSet(object.type) ? grpcRoute_MethodMatch_TypeFromJSON(object.type) : 0,
      grpcService: isSet(object.grpcService) ? globalThis.String(object.grpcService) : "",
      grpcMethod: isSet(object.grpcMethod) ? globalThis.String(object.grpcMethod) : "",
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : undefined,
    };
  },

  toJSON(message: GrpcRoute_MethodMatch): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = grpcRoute_MethodMatch_TypeToJSON(message.type);
    }
    if (message.grpcService !== "") {
      obj.grpcService = message.grpcService;
    }
    if (message.grpcMethod !== "") {
      obj.grpcMethod = message.grpcMethod;
    }
    if (message.caseSensitive !== undefined) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_MethodMatch>, I>>(base?: I): GrpcRoute_MethodMatch {
    return GrpcRoute_MethodMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_MethodMatch>, I>>(object: I): GrpcRoute_MethodMatch {
    const message = createBaseGrpcRoute_MethodMatch();
    message.type = object.type ?? 0;
    message.grpcService = object.grpcService ?? "";
    message.grpcMethod = object.grpcMethod ?? "";
    message.caseSensitive = object.caseSensitive ?? undefined;
    return message;
  },
};

function createBaseGrpcRoute_HeaderMatch(): GrpcRoute_HeaderMatch {
  return { type: 0, key: "", value: "" };
}

export const GrpcRoute_HeaderMatch: MessageFns<GrpcRoute_HeaderMatch> = {
  encode(message: GrpcRoute_HeaderMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_HeaderMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_HeaderMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_HeaderMatch {
    return {
      type: isSet(object.type) ? grpcRoute_HeaderMatch_TypeFromJSON(object.type) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GrpcRoute_HeaderMatch): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = grpcRoute_HeaderMatch_TypeToJSON(message.type);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_HeaderMatch>, I>>(base?: I): GrpcRoute_HeaderMatch {
    return GrpcRoute_HeaderMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_HeaderMatch>, I>>(object: I): GrpcRoute_HeaderMatch {
    const message = createBaseGrpcRoute_HeaderMatch();
    message.type = object.type ?? 0;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGrpcRoute_RouteMatch(): GrpcRoute_RouteMatch {
  return { method: undefined, headers: [] };
}

export const GrpcRoute_RouteMatch: MessageFns<GrpcRoute_RouteMatch> = {
  encode(message: GrpcRoute_RouteMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== undefined) {
      GrpcRoute_MethodMatch.encode(message.method, writer.uint32(10).fork()).join();
    }
    for (const v of message.headers) {
      GrpcRoute_HeaderMatch.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_RouteMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_RouteMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = GrpcRoute_MethodMatch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headers.push(GrpcRoute_HeaderMatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_RouteMatch {
    return {
      method: isSet(object.method) ? GrpcRoute_MethodMatch.fromJSON(object.method) : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => GrpcRoute_HeaderMatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GrpcRoute_RouteMatch): unknown {
    const obj: any = {};
    if (message.method !== undefined) {
      obj.method = GrpcRoute_MethodMatch.toJSON(message.method);
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => GrpcRoute_HeaderMatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_RouteMatch>, I>>(base?: I): GrpcRoute_RouteMatch {
    return GrpcRoute_RouteMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_RouteMatch>, I>>(object: I): GrpcRoute_RouteMatch {
    const message = createBaseGrpcRoute_RouteMatch();
    message.method = (object.method !== undefined && object.method !== null)
      ? GrpcRoute_MethodMatch.fromPartial(object.method)
      : undefined;
    message.headers = object.headers?.map((e) => GrpcRoute_HeaderMatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGrpcRoute_Destination(): GrpcRoute_Destination {
  return { serviceName: undefined, weight: undefined };
}

export const GrpcRoute_Destination: MessageFns<GrpcRoute_Destination> = {
  encode(message: GrpcRoute_Destination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== undefined) {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.weight !== undefined) {
      writer.uint32(16).int32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_Destination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_Destination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_Destination {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
    };
  },

  toJSON(message: GrpcRoute_Destination): unknown {
    const obj: any = {};
    if (message.serviceName !== undefined) {
      obj.serviceName = message.serviceName;
    }
    if (message.weight !== undefined) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_Destination>, I>>(base?: I): GrpcRoute_Destination {
    return GrpcRoute_Destination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_Destination>, I>>(object: I): GrpcRoute_Destination {
    const message = createBaseGrpcRoute_Destination();
    message.serviceName = object.serviceName ?? undefined;
    message.weight = object.weight ?? undefined;
    return message;
  },
};

function createBaseGrpcRoute_FaultInjectionPolicy(): GrpcRoute_FaultInjectionPolicy {
  return { delay: undefined, abort: undefined };
}

export const GrpcRoute_FaultInjectionPolicy: MessageFns<GrpcRoute_FaultInjectionPolicy> = {
  encode(message: GrpcRoute_FaultInjectionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delay !== undefined) {
      GrpcRoute_FaultInjectionPolicy_Delay.encode(message.delay, writer.uint32(10).fork()).join();
    }
    if (message.abort !== undefined) {
      GrpcRoute_FaultInjectionPolicy_Abort.encode(message.abort, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_FaultInjectionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_FaultInjectionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delay = GrpcRoute_FaultInjectionPolicy_Delay.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.abort = GrpcRoute_FaultInjectionPolicy_Abort.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_FaultInjectionPolicy {
    return {
      delay: isSet(object.delay) ? GrpcRoute_FaultInjectionPolicy_Delay.fromJSON(object.delay) : undefined,
      abort: isSet(object.abort) ? GrpcRoute_FaultInjectionPolicy_Abort.fromJSON(object.abort) : undefined,
    };
  },

  toJSON(message: GrpcRoute_FaultInjectionPolicy): unknown {
    const obj: any = {};
    if (message.delay !== undefined) {
      obj.delay = GrpcRoute_FaultInjectionPolicy_Delay.toJSON(message.delay);
    }
    if (message.abort !== undefined) {
      obj.abort = GrpcRoute_FaultInjectionPolicy_Abort.toJSON(message.abort);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_FaultInjectionPolicy>, I>>(base?: I): GrpcRoute_FaultInjectionPolicy {
    return GrpcRoute_FaultInjectionPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_FaultInjectionPolicy>, I>>(
    object: I,
  ): GrpcRoute_FaultInjectionPolicy {
    const message = createBaseGrpcRoute_FaultInjectionPolicy();
    message.delay = (object.delay !== undefined && object.delay !== null)
      ? GrpcRoute_FaultInjectionPolicy_Delay.fromPartial(object.delay)
      : undefined;
    message.abort = (object.abort !== undefined && object.abort !== null)
      ? GrpcRoute_FaultInjectionPolicy_Abort.fromPartial(object.abort)
      : undefined;
    return message;
  },
};

function createBaseGrpcRoute_FaultInjectionPolicy_Delay(): GrpcRoute_FaultInjectionPolicy_Delay {
  return { fixedDelay: undefined, percentage: undefined };
}

export const GrpcRoute_FaultInjectionPolicy_Delay: MessageFns<GrpcRoute_FaultInjectionPolicy_Delay> = {
  encode(message: GrpcRoute_FaultInjectionPolicy_Delay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fixedDelay !== undefined) {
      Duration.encode(message.fixedDelay, writer.uint32(10).fork()).join();
    }
    if (message.percentage !== undefined) {
      writer.uint32(16).int32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_FaultInjectionPolicy_Delay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_FaultInjectionPolicy_Delay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fixedDelay = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_FaultInjectionPolicy_Delay {
    return {
      fixedDelay: isSet(object.fixedDelay) ? Duration.fromJSON(object.fixedDelay) : undefined,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : undefined,
    };
  },

  toJSON(message: GrpcRoute_FaultInjectionPolicy_Delay): unknown {
    const obj: any = {};
    if (message.fixedDelay !== undefined) {
      obj.fixedDelay = Duration.toJSON(message.fixedDelay);
    }
    if (message.percentage !== undefined) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_FaultInjectionPolicy_Delay>, I>>(
    base?: I,
  ): GrpcRoute_FaultInjectionPolicy_Delay {
    return GrpcRoute_FaultInjectionPolicy_Delay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_FaultInjectionPolicy_Delay>, I>>(
    object: I,
  ): GrpcRoute_FaultInjectionPolicy_Delay {
    const message = createBaseGrpcRoute_FaultInjectionPolicy_Delay();
    message.fixedDelay = (object.fixedDelay !== undefined && object.fixedDelay !== null)
      ? Duration.fromPartial(object.fixedDelay)
      : undefined;
    message.percentage = object.percentage ?? undefined;
    return message;
  },
};

function createBaseGrpcRoute_FaultInjectionPolicy_Abort(): GrpcRoute_FaultInjectionPolicy_Abort {
  return { httpStatus: undefined, percentage: undefined };
}

export const GrpcRoute_FaultInjectionPolicy_Abort: MessageFns<GrpcRoute_FaultInjectionPolicy_Abort> = {
  encode(message: GrpcRoute_FaultInjectionPolicy_Abort, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpStatus !== undefined) {
      writer.uint32(8).int32(message.httpStatus);
    }
    if (message.percentage !== undefined) {
      writer.uint32(16).int32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_FaultInjectionPolicy_Abort {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_FaultInjectionPolicy_Abort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.httpStatus = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_FaultInjectionPolicy_Abort {
    return {
      httpStatus: isSet(object.httpStatus) ? globalThis.Number(object.httpStatus) : undefined,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : undefined,
    };
  },

  toJSON(message: GrpcRoute_FaultInjectionPolicy_Abort): unknown {
    const obj: any = {};
    if (message.httpStatus !== undefined) {
      obj.httpStatus = Math.round(message.httpStatus);
    }
    if (message.percentage !== undefined) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_FaultInjectionPolicy_Abort>, I>>(
    base?: I,
  ): GrpcRoute_FaultInjectionPolicy_Abort {
    return GrpcRoute_FaultInjectionPolicy_Abort.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_FaultInjectionPolicy_Abort>, I>>(
    object: I,
  ): GrpcRoute_FaultInjectionPolicy_Abort {
    const message = createBaseGrpcRoute_FaultInjectionPolicy_Abort();
    message.httpStatus = object.httpStatus ?? undefined;
    message.percentage = object.percentage ?? undefined;
    return message;
  },
};

function createBaseGrpcRoute_RetryPolicy(): GrpcRoute_RetryPolicy {
  return { retryConditions: [], numRetries: 0 };
}

export const GrpcRoute_RetryPolicy: MessageFns<GrpcRoute_RetryPolicy> = {
  encode(message: GrpcRoute_RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.retryConditions) {
      writer.uint32(10).string(v!);
    }
    if (message.numRetries !== 0) {
      writer.uint32(16).uint32(message.numRetries);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_RetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retryConditions.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numRetries = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_RetryPolicy {
    return {
      retryConditions: globalThis.Array.isArray(object?.retryConditions)
        ? object.retryConditions.map((e: any) => globalThis.String(e))
        : [],
      numRetries: isSet(object.numRetries) ? globalThis.Number(object.numRetries) : 0,
    };
  },

  toJSON(message: GrpcRoute_RetryPolicy): unknown {
    const obj: any = {};
    if (message.retryConditions?.length) {
      obj.retryConditions = message.retryConditions;
    }
    if (message.numRetries !== 0) {
      obj.numRetries = Math.round(message.numRetries);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_RetryPolicy>, I>>(base?: I): GrpcRoute_RetryPolicy {
    return GrpcRoute_RetryPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_RetryPolicy>, I>>(object: I): GrpcRoute_RetryPolicy {
    const message = createBaseGrpcRoute_RetryPolicy();
    message.retryConditions = object.retryConditions?.map((e) => e) || [];
    message.numRetries = object.numRetries ?? 0;
    return message;
  },
};

function createBaseGrpcRoute_RouteAction(): GrpcRoute_RouteAction {
  return { destinations: [], faultInjectionPolicy: undefined, timeout: undefined, retryPolicy: undefined };
}

export const GrpcRoute_RouteAction: MessageFns<GrpcRoute_RouteAction> = {
  encode(message: GrpcRoute_RouteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.destinations) {
      GrpcRoute_Destination.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.faultInjectionPolicy !== undefined) {
      GrpcRoute_FaultInjectionPolicy.encode(message.faultInjectionPolicy, writer.uint32(26).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(58).fork()).join();
    }
    if (message.retryPolicy !== undefined) {
      GrpcRoute_RetryPolicy.encode(message.retryPolicy, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_RouteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_RouteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destinations.push(GrpcRoute_Destination.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.faultInjectionPolicy = GrpcRoute_FaultInjectionPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.retryPolicy = GrpcRoute_RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_RouteAction {
    return {
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => GrpcRoute_Destination.fromJSON(e))
        : [],
      faultInjectionPolicy: isSet(object.faultInjectionPolicy)
        ? GrpcRoute_FaultInjectionPolicy.fromJSON(object.faultInjectionPolicy)
        : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      retryPolicy: isSet(object.retryPolicy) ? GrpcRoute_RetryPolicy.fromJSON(object.retryPolicy) : undefined,
    };
  },

  toJSON(message: GrpcRoute_RouteAction): unknown {
    const obj: any = {};
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => GrpcRoute_Destination.toJSON(e));
    }
    if (message.faultInjectionPolicy !== undefined) {
      obj.faultInjectionPolicy = GrpcRoute_FaultInjectionPolicy.toJSON(message.faultInjectionPolicy);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.retryPolicy !== undefined) {
      obj.retryPolicy = GrpcRoute_RetryPolicy.toJSON(message.retryPolicy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_RouteAction>, I>>(base?: I): GrpcRoute_RouteAction {
    return GrpcRoute_RouteAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_RouteAction>, I>>(object: I): GrpcRoute_RouteAction {
    const message = createBaseGrpcRoute_RouteAction();
    message.destinations = object.destinations?.map((e) => GrpcRoute_Destination.fromPartial(e)) || [];
    message.faultInjectionPolicy = (object.faultInjectionPolicy !== undefined && object.faultInjectionPolicy !== null)
      ? GrpcRoute_FaultInjectionPolicy.fromPartial(object.faultInjectionPolicy)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.retryPolicy = (object.retryPolicy !== undefined && object.retryPolicy !== null)
      ? GrpcRoute_RetryPolicy.fromPartial(object.retryPolicy)
      : undefined;
    return message;
  },
};

function createBaseGrpcRoute_RouteRule(): GrpcRoute_RouteRule {
  return { matches: [], action: undefined };
}

export const GrpcRoute_RouteRule: MessageFns<GrpcRoute_RouteRule> = {
  encode(message: GrpcRoute_RouteRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      GrpcRoute_RouteMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.action !== undefined) {
      GrpcRoute_RouteAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_RouteRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_RouteRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(GrpcRoute_RouteMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = GrpcRoute_RouteAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_RouteRule {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => GrpcRoute_RouteMatch.fromJSON(e))
        : [],
      action: isSet(object.action) ? GrpcRoute_RouteAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: GrpcRoute_RouteRule): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => GrpcRoute_RouteMatch.toJSON(e));
    }
    if (message.action !== undefined) {
      obj.action = GrpcRoute_RouteAction.toJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_RouteRule>, I>>(base?: I): GrpcRoute_RouteRule {
    return GrpcRoute_RouteRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_RouteRule>, I>>(object: I): GrpcRoute_RouteRule {
    const message = createBaseGrpcRoute_RouteRule();
    message.matches = object.matches?.map((e) => GrpcRoute_RouteMatch.fromPartial(e)) || [];
    message.action = (object.action !== undefined && object.action !== null)
      ? GrpcRoute_RouteAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseGrpcRoute_LabelsEntry(): GrpcRoute_LabelsEntry {
  return { key: "", value: "" };
}

export const GrpcRoute_LabelsEntry: MessageFns<GrpcRoute_LabelsEntry> = {
  encode(message: GrpcRoute_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GrpcRoute_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRoute_LabelsEntry>, I>>(base?: I): GrpcRoute_LabelsEntry {
    return GrpcRoute_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRoute_LabelsEntry>, I>>(object: I): GrpcRoute_LabelsEntry {
    const message = createBaseGrpcRoute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHttpRoute(): HttpRoute {
  return {
    name: "",
    selfLink: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    hostnames: [],
    meshes: [],
    gateways: [],
    labels: {},
    rules: [],
  };
}

export const HttpRoute: MessageFns<HttpRoute> = {
  encode(message: HttpRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selfLink !== "") {
      writer.uint32(90).string(message.selfLink);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    for (const v of message.hostnames) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.meshes) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.gateways) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      HttpRoute_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    for (const v of message.rules) {
      HttpRoute_RouteRule.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hostnames.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.meshes.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gateways.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = HttpRoute_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rules.push(HttpRoute_RouteRule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      hostnames: globalThis.Array.isArray(object?.hostnames)
        ? object.hostnames.map((e: any) => globalThis.String(e))
        : [],
      meshes: globalThis.Array.isArray(object?.meshes) ? object.meshes.map((e: any) => globalThis.String(e)) : [],
      gateways: globalThis.Array.isArray(object?.gateways) ? object.gateways.map((e: any) => globalThis.String(e)) : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => HttpRoute_RouteRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HttpRoute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.hostnames?.length) {
      obj.hostnames = message.hostnames;
    }
    if (message.meshes?.length) {
      obj.meshes = message.meshes;
    }
    if (message.gateways?.length) {
      obj.gateways = message.gateways;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => HttpRoute_RouteRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute>, I>>(base?: I): HttpRoute {
    return HttpRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute>, I>>(object: I): HttpRoute {
    const message = createBaseHttpRoute();
    message.name = object.name ?? "";
    message.selfLink = object.selfLink ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.hostnames = object.hostnames?.map((e) => e) || [];
    message.meshes = object.meshes?.map((e) => e) || [];
    message.gateways = object.gateways?.map((e) => e) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.rules = object.rules?.map((e) => HttpRoute_RouteRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHttpRoute_HeaderMatch(): HttpRoute_HeaderMatch {
  return {
    exactMatch: undefined,
    regexMatch: undefined,
    prefixMatch: undefined,
    presentMatch: undefined,
    suffixMatch: undefined,
    rangeMatch: undefined,
    header: "",
    invertMatch: false,
  };
}

export const HttpRoute_HeaderMatch: MessageFns<HttpRoute_HeaderMatch> = {
  encode(message: HttpRoute_HeaderMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exactMatch !== undefined) {
      writer.uint32(18).string(message.exactMatch);
    }
    if (message.regexMatch !== undefined) {
      writer.uint32(26).string(message.regexMatch);
    }
    if (message.prefixMatch !== undefined) {
      writer.uint32(34).string(message.prefixMatch);
    }
    if (message.presentMatch !== undefined) {
      writer.uint32(40).bool(message.presentMatch);
    }
    if (message.suffixMatch !== undefined) {
      writer.uint32(50).string(message.suffixMatch);
    }
    if (message.rangeMatch !== undefined) {
      HttpRoute_HeaderMatch_IntegerRange.encode(message.rangeMatch, writer.uint32(58).fork()).join();
    }
    if (message.header !== "") {
      writer.uint32(10).string(message.header);
    }
    if (message.invertMatch !== false) {
      writer.uint32(64).bool(message.invertMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exactMatch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.regexMatch = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prefixMatch = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.presentMatch = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.suffixMatch = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rangeMatch = HttpRoute_HeaderMatch_IntegerRange.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.invertMatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderMatch {
    return {
      exactMatch: isSet(object.exactMatch) ? globalThis.String(object.exactMatch) : undefined,
      regexMatch: isSet(object.regexMatch) ? globalThis.String(object.regexMatch) : undefined,
      prefixMatch: isSet(object.prefixMatch) ? globalThis.String(object.prefixMatch) : undefined,
      presentMatch: isSet(object.presentMatch) ? globalThis.Boolean(object.presentMatch) : undefined,
      suffixMatch: isSet(object.suffixMatch) ? globalThis.String(object.suffixMatch) : undefined,
      rangeMatch: isSet(object.rangeMatch) ? HttpRoute_HeaderMatch_IntegerRange.fromJSON(object.rangeMatch) : undefined,
      header: isSet(object.header) ? globalThis.String(object.header) : "",
      invertMatch: isSet(object.invertMatch) ? globalThis.Boolean(object.invertMatch) : false,
    };
  },

  toJSON(message: HttpRoute_HeaderMatch): unknown {
    const obj: any = {};
    if (message.exactMatch !== undefined) {
      obj.exactMatch = message.exactMatch;
    }
    if (message.regexMatch !== undefined) {
      obj.regexMatch = message.regexMatch;
    }
    if (message.prefixMatch !== undefined) {
      obj.prefixMatch = message.prefixMatch;
    }
    if (message.presentMatch !== undefined) {
      obj.presentMatch = message.presentMatch;
    }
    if (message.suffixMatch !== undefined) {
      obj.suffixMatch = message.suffixMatch;
    }
    if (message.rangeMatch !== undefined) {
      obj.rangeMatch = HttpRoute_HeaderMatch_IntegerRange.toJSON(message.rangeMatch);
    }
    if (message.header !== "") {
      obj.header = message.header;
    }
    if (message.invertMatch !== false) {
      obj.invertMatch = message.invertMatch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_HeaderMatch>, I>>(base?: I): HttpRoute_HeaderMatch {
    return HttpRoute_HeaderMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_HeaderMatch>, I>>(object: I): HttpRoute_HeaderMatch {
    const message = createBaseHttpRoute_HeaderMatch();
    message.exactMatch = object.exactMatch ?? undefined;
    message.regexMatch = object.regexMatch ?? undefined;
    message.prefixMatch = object.prefixMatch ?? undefined;
    message.presentMatch = object.presentMatch ?? undefined;
    message.suffixMatch = object.suffixMatch ?? undefined;
    message.rangeMatch = (object.rangeMatch !== undefined && object.rangeMatch !== null)
      ? HttpRoute_HeaderMatch_IntegerRange.fromPartial(object.rangeMatch)
      : undefined;
    message.header = object.header ?? "";
    message.invertMatch = object.invertMatch ?? false;
    return message;
  },
};

function createBaseHttpRoute_HeaderMatch_IntegerRange(): HttpRoute_HeaderMatch_IntegerRange {
  return { start: 0, end: 0 };
}

export const HttpRoute_HeaderMatch_IntegerRange: MessageFns<HttpRoute_HeaderMatch_IntegerRange> = {
  encode(message: HttpRoute_HeaderMatch_IntegerRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderMatch_IntegerRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderMatch_IntegerRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.end = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderMatch_IntegerRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
    };
  },

  toJSON(message: HttpRoute_HeaderMatch_IntegerRange): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_HeaderMatch_IntegerRange>, I>>(
    base?: I,
  ): HttpRoute_HeaderMatch_IntegerRange {
    return HttpRoute_HeaderMatch_IntegerRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_HeaderMatch_IntegerRange>, I>>(
    object: I,
  ): HttpRoute_HeaderMatch_IntegerRange {
    const message = createBaseHttpRoute_HeaderMatch_IntegerRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  },
};

function createBaseHttpRoute_QueryParameterMatch(): HttpRoute_QueryParameterMatch {
  return { exactMatch: undefined, regexMatch: undefined, presentMatch: undefined, queryParameter: "" };
}

export const HttpRoute_QueryParameterMatch: MessageFns<HttpRoute_QueryParameterMatch> = {
  encode(message: HttpRoute_QueryParameterMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exactMatch !== undefined) {
      writer.uint32(18).string(message.exactMatch);
    }
    if (message.regexMatch !== undefined) {
      writer.uint32(26).string(message.regexMatch);
    }
    if (message.presentMatch !== undefined) {
      writer.uint32(32).bool(message.presentMatch);
    }
    if (message.queryParameter !== "") {
      writer.uint32(10).string(message.queryParameter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_QueryParameterMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_QueryParameterMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exactMatch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.regexMatch = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.presentMatch = reader.bool();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryParameter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_QueryParameterMatch {
    return {
      exactMatch: isSet(object.exactMatch) ? globalThis.String(object.exactMatch) : undefined,
      regexMatch: isSet(object.regexMatch) ? globalThis.String(object.regexMatch) : undefined,
      presentMatch: isSet(object.presentMatch) ? globalThis.Boolean(object.presentMatch) : undefined,
      queryParameter: isSet(object.queryParameter) ? globalThis.String(object.queryParameter) : "",
    };
  },

  toJSON(message: HttpRoute_QueryParameterMatch): unknown {
    const obj: any = {};
    if (message.exactMatch !== undefined) {
      obj.exactMatch = message.exactMatch;
    }
    if (message.regexMatch !== undefined) {
      obj.regexMatch = message.regexMatch;
    }
    if (message.presentMatch !== undefined) {
      obj.presentMatch = message.presentMatch;
    }
    if (message.queryParameter !== "") {
      obj.queryParameter = message.queryParameter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_QueryParameterMatch>, I>>(base?: I): HttpRoute_QueryParameterMatch {
    return HttpRoute_QueryParameterMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_QueryParameterMatch>, I>>(
    object: I,
  ): HttpRoute_QueryParameterMatch {
    const message = createBaseHttpRoute_QueryParameterMatch();
    message.exactMatch = object.exactMatch ?? undefined;
    message.regexMatch = object.regexMatch ?? undefined;
    message.presentMatch = object.presentMatch ?? undefined;
    message.queryParameter = object.queryParameter ?? "";
    return message;
  },
};

function createBaseHttpRoute_RouteMatch(): HttpRoute_RouteMatch {
  return {
    fullPathMatch: undefined,
    prefixMatch: undefined,
    regexMatch: undefined,
    ignoreCase: false,
    headers: [],
    queryParameters: [],
  };
}

export const HttpRoute_RouteMatch: MessageFns<HttpRoute_RouteMatch> = {
  encode(message: HttpRoute_RouteMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullPathMatch !== undefined) {
      writer.uint32(10).string(message.fullPathMatch);
    }
    if (message.prefixMatch !== undefined) {
      writer.uint32(18).string(message.prefixMatch);
    }
    if (message.regexMatch !== undefined) {
      writer.uint32(26).string(message.regexMatch);
    }
    if (message.ignoreCase !== false) {
      writer.uint32(32).bool(message.ignoreCase);
    }
    for (const v of message.headers) {
      HttpRoute_HeaderMatch.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.queryParameters) {
      HttpRoute_QueryParameterMatch.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RouteMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RouteMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fullPathMatch = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefixMatch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.regexMatch = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ignoreCase = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.headers.push(HttpRoute_HeaderMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.queryParameters.push(HttpRoute_QueryParameterMatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RouteMatch {
    return {
      fullPathMatch: isSet(object.fullPathMatch) ? globalThis.String(object.fullPathMatch) : undefined,
      prefixMatch: isSet(object.prefixMatch) ? globalThis.String(object.prefixMatch) : undefined,
      regexMatch: isSet(object.regexMatch) ? globalThis.String(object.regexMatch) : undefined,
      ignoreCase: isSet(object.ignoreCase) ? globalThis.Boolean(object.ignoreCase) : false,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HttpRoute_HeaderMatch.fromJSON(e))
        : [],
      queryParameters: globalThis.Array.isArray(object?.queryParameters)
        ? object.queryParameters.map((e: any) => HttpRoute_QueryParameterMatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HttpRoute_RouteMatch): unknown {
    const obj: any = {};
    if (message.fullPathMatch !== undefined) {
      obj.fullPathMatch = message.fullPathMatch;
    }
    if (message.prefixMatch !== undefined) {
      obj.prefixMatch = message.prefixMatch;
    }
    if (message.regexMatch !== undefined) {
      obj.regexMatch = message.regexMatch;
    }
    if (message.ignoreCase !== false) {
      obj.ignoreCase = message.ignoreCase;
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HttpRoute_HeaderMatch.toJSON(e));
    }
    if (message.queryParameters?.length) {
      obj.queryParameters = message.queryParameters.map((e) => HttpRoute_QueryParameterMatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_RouteMatch>, I>>(base?: I): HttpRoute_RouteMatch {
    return HttpRoute_RouteMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_RouteMatch>, I>>(object: I): HttpRoute_RouteMatch {
    const message = createBaseHttpRoute_RouteMatch();
    message.fullPathMatch = object.fullPathMatch ?? undefined;
    message.prefixMatch = object.prefixMatch ?? undefined;
    message.regexMatch = object.regexMatch ?? undefined;
    message.ignoreCase = object.ignoreCase ?? false;
    message.headers = object.headers?.map((e) => HttpRoute_HeaderMatch.fromPartial(e)) || [];
    message.queryParameters = object.queryParameters?.map((e) => HttpRoute_QueryParameterMatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHttpRoute_Destination(): HttpRoute_Destination {
  return { serviceName: "", weight: 0 };
}

export const HttpRoute_Destination: MessageFns<HttpRoute_Destination> = {
  encode(message: HttpRoute_Destination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.weight !== 0) {
      writer.uint32(16).int32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_Destination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_Destination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_Destination {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: HttpRoute_Destination): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_Destination>, I>>(base?: I): HttpRoute_Destination {
    return HttpRoute_Destination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_Destination>, I>>(object: I): HttpRoute_Destination {
    const message = createBaseHttpRoute_Destination();
    message.serviceName = object.serviceName ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseHttpRoute_Redirect(): HttpRoute_Redirect {
  return {
    hostRedirect: "",
    pathRedirect: "",
    prefixRewrite: "",
    responseCode: 0,
    httpsRedirect: false,
    stripQuery: false,
    portRedirect: 0,
  };
}

export const HttpRoute_Redirect: MessageFns<HttpRoute_Redirect> = {
  encode(message: HttpRoute_Redirect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostRedirect !== "") {
      writer.uint32(10).string(message.hostRedirect);
    }
    if (message.pathRedirect !== "") {
      writer.uint32(18).string(message.pathRedirect);
    }
    if (message.prefixRewrite !== "") {
      writer.uint32(26).string(message.prefixRewrite);
    }
    if (message.responseCode !== 0) {
      writer.uint32(32).int32(message.responseCode);
    }
    if (message.httpsRedirect !== false) {
      writer.uint32(40).bool(message.httpsRedirect);
    }
    if (message.stripQuery !== false) {
      writer.uint32(48).bool(message.stripQuery);
    }
    if (message.portRedirect !== 0) {
      writer.uint32(56).int32(message.portRedirect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_Redirect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_Redirect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostRedirect = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pathRedirect = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefixRewrite = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.responseCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.httpsRedirect = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.stripQuery = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.portRedirect = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_Redirect {
    return {
      hostRedirect: isSet(object.hostRedirect) ? globalThis.String(object.hostRedirect) : "",
      pathRedirect: isSet(object.pathRedirect) ? globalThis.String(object.pathRedirect) : "",
      prefixRewrite: isSet(object.prefixRewrite) ? globalThis.String(object.prefixRewrite) : "",
      responseCode: isSet(object.responseCode) ? httpRoute_Redirect_ResponseCodeFromJSON(object.responseCode) : 0,
      httpsRedirect: isSet(object.httpsRedirect) ? globalThis.Boolean(object.httpsRedirect) : false,
      stripQuery: isSet(object.stripQuery) ? globalThis.Boolean(object.stripQuery) : false,
      portRedirect: isSet(object.portRedirect) ? globalThis.Number(object.portRedirect) : 0,
    };
  },

  toJSON(message: HttpRoute_Redirect): unknown {
    const obj: any = {};
    if (message.hostRedirect !== "") {
      obj.hostRedirect = message.hostRedirect;
    }
    if (message.pathRedirect !== "") {
      obj.pathRedirect = message.pathRedirect;
    }
    if (message.prefixRewrite !== "") {
      obj.prefixRewrite = message.prefixRewrite;
    }
    if (message.responseCode !== 0) {
      obj.responseCode = httpRoute_Redirect_ResponseCodeToJSON(message.responseCode);
    }
    if (message.httpsRedirect !== false) {
      obj.httpsRedirect = message.httpsRedirect;
    }
    if (message.stripQuery !== false) {
      obj.stripQuery = message.stripQuery;
    }
    if (message.portRedirect !== 0) {
      obj.portRedirect = Math.round(message.portRedirect);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_Redirect>, I>>(base?: I): HttpRoute_Redirect {
    return HttpRoute_Redirect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_Redirect>, I>>(object: I): HttpRoute_Redirect {
    const message = createBaseHttpRoute_Redirect();
    message.hostRedirect = object.hostRedirect ?? "";
    message.pathRedirect = object.pathRedirect ?? "";
    message.prefixRewrite = object.prefixRewrite ?? "";
    message.responseCode = object.responseCode ?? 0;
    message.httpsRedirect = object.httpsRedirect ?? false;
    message.stripQuery = object.stripQuery ?? false;
    message.portRedirect = object.portRedirect ?? 0;
    return message;
  },
};

function createBaseHttpRoute_FaultInjectionPolicy(): HttpRoute_FaultInjectionPolicy {
  return { delay: undefined, abort: undefined };
}

export const HttpRoute_FaultInjectionPolicy: MessageFns<HttpRoute_FaultInjectionPolicy> = {
  encode(message: HttpRoute_FaultInjectionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delay !== undefined) {
      HttpRoute_FaultInjectionPolicy_Delay.encode(message.delay, writer.uint32(10).fork()).join();
    }
    if (message.abort !== undefined) {
      HttpRoute_FaultInjectionPolicy_Abort.encode(message.abort, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_FaultInjectionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_FaultInjectionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delay = HttpRoute_FaultInjectionPolicy_Delay.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.abort = HttpRoute_FaultInjectionPolicy_Abort.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_FaultInjectionPolicy {
    return {
      delay: isSet(object.delay) ? HttpRoute_FaultInjectionPolicy_Delay.fromJSON(object.delay) : undefined,
      abort: isSet(object.abort) ? HttpRoute_FaultInjectionPolicy_Abort.fromJSON(object.abort) : undefined,
    };
  },

  toJSON(message: HttpRoute_FaultInjectionPolicy): unknown {
    const obj: any = {};
    if (message.delay !== undefined) {
      obj.delay = HttpRoute_FaultInjectionPolicy_Delay.toJSON(message.delay);
    }
    if (message.abort !== undefined) {
      obj.abort = HttpRoute_FaultInjectionPolicy_Abort.toJSON(message.abort);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_FaultInjectionPolicy>, I>>(base?: I): HttpRoute_FaultInjectionPolicy {
    return HttpRoute_FaultInjectionPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_FaultInjectionPolicy>, I>>(
    object: I,
  ): HttpRoute_FaultInjectionPolicy {
    const message = createBaseHttpRoute_FaultInjectionPolicy();
    message.delay = (object.delay !== undefined && object.delay !== null)
      ? HttpRoute_FaultInjectionPolicy_Delay.fromPartial(object.delay)
      : undefined;
    message.abort = (object.abort !== undefined && object.abort !== null)
      ? HttpRoute_FaultInjectionPolicy_Abort.fromPartial(object.abort)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_FaultInjectionPolicy_Delay(): HttpRoute_FaultInjectionPolicy_Delay {
  return { fixedDelay: undefined, percentage: 0 };
}

export const HttpRoute_FaultInjectionPolicy_Delay: MessageFns<HttpRoute_FaultInjectionPolicy_Delay> = {
  encode(message: HttpRoute_FaultInjectionPolicy_Delay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fixedDelay !== undefined) {
      Duration.encode(message.fixedDelay, writer.uint32(10).fork()).join();
    }
    if (message.percentage !== 0) {
      writer.uint32(16).int32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_FaultInjectionPolicy_Delay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_FaultInjectionPolicy_Delay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fixedDelay = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_FaultInjectionPolicy_Delay {
    return {
      fixedDelay: isSet(object.fixedDelay) ? Duration.fromJSON(object.fixedDelay) : undefined,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
    };
  },

  toJSON(message: HttpRoute_FaultInjectionPolicy_Delay): unknown {
    const obj: any = {};
    if (message.fixedDelay !== undefined) {
      obj.fixedDelay = Duration.toJSON(message.fixedDelay);
    }
    if (message.percentage !== 0) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_FaultInjectionPolicy_Delay>, I>>(
    base?: I,
  ): HttpRoute_FaultInjectionPolicy_Delay {
    return HttpRoute_FaultInjectionPolicy_Delay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_FaultInjectionPolicy_Delay>, I>>(
    object: I,
  ): HttpRoute_FaultInjectionPolicy_Delay {
    const message = createBaseHttpRoute_FaultInjectionPolicy_Delay();
    message.fixedDelay = (object.fixedDelay !== undefined && object.fixedDelay !== null)
      ? Duration.fromPartial(object.fixedDelay)
      : undefined;
    message.percentage = object.percentage ?? 0;
    return message;
  },
};

function createBaseHttpRoute_FaultInjectionPolicy_Abort(): HttpRoute_FaultInjectionPolicy_Abort {
  return { httpStatus: 0, percentage: 0 };
}

export const HttpRoute_FaultInjectionPolicy_Abort: MessageFns<HttpRoute_FaultInjectionPolicy_Abort> = {
  encode(message: HttpRoute_FaultInjectionPolicy_Abort, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpStatus !== 0) {
      writer.uint32(8).int32(message.httpStatus);
    }
    if (message.percentage !== 0) {
      writer.uint32(16).int32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_FaultInjectionPolicy_Abort {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_FaultInjectionPolicy_Abort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.httpStatus = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_FaultInjectionPolicy_Abort {
    return {
      httpStatus: isSet(object.httpStatus) ? globalThis.Number(object.httpStatus) : 0,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
    };
  },

  toJSON(message: HttpRoute_FaultInjectionPolicy_Abort): unknown {
    const obj: any = {};
    if (message.httpStatus !== 0) {
      obj.httpStatus = Math.round(message.httpStatus);
    }
    if (message.percentage !== 0) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_FaultInjectionPolicy_Abort>, I>>(
    base?: I,
  ): HttpRoute_FaultInjectionPolicy_Abort {
    return HttpRoute_FaultInjectionPolicy_Abort.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_FaultInjectionPolicy_Abort>, I>>(
    object: I,
  ): HttpRoute_FaultInjectionPolicy_Abort {
    const message = createBaseHttpRoute_FaultInjectionPolicy_Abort();
    message.httpStatus = object.httpStatus ?? 0;
    message.percentage = object.percentage ?? 0;
    return message;
  },
};

function createBaseHttpRoute_HeaderModifier(): HttpRoute_HeaderModifier {
  return { set: {}, add: {}, remove: [] };
}

export const HttpRoute_HeaderModifier: MessageFns<HttpRoute_HeaderModifier> = {
  encode(message: HttpRoute_HeaderModifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.set).forEach(([key, value]) => {
      HttpRoute_HeaderModifier_SetEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.add).forEach(([key, value]) => {
      HttpRoute_HeaderModifier_AddEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    for (const v of message.remove) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderModifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderModifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = HttpRoute_HeaderModifier_SetEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.set[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HttpRoute_HeaderModifier_AddEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.add[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remove.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderModifier {
    return {
      set: isObject(object.set)
        ? Object.entries(object.set).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      add: isObject(object.add)
        ? Object.entries(object.add).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      remove: globalThis.Array.isArray(object?.remove) ? object.remove.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: HttpRoute_HeaderModifier): unknown {
    const obj: any = {};
    if (message.set) {
      const entries = Object.entries(message.set);
      if (entries.length > 0) {
        obj.set = {};
        entries.forEach(([k, v]) => {
          obj.set[k] = v;
        });
      }
    }
    if (message.add) {
      const entries = Object.entries(message.add);
      if (entries.length > 0) {
        obj.add = {};
        entries.forEach(([k, v]) => {
          obj.add[k] = v;
        });
      }
    }
    if (message.remove?.length) {
      obj.remove = message.remove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_HeaderModifier>, I>>(base?: I): HttpRoute_HeaderModifier {
    return HttpRoute_HeaderModifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_HeaderModifier>, I>>(object: I): HttpRoute_HeaderModifier {
    const message = createBaseHttpRoute_HeaderModifier();
    message.set = Object.entries(object.set ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.add = Object.entries(object.add ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.remove = object.remove?.map((e) => e) || [];
    return message;
  },
};

function createBaseHttpRoute_HeaderModifier_SetEntry(): HttpRoute_HeaderModifier_SetEntry {
  return { key: "", value: "" };
}

export const HttpRoute_HeaderModifier_SetEntry: MessageFns<HttpRoute_HeaderModifier_SetEntry> = {
  encode(message: HttpRoute_HeaderModifier_SetEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderModifier_SetEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderModifier_SetEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderModifier_SetEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpRoute_HeaderModifier_SetEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_HeaderModifier_SetEntry>, I>>(
    base?: I,
  ): HttpRoute_HeaderModifier_SetEntry {
    return HttpRoute_HeaderModifier_SetEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_HeaderModifier_SetEntry>, I>>(
    object: I,
  ): HttpRoute_HeaderModifier_SetEntry {
    const message = createBaseHttpRoute_HeaderModifier_SetEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHttpRoute_HeaderModifier_AddEntry(): HttpRoute_HeaderModifier_AddEntry {
  return { key: "", value: "" };
}

export const HttpRoute_HeaderModifier_AddEntry: MessageFns<HttpRoute_HeaderModifier_AddEntry> = {
  encode(message: HttpRoute_HeaderModifier_AddEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderModifier_AddEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderModifier_AddEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderModifier_AddEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpRoute_HeaderModifier_AddEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_HeaderModifier_AddEntry>, I>>(
    base?: I,
  ): HttpRoute_HeaderModifier_AddEntry {
    return HttpRoute_HeaderModifier_AddEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_HeaderModifier_AddEntry>, I>>(
    object: I,
  ): HttpRoute_HeaderModifier_AddEntry {
    const message = createBaseHttpRoute_HeaderModifier_AddEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHttpRoute_URLRewrite(): HttpRoute_URLRewrite {
  return { pathPrefixRewrite: "", hostRewrite: "" };
}

export const HttpRoute_URLRewrite: MessageFns<HttpRoute_URLRewrite> = {
  encode(message: HttpRoute_URLRewrite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pathPrefixRewrite !== "") {
      writer.uint32(10).string(message.pathPrefixRewrite);
    }
    if (message.hostRewrite !== "") {
      writer.uint32(18).string(message.hostRewrite);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_URLRewrite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_URLRewrite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pathPrefixRewrite = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostRewrite = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_URLRewrite {
    return {
      pathPrefixRewrite: isSet(object.pathPrefixRewrite) ? globalThis.String(object.pathPrefixRewrite) : "",
      hostRewrite: isSet(object.hostRewrite) ? globalThis.String(object.hostRewrite) : "",
    };
  },

  toJSON(message: HttpRoute_URLRewrite): unknown {
    const obj: any = {};
    if (message.pathPrefixRewrite !== "") {
      obj.pathPrefixRewrite = message.pathPrefixRewrite;
    }
    if (message.hostRewrite !== "") {
      obj.hostRewrite = message.hostRewrite;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_URLRewrite>, I>>(base?: I): HttpRoute_URLRewrite {
    return HttpRoute_URLRewrite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_URLRewrite>, I>>(object: I): HttpRoute_URLRewrite {
    const message = createBaseHttpRoute_URLRewrite();
    message.pathPrefixRewrite = object.pathPrefixRewrite ?? "";
    message.hostRewrite = object.hostRewrite ?? "";
    return message;
  },
};

function createBaseHttpRoute_RetryPolicy(): HttpRoute_RetryPolicy {
  return { retryConditions: [], numRetries: 0, perTryTimeout: undefined };
}

export const HttpRoute_RetryPolicy: MessageFns<HttpRoute_RetryPolicy> = {
  encode(message: HttpRoute_RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.retryConditions) {
      writer.uint32(10).string(v!);
    }
    if (message.numRetries !== 0) {
      writer.uint32(16).int32(message.numRetries);
    }
    if (message.perTryTimeout !== undefined) {
      Duration.encode(message.perTryTimeout, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retryConditions.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numRetries = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.perTryTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RetryPolicy {
    return {
      retryConditions: globalThis.Array.isArray(object?.retryConditions)
        ? object.retryConditions.map((e: any) => globalThis.String(e))
        : [],
      numRetries: isSet(object.numRetries) ? globalThis.Number(object.numRetries) : 0,
      perTryTimeout: isSet(object.perTryTimeout) ? Duration.fromJSON(object.perTryTimeout) : undefined,
    };
  },

  toJSON(message: HttpRoute_RetryPolicy): unknown {
    const obj: any = {};
    if (message.retryConditions?.length) {
      obj.retryConditions = message.retryConditions;
    }
    if (message.numRetries !== 0) {
      obj.numRetries = Math.round(message.numRetries);
    }
    if (message.perTryTimeout !== undefined) {
      obj.perTryTimeout = Duration.toJSON(message.perTryTimeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_RetryPolicy>, I>>(base?: I): HttpRoute_RetryPolicy {
    return HttpRoute_RetryPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_RetryPolicy>, I>>(object: I): HttpRoute_RetryPolicy {
    const message = createBaseHttpRoute_RetryPolicy();
    message.retryConditions = object.retryConditions?.map((e) => e) || [];
    message.numRetries = object.numRetries ?? 0;
    message.perTryTimeout = (object.perTryTimeout !== undefined && object.perTryTimeout !== null)
      ? Duration.fromPartial(object.perTryTimeout)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_RequestMirrorPolicy(): HttpRoute_RequestMirrorPolicy {
  return { destination: undefined };
}

export const HttpRoute_RequestMirrorPolicy: MessageFns<HttpRoute_RequestMirrorPolicy> = {
  encode(message: HttpRoute_RequestMirrorPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.destination !== undefined) {
      HttpRoute_Destination.encode(message.destination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RequestMirrorPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RequestMirrorPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destination = HttpRoute_Destination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RequestMirrorPolicy {
    return { destination: isSet(object.destination) ? HttpRoute_Destination.fromJSON(object.destination) : undefined };
  },

  toJSON(message: HttpRoute_RequestMirrorPolicy): unknown {
    const obj: any = {};
    if (message.destination !== undefined) {
      obj.destination = HttpRoute_Destination.toJSON(message.destination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_RequestMirrorPolicy>, I>>(base?: I): HttpRoute_RequestMirrorPolicy {
    return HttpRoute_RequestMirrorPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_RequestMirrorPolicy>, I>>(
    object: I,
  ): HttpRoute_RequestMirrorPolicy {
    const message = createBaseHttpRoute_RequestMirrorPolicy();
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? HttpRoute_Destination.fromPartial(object.destination)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_CorsPolicy(): HttpRoute_CorsPolicy {
  return {
    allowOrigins: [],
    allowOriginRegexes: [],
    allowMethods: [],
    allowHeaders: [],
    exposeHeaders: [],
    maxAge: "",
    allowCredentials: false,
    disabled: false,
  };
}

export const HttpRoute_CorsPolicy: MessageFns<HttpRoute_CorsPolicy> = {
  encode(message: HttpRoute_CorsPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowOrigins) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.allowOriginRegexes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.allowMethods) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.allowHeaders) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.exposeHeaders) {
      writer.uint32(42).string(v!);
    }
    if (message.maxAge !== "") {
      writer.uint32(50).string(message.maxAge);
    }
    if (message.allowCredentials !== false) {
      writer.uint32(56).bool(message.allowCredentials);
    }
    if (message.disabled !== false) {
      writer.uint32(64).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_CorsPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_CorsPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowOrigins.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowOriginRegexes.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allowMethods.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allowHeaders.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exposeHeaders.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.maxAge = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.allowCredentials = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_CorsPolicy {
    return {
      allowOrigins: globalThis.Array.isArray(object?.allowOrigins)
        ? object.allowOrigins.map((e: any) => globalThis.String(e))
        : [],
      allowOriginRegexes: globalThis.Array.isArray(object?.allowOriginRegexes)
        ? object.allowOriginRegexes.map((e: any) => globalThis.String(e))
        : [],
      allowMethods: globalThis.Array.isArray(object?.allowMethods)
        ? object.allowMethods.map((e: any) => globalThis.String(e))
        : [],
      allowHeaders: globalThis.Array.isArray(object?.allowHeaders)
        ? object.allowHeaders.map((e: any) => globalThis.String(e))
        : [],
      exposeHeaders: globalThis.Array.isArray(object?.exposeHeaders)
        ? object.exposeHeaders.map((e: any) => globalThis.String(e))
        : [],
      maxAge: isSet(object.maxAge) ? globalThis.String(object.maxAge) : "",
      allowCredentials: isSet(object.allowCredentials) ? globalThis.Boolean(object.allowCredentials) : false,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
    };
  },

  toJSON(message: HttpRoute_CorsPolicy): unknown {
    const obj: any = {};
    if (message.allowOrigins?.length) {
      obj.allowOrigins = message.allowOrigins;
    }
    if (message.allowOriginRegexes?.length) {
      obj.allowOriginRegexes = message.allowOriginRegexes;
    }
    if (message.allowMethods?.length) {
      obj.allowMethods = message.allowMethods;
    }
    if (message.allowHeaders?.length) {
      obj.allowHeaders = message.allowHeaders;
    }
    if (message.exposeHeaders?.length) {
      obj.exposeHeaders = message.exposeHeaders;
    }
    if (message.maxAge !== "") {
      obj.maxAge = message.maxAge;
    }
    if (message.allowCredentials !== false) {
      obj.allowCredentials = message.allowCredentials;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_CorsPolicy>, I>>(base?: I): HttpRoute_CorsPolicy {
    return HttpRoute_CorsPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_CorsPolicy>, I>>(object: I): HttpRoute_CorsPolicy {
    const message = createBaseHttpRoute_CorsPolicy();
    message.allowOrigins = object.allowOrigins?.map((e) => e) || [];
    message.allowOriginRegexes = object.allowOriginRegexes?.map((e) => e) || [];
    message.allowMethods = object.allowMethods?.map((e) => e) || [];
    message.allowHeaders = object.allowHeaders?.map((e) => e) || [];
    message.exposeHeaders = object.exposeHeaders?.map((e) => e) || [];
    message.maxAge = object.maxAge ?? "";
    message.allowCredentials = object.allowCredentials ?? false;
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseHttpRoute_RouteAction(): HttpRoute_RouteAction {
  return {
    destinations: [],
    redirect: undefined,
    faultInjectionPolicy: undefined,
    requestHeaderModifier: undefined,
    responseHeaderModifier: undefined,
    urlRewrite: undefined,
    timeout: undefined,
    retryPolicy: undefined,
    requestMirrorPolicy: undefined,
    corsPolicy: undefined,
  };
}

export const HttpRoute_RouteAction: MessageFns<HttpRoute_RouteAction> = {
  encode(message: HttpRoute_RouteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.destinations) {
      HttpRoute_Destination.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.redirect !== undefined) {
      HttpRoute_Redirect.encode(message.redirect, writer.uint32(18).fork()).join();
    }
    if (message.faultInjectionPolicy !== undefined) {
      HttpRoute_FaultInjectionPolicy.encode(message.faultInjectionPolicy, writer.uint32(34).fork()).join();
    }
    if (message.requestHeaderModifier !== undefined) {
      HttpRoute_HeaderModifier.encode(message.requestHeaderModifier, writer.uint32(42).fork()).join();
    }
    if (message.responseHeaderModifier !== undefined) {
      HttpRoute_HeaderModifier.encode(message.responseHeaderModifier, writer.uint32(50).fork()).join();
    }
    if (message.urlRewrite !== undefined) {
      HttpRoute_URLRewrite.encode(message.urlRewrite, writer.uint32(58).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(66).fork()).join();
    }
    if (message.retryPolicy !== undefined) {
      HttpRoute_RetryPolicy.encode(message.retryPolicy, writer.uint32(74).fork()).join();
    }
    if (message.requestMirrorPolicy !== undefined) {
      HttpRoute_RequestMirrorPolicy.encode(message.requestMirrorPolicy, writer.uint32(82).fork()).join();
    }
    if (message.corsPolicy !== undefined) {
      HttpRoute_CorsPolicy.encode(message.corsPolicy, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RouteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RouteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destinations.push(HttpRoute_Destination.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.redirect = HttpRoute_Redirect.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.faultInjectionPolicy = HttpRoute_FaultInjectionPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestHeaderModifier = HttpRoute_HeaderModifier.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.responseHeaderModifier = HttpRoute_HeaderModifier.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.urlRewrite = HttpRoute_URLRewrite.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.retryPolicy = HttpRoute_RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requestMirrorPolicy = HttpRoute_RequestMirrorPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.corsPolicy = HttpRoute_CorsPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RouteAction {
    return {
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => HttpRoute_Destination.fromJSON(e))
        : [],
      redirect: isSet(object.redirect) ? HttpRoute_Redirect.fromJSON(object.redirect) : undefined,
      faultInjectionPolicy: isSet(object.faultInjectionPolicy)
        ? HttpRoute_FaultInjectionPolicy.fromJSON(object.faultInjectionPolicy)
        : undefined,
      requestHeaderModifier: isSet(object.requestHeaderModifier)
        ? HttpRoute_HeaderModifier.fromJSON(object.requestHeaderModifier)
        : undefined,
      responseHeaderModifier: isSet(object.responseHeaderModifier)
        ? HttpRoute_HeaderModifier.fromJSON(object.responseHeaderModifier)
        : undefined,
      urlRewrite: isSet(object.urlRewrite) ? HttpRoute_URLRewrite.fromJSON(object.urlRewrite) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      retryPolicy: isSet(object.retryPolicy) ? HttpRoute_RetryPolicy.fromJSON(object.retryPolicy) : undefined,
      requestMirrorPolicy: isSet(object.requestMirrorPolicy)
        ? HttpRoute_RequestMirrorPolicy.fromJSON(object.requestMirrorPolicy)
        : undefined,
      corsPolicy: isSet(object.corsPolicy) ? HttpRoute_CorsPolicy.fromJSON(object.corsPolicy) : undefined,
    };
  },

  toJSON(message: HttpRoute_RouteAction): unknown {
    const obj: any = {};
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => HttpRoute_Destination.toJSON(e));
    }
    if (message.redirect !== undefined) {
      obj.redirect = HttpRoute_Redirect.toJSON(message.redirect);
    }
    if (message.faultInjectionPolicy !== undefined) {
      obj.faultInjectionPolicy = HttpRoute_FaultInjectionPolicy.toJSON(message.faultInjectionPolicy);
    }
    if (message.requestHeaderModifier !== undefined) {
      obj.requestHeaderModifier = HttpRoute_HeaderModifier.toJSON(message.requestHeaderModifier);
    }
    if (message.responseHeaderModifier !== undefined) {
      obj.responseHeaderModifier = HttpRoute_HeaderModifier.toJSON(message.responseHeaderModifier);
    }
    if (message.urlRewrite !== undefined) {
      obj.urlRewrite = HttpRoute_URLRewrite.toJSON(message.urlRewrite);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.retryPolicy !== undefined) {
      obj.retryPolicy = HttpRoute_RetryPolicy.toJSON(message.retryPolicy);
    }
    if (message.requestMirrorPolicy !== undefined) {
      obj.requestMirrorPolicy = HttpRoute_RequestMirrorPolicy.toJSON(message.requestMirrorPolicy);
    }
    if (message.corsPolicy !== undefined) {
      obj.corsPolicy = HttpRoute_CorsPolicy.toJSON(message.corsPolicy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_RouteAction>, I>>(base?: I): HttpRoute_RouteAction {
    return HttpRoute_RouteAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_RouteAction>, I>>(object: I): HttpRoute_RouteAction {
    const message = createBaseHttpRoute_RouteAction();
    message.destinations = object.destinations?.map((e) => HttpRoute_Destination.fromPartial(e)) || [];
    message.redirect = (object.redirect !== undefined && object.redirect !== null)
      ? HttpRoute_Redirect.fromPartial(object.redirect)
      : undefined;
    message.faultInjectionPolicy = (object.faultInjectionPolicy !== undefined && object.faultInjectionPolicy !== null)
      ? HttpRoute_FaultInjectionPolicy.fromPartial(object.faultInjectionPolicy)
      : undefined;
    message.requestHeaderModifier =
      (object.requestHeaderModifier !== undefined && object.requestHeaderModifier !== null)
        ? HttpRoute_HeaderModifier.fromPartial(object.requestHeaderModifier)
        : undefined;
    message.responseHeaderModifier =
      (object.responseHeaderModifier !== undefined && object.responseHeaderModifier !== null)
        ? HttpRoute_HeaderModifier.fromPartial(object.responseHeaderModifier)
        : undefined;
    message.urlRewrite = (object.urlRewrite !== undefined && object.urlRewrite !== null)
      ? HttpRoute_URLRewrite.fromPartial(object.urlRewrite)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.retryPolicy = (object.retryPolicy !== undefined && object.retryPolicy !== null)
      ? HttpRoute_RetryPolicy.fromPartial(object.retryPolicy)
      : undefined;
    message.requestMirrorPolicy = (object.requestMirrorPolicy !== undefined && object.requestMirrorPolicy !== null)
      ? HttpRoute_RequestMirrorPolicy.fromPartial(object.requestMirrorPolicy)
      : undefined;
    message.corsPolicy = (object.corsPolicy !== undefined && object.corsPolicy !== null)
      ? HttpRoute_CorsPolicy.fromPartial(object.corsPolicy)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_RouteRule(): HttpRoute_RouteRule {
  return { matches: [], action: undefined };
}

export const HttpRoute_RouteRule: MessageFns<HttpRoute_RouteRule> = {
  encode(message: HttpRoute_RouteRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      HttpRoute_RouteMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.action !== undefined) {
      HttpRoute_RouteAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RouteRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RouteRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(HttpRoute_RouteMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = HttpRoute_RouteAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RouteRule {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => HttpRoute_RouteMatch.fromJSON(e))
        : [],
      action: isSet(object.action) ? HttpRoute_RouteAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: HttpRoute_RouteRule): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => HttpRoute_RouteMatch.toJSON(e));
    }
    if (message.action !== undefined) {
      obj.action = HttpRoute_RouteAction.toJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_RouteRule>, I>>(base?: I): HttpRoute_RouteRule {
    return HttpRoute_RouteRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_RouteRule>, I>>(object: I): HttpRoute_RouteRule {
    const message = createBaseHttpRoute_RouteRule();
    message.matches = object.matches?.map((e) => HttpRoute_RouteMatch.fromPartial(e)) || [];
    message.action = (object.action !== undefined && object.action !== null)
      ? HttpRoute_RouteAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_LabelsEntry(): HttpRoute_LabelsEntry {
  return { key: "", value: "" };
}

export const HttpRoute_LabelsEntry: MessageFns<HttpRoute_LabelsEntry> = {
  encode(message: HttpRoute_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpRoute_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRoute_LabelsEntry>, I>>(base?: I): HttpRoute_LabelsEntry {
    return HttpRoute_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRoute_LabelsEntry>, I>>(object: I): HttpRoute_LabelsEntry {
    const message = createBaseHttpRoute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMesh(): Mesh {
  return {
    name: "",
    selfLink: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    interceptionPort: 0,
  };
}

export const Mesh: MessageFns<Mesh> = {
  encode(message: Mesh, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selfLink !== "") {
      writer.uint32(74).string(message.selfLink);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Mesh_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.interceptionPort !== 0) {
      writer.uint32(64).int32(message.interceptionPort);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mesh {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMesh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Mesh_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.interceptionPort = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mesh {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      interceptionPort: isSet(object.interceptionPort) ? globalThis.Number(object.interceptionPort) : 0,
    };
  },

  toJSON(message: Mesh): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.interceptionPort !== 0) {
      obj.interceptionPort = Math.round(message.interceptionPort);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mesh>, I>>(base?: I): Mesh {
    return Mesh.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mesh>, I>>(object: I): Mesh {
    const message = createBaseMesh();
    message.name = object.name ?? "";
    message.selfLink = object.selfLink ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.interceptionPort = object.interceptionPort ?? 0;
    return message;
  },
};

function createBaseMesh_LabelsEntry(): Mesh_LabelsEntry {
  return { key: "", value: "" };
}

export const Mesh_LabelsEntry: MessageFns<Mesh_LabelsEntry> = {
  encode(message: Mesh_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mesh_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMesh_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mesh_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Mesh_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mesh_LabelsEntry>, I>>(base?: I): Mesh_LabelsEntry {
    return Mesh_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mesh_LabelsEntry>, I>>(object: I): Mesh_LabelsEntry {
    const message = createBaseMesh_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServiceBinding(): ServiceBinding {
  return {
    name: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    service: "",
    serviceId: "",
    labels: {},
  };
}

export const ServiceBinding: MessageFns<ServiceBinding> = {
  encode(message: ServiceBinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.service !== "") {
      writer.uint32(42).string(message.service);
    }
    if (message.serviceId !== "") {
      writer.uint32(66).string(message.serviceId);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ServiceBinding_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceBinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = ServiceBinding_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceBinding {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      serviceId: isSet(object.serviceId) ? globalThis.String(object.serviceId) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ServiceBinding): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceBinding>, I>>(base?: I): ServiceBinding {
    return ServiceBinding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceBinding>, I>>(object: I): ServiceBinding {
    const message = createBaseServiceBinding();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.service = object.service ?? "";
    message.serviceId = object.serviceId ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseServiceBinding_LabelsEntry(): ServiceBinding_LabelsEntry {
  return { key: "", value: "" };
}

export const ServiceBinding_LabelsEntry: MessageFns<ServiceBinding_LabelsEntry> = {
  encode(message: ServiceBinding_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceBinding_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceBinding_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceBinding_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ServiceBinding_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceBinding_LabelsEntry>, I>>(base?: I): ServiceBinding_LabelsEntry {
    return ServiceBinding_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceBinding_LabelsEntry>, I>>(object: I): ServiceBinding_LabelsEntry {
    const message = createBaseServiceBinding_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTcpRoute(): TcpRoute {
  return {
    name: "",
    selfLink: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    rules: [],
    meshes: [],
    gateways: [],
    labels: {},
  };
}

export const TcpRoute: MessageFns<TcpRoute> = {
  encode(message: TcpRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selfLink !== "") {
      writer.uint32(90).string(message.selfLink);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.rules) {
      TcpRoute_RouteRule.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.meshes) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.gateways) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      TcpRoute_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rules.push(TcpRoute_RouteRule.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.meshes.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gateways.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = TcpRoute_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpRoute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => TcpRoute_RouteRule.fromJSON(e))
        : [],
      meshes: globalThis.Array.isArray(object?.meshes) ? object.meshes.map((e: any) => globalThis.String(e)) : [],
      gateways: globalThis.Array.isArray(object?.gateways) ? object.gateways.map((e: any) => globalThis.String(e)) : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TcpRoute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => TcpRoute_RouteRule.toJSON(e));
    }
    if (message.meshes?.length) {
      obj.meshes = message.meshes;
    }
    if (message.gateways?.length) {
      obj.gateways = message.gateways;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpRoute>, I>>(base?: I): TcpRoute {
    return TcpRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpRoute>, I>>(object: I): TcpRoute {
    const message = createBaseTcpRoute();
    message.name = object.name ?? "";
    message.selfLink = object.selfLink ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.rules = object.rules?.map((e) => TcpRoute_RouteRule.fromPartial(e)) || [];
    message.meshes = object.meshes?.map((e) => e) || [];
    message.gateways = object.gateways?.map((e) => e) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTcpRoute_RouteRule(): TcpRoute_RouteRule {
  return { matches: [], action: undefined };
}

export const TcpRoute_RouteRule: MessageFns<TcpRoute_RouteRule> = {
  encode(message: TcpRoute_RouteRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      TcpRoute_RouteMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.action !== undefined) {
      TcpRoute_RouteAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpRoute_RouteRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpRoute_RouteRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(TcpRoute_RouteMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = TcpRoute_RouteAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpRoute_RouteRule {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => TcpRoute_RouteMatch.fromJSON(e))
        : [],
      action: isSet(object.action) ? TcpRoute_RouteAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: TcpRoute_RouteRule): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => TcpRoute_RouteMatch.toJSON(e));
    }
    if (message.action !== undefined) {
      obj.action = TcpRoute_RouteAction.toJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpRoute_RouteRule>, I>>(base?: I): TcpRoute_RouteRule {
    return TcpRoute_RouteRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpRoute_RouteRule>, I>>(object: I): TcpRoute_RouteRule {
    const message = createBaseTcpRoute_RouteRule();
    message.matches = object.matches?.map((e) => TcpRoute_RouteMatch.fromPartial(e)) || [];
    message.action = (object.action !== undefined && object.action !== null)
      ? TcpRoute_RouteAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseTcpRoute_RouteMatch(): TcpRoute_RouteMatch {
  return { address: "", port: "" };
}

export const TcpRoute_RouteMatch: MessageFns<TcpRoute_RouteMatch> = {
  encode(message: TcpRoute_RouteMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.port !== "") {
      writer.uint32(18).string(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpRoute_RouteMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpRoute_RouteMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.port = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpRoute_RouteMatch {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
    };
  },

  toJSON(message: TcpRoute_RouteMatch): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpRoute_RouteMatch>, I>>(base?: I): TcpRoute_RouteMatch {
    return TcpRoute_RouteMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpRoute_RouteMatch>, I>>(object: I): TcpRoute_RouteMatch {
    const message = createBaseTcpRoute_RouteMatch();
    message.address = object.address ?? "";
    message.port = object.port ?? "";
    return message;
  },
};

function createBaseTcpRoute_RouteAction(): TcpRoute_RouteAction {
  return { destinations: [], originalDestination: false };
}

export const TcpRoute_RouteAction: MessageFns<TcpRoute_RouteAction> = {
  encode(message: TcpRoute_RouteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.destinations) {
      TcpRoute_RouteDestination.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.originalDestination !== false) {
      writer.uint32(24).bool(message.originalDestination);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpRoute_RouteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpRoute_RouteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destinations.push(TcpRoute_RouteDestination.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.originalDestination = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpRoute_RouteAction {
    return {
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => TcpRoute_RouteDestination.fromJSON(e))
        : [],
      originalDestination: isSet(object.originalDestination) ? globalThis.Boolean(object.originalDestination) : false,
    };
  },

  toJSON(message: TcpRoute_RouteAction): unknown {
    const obj: any = {};
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => TcpRoute_RouteDestination.toJSON(e));
    }
    if (message.originalDestination !== false) {
      obj.originalDestination = message.originalDestination;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpRoute_RouteAction>, I>>(base?: I): TcpRoute_RouteAction {
    return TcpRoute_RouteAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpRoute_RouteAction>, I>>(object: I): TcpRoute_RouteAction {
    const message = createBaseTcpRoute_RouteAction();
    message.destinations = object.destinations?.map((e) => TcpRoute_RouteDestination.fromPartial(e)) || [];
    message.originalDestination = object.originalDestination ?? false;
    return message;
  },
};

function createBaseTcpRoute_RouteDestination(): TcpRoute_RouteDestination {
  return { serviceName: "", weight: 0 };
}

export const TcpRoute_RouteDestination: MessageFns<TcpRoute_RouteDestination> = {
  encode(message: TcpRoute_RouteDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.weight !== 0) {
      writer.uint32(16).int32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpRoute_RouteDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpRoute_RouteDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpRoute_RouteDestination {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: TcpRoute_RouteDestination): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpRoute_RouteDestination>, I>>(base?: I): TcpRoute_RouteDestination {
    return TcpRoute_RouteDestination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpRoute_RouteDestination>, I>>(object: I): TcpRoute_RouteDestination {
    const message = createBaseTcpRoute_RouteDestination();
    message.serviceName = object.serviceName ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseTcpRoute_LabelsEntry(): TcpRoute_LabelsEntry {
  return { key: "", value: "" };
}

export const TcpRoute_LabelsEntry: MessageFns<TcpRoute_LabelsEntry> = {
  encode(message: TcpRoute_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpRoute_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpRoute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpRoute_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TcpRoute_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpRoute_LabelsEntry>, I>>(base?: I): TcpRoute_LabelsEntry {
    return TcpRoute_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpRoute_LabelsEntry>, I>>(object: I): TcpRoute_LabelsEntry {
    const message = createBaseTcpRoute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTlsRoute(): TlsRoute {
  return {
    name: "",
    selfLink: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    rules: [],
    meshes: [],
    gateways: [],
  };
}

export const TlsRoute: MessageFns<TlsRoute> = {
  encode(message: TlsRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selfLink !== "") {
      writer.uint32(66).string(message.selfLink);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.rules) {
      TlsRoute_RouteRule.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.meshes) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.gateways) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rules.push(TlsRoute_RouteRule.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.meshes.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gateways.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsRoute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => TlsRoute_RouteRule.fromJSON(e))
        : [],
      meshes: globalThis.Array.isArray(object?.meshes) ? object.meshes.map((e: any) => globalThis.String(e)) : [],
      gateways: globalThis.Array.isArray(object?.gateways) ? object.gateways.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TlsRoute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => TlsRoute_RouteRule.toJSON(e));
    }
    if (message.meshes?.length) {
      obj.meshes = message.meshes;
    }
    if (message.gateways?.length) {
      obj.gateways = message.gateways;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsRoute>, I>>(base?: I): TlsRoute {
    return TlsRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsRoute>, I>>(object: I): TlsRoute {
    const message = createBaseTlsRoute();
    message.name = object.name ?? "";
    message.selfLink = object.selfLink ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.rules = object.rules?.map((e) => TlsRoute_RouteRule.fromPartial(e)) || [];
    message.meshes = object.meshes?.map((e) => e) || [];
    message.gateways = object.gateways?.map((e) => e) || [];
    return message;
  },
};

function createBaseTlsRoute_RouteRule(): TlsRoute_RouteRule {
  return { matches: [], action: undefined };
}

export const TlsRoute_RouteRule: MessageFns<TlsRoute_RouteRule> = {
  encode(message: TlsRoute_RouteRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      TlsRoute_RouteMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.action !== undefined) {
      TlsRoute_RouteAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsRoute_RouteRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsRoute_RouteRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(TlsRoute_RouteMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = TlsRoute_RouteAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsRoute_RouteRule {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => TlsRoute_RouteMatch.fromJSON(e))
        : [],
      action: isSet(object.action) ? TlsRoute_RouteAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: TlsRoute_RouteRule): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => TlsRoute_RouteMatch.toJSON(e));
    }
    if (message.action !== undefined) {
      obj.action = TlsRoute_RouteAction.toJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsRoute_RouteRule>, I>>(base?: I): TlsRoute_RouteRule {
    return TlsRoute_RouteRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsRoute_RouteRule>, I>>(object: I): TlsRoute_RouteRule {
    const message = createBaseTlsRoute_RouteRule();
    message.matches = object.matches?.map((e) => TlsRoute_RouteMatch.fromPartial(e)) || [];
    message.action = (object.action !== undefined && object.action !== null)
      ? TlsRoute_RouteAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseTlsRoute_RouteMatch(): TlsRoute_RouteMatch {
  return { sniHost: [], alpn: [] };
}

export const TlsRoute_RouteMatch: MessageFns<TlsRoute_RouteMatch> = {
  encode(message: TlsRoute_RouteMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sniHost) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.alpn) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsRoute_RouteMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsRoute_RouteMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sniHost.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alpn.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsRoute_RouteMatch {
    return {
      sniHost: globalThis.Array.isArray(object?.sniHost) ? object.sniHost.map((e: any) => globalThis.String(e)) : [],
      alpn: globalThis.Array.isArray(object?.alpn) ? object.alpn.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TlsRoute_RouteMatch): unknown {
    const obj: any = {};
    if (message.sniHost?.length) {
      obj.sniHost = message.sniHost;
    }
    if (message.alpn?.length) {
      obj.alpn = message.alpn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsRoute_RouteMatch>, I>>(base?: I): TlsRoute_RouteMatch {
    return TlsRoute_RouteMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsRoute_RouteMatch>, I>>(object: I): TlsRoute_RouteMatch {
    const message = createBaseTlsRoute_RouteMatch();
    message.sniHost = object.sniHost?.map((e) => e) || [];
    message.alpn = object.alpn?.map((e) => e) || [];
    return message;
  },
};

function createBaseTlsRoute_RouteAction(): TlsRoute_RouteAction {
  return { destinations: [] };
}

export const TlsRoute_RouteAction: MessageFns<TlsRoute_RouteAction> = {
  encode(message: TlsRoute_RouteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.destinations) {
      TlsRoute_RouteDestination.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsRoute_RouteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsRoute_RouteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destinations.push(TlsRoute_RouteDestination.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsRoute_RouteAction {
    return {
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => TlsRoute_RouteDestination.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TlsRoute_RouteAction): unknown {
    const obj: any = {};
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => TlsRoute_RouteDestination.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsRoute_RouteAction>, I>>(base?: I): TlsRoute_RouteAction {
    return TlsRoute_RouteAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsRoute_RouteAction>, I>>(object: I): TlsRoute_RouteAction {
    const message = createBaseTlsRoute_RouteAction();
    message.destinations = object.destinations?.map((e) => TlsRoute_RouteDestination.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTlsRoute_RouteDestination(): TlsRoute_RouteDestination {
  return { serviceName: "", weight: 0 };
}

export const TlsRoute_RouteDestination: MessageFns<TlsRoute_RouteDestination> = {
  encode(message: TlsRoute_RouteDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.weight !== 0) {
      writer.uint32(16).int32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsRoute_RouteDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsRoute_RouteDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsRoute_RouteDestination {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: TlsRoute_RouteDestination): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsRoute_RouteDestination>, I>>(base?: I): TlsRoute_RouteDestination {
    return TlsRoute_RouteDestination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsRoute_RouteDestination>, I>>(object: I): TlsRoute_RouteDestination {
    const message = createBaseTlsRoute_RouteDestination();
    message.serviceName = object.serviceName ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseEndpointPolicyEventData(): EndpointPolicyEventData {
  return { payload: undefined };
}

export const EndpointPolicyEventData: MessageFns<EndpointPolicyEventData> = {
  encode(message: EndpointPolicyEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      EndpointPolicy.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointPolicyEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointPolicyEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = EndpointPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointPolicyEventData {
    return { payload: isSet(object.payload) ? EndpointPolicy.fromJSON(object.payload) : undefined };
  },

  toJSON(message: EndpointPolicyEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = EndpointPolicy.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointPolicyEventData>, I>>(base?: I): EndpointPolicyEventData {
    return EndpointPolicyEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointPolicyEventData>, I>>(object: I): EndpointPolicyEventData {
    const message = createBaseEndpointPolicyEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? EndpointPolicy.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseHttpRouteEventData(): HttpRouteEventData {
  return { payload: undefined };
}

export const HttpRouteEventData: MessageFns<HttpRouteEventData> = {
  encode(message: HttpRouteEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      HttpRoute.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRouteEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRouteEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = HttpRoute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRouteEventData {
    return { payload: isSet(object.payload) ? HttpRoute.fromJSON(object.payload) : undefined };
  },

  toJSON(message: HttpRouteEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = HttpRoute.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRouteEventData>, I>>(base?: I): HttpRouteEventData {
    return HttpRouteEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRouteEventData>, I>>(object: I): HttpRouteEventData {
    const message = createBaseHttpRouteEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? HttpRoute.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseServiceBindingEventData(): ServiceBindingEventData {
  return { payload: undefined };
}

export const ServiceBindingEventData: MessageFns<ServiceBindingEventData> = {
  encode(message: ServiceBindingEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      ServiceBinding.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceBindingEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceBindingEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = ServiceBinding.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceBindingEventData {
    return { payload: isSet(object.payload) ? ServiceBinding.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ServiceBindingEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ServiceBinding.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceBindingEventData>, I>>(base?: I): ServiceBindingEventData {
    return ServiceBindingEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceBindingEventData>, I>>(object: I): ServiceBindingEventData {
    const message = createBaseServiceBindingEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ServiceBinding.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseGatewayEventData(): GatewayEventData {
  return { payload: undefined };
}

export const GatewayEventData: MessageFns<GatewayEventData> = {
  encode(message: GatewayEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Gateway.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GatewayEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatewayEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Gateway.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatewayEventData {
    return { payload: isSet(object.payload) ? Gateway.fromJSON(object.payload) : undefined };
  },

  toJSON(message: GatewayEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Gateway.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GatewayEventData>, I>>(base?: I): GatewayEventData {
    return GatewayEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GatewayEventData>, I>>(object: I): GatewayEventData {
    const message = createBaseGatewayEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Gateway.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseTlsRouteEventData(): TlsRouteEventData {
  return { payload: undefined };
}

export const TlsRouteEventData: MessageFns<TlsRouteEventData> = {
  encode(message: TlsRouteEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      TlsRoute.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsRouteEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsRouteEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = TlsRoute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsRouteEventData {
    return { payload: isSet(object.payload) ? TlsRoute.fromJSON(object.payload) : undefined };
  },

  toJSON(message: TlsRouteEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = TlsRoute.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsRouteEventData>, I>>(base?: I): TlsRouteEventData {
    return TlsRouteEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsRouteEventData>, I>>(object: I): TlsRouteEventData {
    const message = createBaseTlsRouteEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? TlsRoute.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseGrpcRouteEventData(): GrpcRouteEventData {
  return { payload: undefined };
}

export const GrpcRouteEventData: MessageFns<GrpcRouteEventData> = {
  encode(message: GrpcRouteEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      GrpcRoute.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRouteEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRouteEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = GrpcRoute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRouteEventData {
    return { payload: isSet(object.payload) ? GrpcRoute.fromJSON(object.payload) : undefined };
  },

  toJSON(message: GrpcRouteEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = GrpcRoute.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcRouteEventData>, I>>(base?: I): GrpcRouteEventData {
    return GrpcRouteEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcRouteEventData>, I>>(object: I): GrpcRouteEventData {
    const message = createBaseGrpcRouteEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? GrpcRoute.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseMeshEventData(): MeshEventData {
  return { payload: undefined };
}

export const MeshEventData: MessageFns<MeshEventData> = {
  encode(message: MeshEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Mesh.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MeshEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeshEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Mesh.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MeshEventData {
    return { payload: isSet(object.payload) ? Mesh.fromJSON(object.payload) : undefined };
  },

  toJSON(message: MeshEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Mesh.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MeshEventData>, I>>(base?: I): MeshEventData {
    return MeshEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MeshEventData>, I>>(object: I): MeshEventData {
    const message = createBaseMeshEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Mesh.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseTcpRouteEventData(): TcpRouteEventData {
  return { payload: undefined };
}

export const TcpRouteEventData: MessageFns<TcpRouteEventData> = {
  encode(message: TcpRouteEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      TcpRoute.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpRouteEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpRouteEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = TcpRoute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpRouteEventData {
    return { payload: isSet(object.payload) ? TcpRoute.fromJSON(object.payload) : undefined };
  },

  toJSON(message: TcpRouteEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = TcpRoute.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpRouteEventData>, I>>(base?: I): TcpRouteEventData {
    return TcpRouteEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpRouteEventData>, I>>(object: I): TcpRouteEventData {
    const message = createBaseTcpRouteEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? TcpRoute.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
