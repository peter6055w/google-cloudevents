// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/notebooks/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";

export const protobufPackage = "google.events.cloud.notebooks.v1";

/**
 * Definition of a software environment that is used to start a notebook
 * instance.
 */
export interface Environment {
  /**
   * Output only. Name of this environment.
   * Format:
   * `projects/{project_id}/locations/{location}/environments/{environment_id}`
   */
  name: string;
  /** Display name of this environment for the UI. */
  displayName: string;
  /** A brief description of this environment. */
  description: string;
  /** Use a Compute Engine VM image to start the notebook instance. */
  vmImage?:
    | VmImage
    | undefined;
  /** Use a container image to start the notebook instance. */
  containerImage?:
    | ContainerImage
    | undefined;
  /**
   * Path to a Bash script that automatically runs after a notebook instance
   * fully boots up. The path must be a URL or
   * Cloud Storage path. Example: `"gs://path-to-file/file-name"`
   */
  postStartupScript: string;
  /** Output only. The time at which this environment was created. */
  createTime?: Date | undefined;
}

/**
 * Definition of a custom Compute Engine virtual machine image for starting a
 * notebook instance with the environment installed directly on the VM.
 */
export interface VmImage {
  /**
   * Required. The name of the Google Cloud project that this VM image belongs
   * to. Format: `{project_id}`
   */
  project: string;
  /** Use VM image name to find the image. */
  imageName?:
    | string
    | undefined;
  /**
   * Use this VM image family to find the image; the newest image in this
   * family will be used.
   */
  imageFamily?: string | undefined;
}

/**
 * Definition of a container image for starting a notebook instance with the
 * environment installed in a container.
 */
export interface ContainerImage {
  /**
   * Required. The path to the container image repository. For example:
   * `gcr.io/{project_id}/{image_name}`
   */
  repository: string;
  /**
   * The tag of the container image. If not specified, this defaults
   * to the latest tag.
   */
  tag: string;
}

/** The definition of a Runtime for a managed notebook instance. */
export interface Runtime {
  /**
   * Output only. The resource name of the runtime.
   * Format:
   * `projects/{project}/locations/{location}/runtimes/{runtimeId}`
   */
  name: string;
  /** Use a Compute Engine VM image to start the managed notebook instance. */
  virtualMachine?:
    | VirtualMachine
    | undefined;
  /** Output only. Runtime state. */
  state: Runtime_State;
  /** Output only. Runtime health_state. */
  healthState: Runtime_HealthState;
  /** The config settings for accessing runtime. */
  accessConfig?:
    | RuntimeAccessConfig
    | undefined;
  /** The config settings for software inside the runtime. */
  softwareConfig?:
    | RuntimeSoftwareConfig
    | undefined;
  /**
   * Output only. Contains Runtime daemon metrics such as Service status and
   * JupyterLab stats.
   */
  metrics?:
    | RuntimeMetrics
    | undefined;
  /** Output only. Runtime creation time. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Runtime update time. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. The labels to associate with this Managed Notebook or Runtime.
   * Label **keys** must contain 1 to 63 characters, and must conform to
   * [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
   * Label **values** may be empty, but, if present, must contain 1 to 63
   * characters, and must conform to [RFC
   * 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
   * associated with a cluster.
   */
  labels: { [key: string]: string };
}

/** The definition of the states of this runtime. */
export enum Runtime_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTING - The compute layer is starting the runtime. It is not ready for use. */
  STARTING = 1,
  /**
   * PROVISIONING - The compute layer is installing required frameworks and registering the
   * runtime with notebook proxy. It cannot be used.
   */
  PROVISIONING = 2,
  /** ACTIVE - The runtime is currently running. It is ready for use. */
  ACTIVE = 3,
  /** STOPPING - The control logic is stopping the runtime. It cannot be used. */
  STOPPING = 4,
  /** STOPPED - The runtime is stopped. It cannot be used. */
  STOPPED = 5,
  /** DELETING - The runtime is being deleted. It cannot be used. */
  DELETING = 6,
  /** UPGRADING - The runtime is upgrading. It cannot be used. */
  UPGRADING = 7,
  /** INITIALIZING - The runtime is being created and set up. It is not ready for use. */
  INITIALIZING = 8,
  UNRECOGNIZED = -1,
}

export function runtime_StateFromJSON(object: any): Runtime_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Runtime_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTING":
      return Runtime_State.STARTING;
    case 2:
    case "PROVISIONING":
      return Runtime_State.PROVISIONING;
    case 3:
    case "ACTIVE":
      return Runtime_State.ACTIVE;
    case 4:
    case "STOPPING":
      return Runtime_State.STOPPING;
    case 5:
    case "STOPPED":
      return Runtime_State.STOPPED;
    case 6:
    case "DELETING":
      return Runtime_State.DELETING;
    case 7:
    case "UPGRADING":
      return Runtime_State.UPGRADING;
    case 8:
    case "INITIALIZING":
      return Runtime_State.INITIALIZING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Runtime_State.UNRECOGNIZED;
  }
}

export function runtime_StateToJSON(object: Runtime_State): string {
  switch (object) {
    case Runtime_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Runtime_State.STARTING:
      return "STARTING";
    case Runtime_State.PROVISIONING:
      return "PROVISIONING";
    case Runtime_State.ACTIVE:
      return "ACTIVE";
    case Runtime_State.STOPPING:
      return "STOPPING";
    case Runtime_State.STOPPED:
      return "STOPPED";
    case Runtime_State.DELETING:
      return "DELETING";
    case Runtime_State.UPGRADING:
      return "UPGRADING";
    case Runtime_State.INITIALIZING:
      return "INITIALIZING";
    case Runtime_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The runtime substate. */
export enum Runtime_HealthState {
  /** HEALTH_STATE_UNSPECIFIED - The runtime substate is unknown. */
  HEALTH_STATE_UNSPECIFIED = 0,
  /**
   * HEALTHY - The runtime is known to be in an healthy state
   * (for example, critical daemons are running)
   * Applies to ACTIVE state.
   */
  HEALTHY = 1,
  /**
   * UNHEALTHY - The runtime is known to be in an unhealthy state
   * (for example, critical daemons are not running)
   * Applies to ACTIVE state.
   */
  UNHEALTHY = 2,
  /**
   * AGENT_NOT_INSTALLED - The runtime has not installed health monitoring agent.
   * Applies to ACTIVE state.
   */
  AGENT_NOT_INSTALLED = 3,
  /**
   * AGENT_NOT_RUNNING - The runtime health monitoring agent is not running.
   * Applies to ACTIVE state.
   */
  AGENT_NOT_RUNNING = 4,
  UNRECOGNIZED = -1,
}

export function runtime_HealthStateFromJSON(object: any): Runtime_HealthState {
  switch (object) {
    case 0:
    case "HEALTH_STATE_UNSPECIFIED":
      return Runtime_HealthState.HEALTH_STATE_UNSPECIFIED;
    case 1:
    case "HEALTHY":
      return Runtime_HealthState.HEALTHY;
    case 2:
    case "UNHEALTHY":
      return Runtime_HealthState.UNHEALTHY;
    case 3:
    case "AGENT_NOT_INSTALLED":
      return Runtime_HealthState.AGENT_NOT_INSTALLED;
    case 4:
    case "AGENT_NOT_RUNNING":
      return Runtime_HealthState.AGENT_NOT_RUNNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Runtime_HealthState.UNRECOGNIZED;
  }
}

export function runtime_HealthStateToJSON(object: Runtime_HealthState): string {
  switch (object) {
    case Runtime_HealthState.HEALTH_STATE_UNSPECIFIED:
      return "HEALTH_STATE_UNSPECIFIED";
    case Runtime_HealthState.HEALTHY:
      return "HEALTHY";
    case Runtime_HealthState.UNHEALTHY:
      return "UNHEALTHY";
    case Runtime_HealthState.AGENT_NOT_INSTALLED:
      return "AGENT_NOT_INSTALLED";
    case Runtime_HealthState.AGENT_NOT_RUNNING:
      return "AGENT_NOT_RUNNING";
    case Runtime_HealthState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Runtime_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Definition of the types of hardware accelerators that can be used.
 * Definition of the types of hardware accelerators that can be used.
 * See [Compute Engine
 * AcceleratorTypes](https://cloud.google.com/compute/docs/reference/beta/acceleratorTypes).
 * Examples:
 *
 * * `nvidia-tesla-k80`
 * * `nvidia-tesla-p100`
 * * `nvidia-tesla-v100`
 * * `nvidia-tesla-p4`
 * * `nvidia-tesla-t4`
 * * `nvidia-tesla-a100`
 */
export interface RuntimeAcceleratorConfig {
  /** Accelerator model. */
  type: RuntimeAcceleratorConfig_AcceleratorType;
  /** Count of cores of this accelerator. */
  coreCount: Long;
}

/** Type of this accelerator. */
export enum RuntimeAcceleratorConfig_AcceleratorType {
  /** ACCELERATOR_TYPE_UNSPECIFIED - Accelerator type is not specified. */
  ACCELERATOR_TYPE_UNSPECIFIED = 0,
  /** NVIDIA_TESLA_K80 - Accelerator type is Nvidia Tesla K80. */
  NVIDIA_TESLA_K80 = 1,
  /** NVIDIA_TESLA_P100 - Accelerator type is Nvidia Tesla P100. */
  NVIDIA_TESLA_P100 = 2,
  /** NVIDIA_TESLA_V100 - Accelerator type is Nvidia Tesla V100. */
  NVIDIA_TESLA_V100 = 3,
  /** NVIDIA_TESLA_P4 - Accelerator type is Nvidia Tesla P4. */
  NVIDIA_TESLA_P4 = 4,
  /** NVIDIA_TESLA_T4 - Accelerator type is Nvidia Tesla T4. */
  NVIDIA_TESLA_T4 = 5,
  /** NVIDIA_TESLA_A100 - Accelerator type is Nvidia Tesla A100 - 40GB. */
  NVIDIA_TESLA_A100 = 6,
  /** TPU_V2 - (Coming soon) Accelerator type is TPU V2. */
  TPU_V2 = 7,
  /** TPU_V3 - (Coming soon) Accelerator type is TPU V3. */
  TPU_V3 = 8,
  /** NVIDIA_TESLA_T4_VWS - Accelerator type is NVIDIA Tesla T4 Virtual Workstations. */
  NVIDIA_TESLA_T4_VWS = 9,
  /** NVIDIA_TESLA_P100_VWS - Accelerator type is NVIDIA Tesla P100 Virtual Workstations. */
  NVIDIA_TESLA_P100_VWS = 10,
  /** NVIDIA_TESLA_P4_VWS - Accelerator type is NVIDIA Tesla P4 Virtual Workstations. */
  NVIDIA_TESLA_P4_VWS = 11,
  UNRECOGNIZED = -1,
}

export function runtimeAcceleratorConfig_AcceleratorTypeFromJSON(
  object: any,
): RuntimeAcceleratorConfig_AcceleratorType {
  switch (object) {
    case 0:
    case "ACCELERATOR_TYPE_UNSPECIFIED":
      return RuntimeAcceleratorConfig_AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED;
    case 1:
    case "NVIDIA_TESLA_K80":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_K80;
    case 2:
    case "NVIDIA_TESLA_P100":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P100;
    case 3:
    case "NVIDIA_TESLA_V100":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_V100;
    case 4:
    case "NVIDIA_TESLA_P4":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P4;
    case 5:
    case "NVIDIA_TESLA_T4":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_T4;
    case 6:
    case "NVIDIA_TESLA_A100":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_A100;
    case 7:
    case "TPU_V2":
      return RuntimeAcceleratorConfig_AcceleratorType.TPU_V2;
    case 8:
    case "TPU_V3":
      return RuntimeAcceleratorConfig_AcceleratorType.TPU_V3;
    case 9:
    case "NVIDIA_TESLA_T4_VWS":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_T4_VWS;
    case 10:
    case "NVIDIA_TESLA_P100_VWS":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P100_VWS;
    case 11:
    case "NVIDIA_TESLA_P4_VWS":
      return RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P4_VWS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuntimeAcceleratorConfig_AcceleratorType.UNRECOGNIZED;
  }
}

export function runtimeAcceleratorConfig_AcceleratorTypeToJSON(
  object: RuntimeAcceleratorConfig_AcceleratorType,
): string {
  switch (object) {
    case RuntimeAcceleratorConfig_AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED:
      return "ACCELERATOR_TYPE_UNSPECIFIED";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_K80:
      return "NVIDIA_TESLA_K80";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P100:
      return "NVIDIA_TESLA_P100";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_V100:
      return "NVIDIA_TESLA_V100";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P4:
      return "NVIDIA_TESLA_P4";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_T4:
      return "NVIDIA_TESLA_T4";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_A100:
      return "NVIDIA_TESLA_A100";
    case RuntimeAcceleratorConfig_AcceleratorType.TPU_V2:
      return "TPU_V2";
    case RuntimeAcceleratorConfig_AcceleratorType.TPU_V3:
      return "TPU_V3";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_T4_VWS:
      return "NVIDIA_TESLA_T4_VWS";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P100_VWS:
      return "NVIDIA_TESLA_P100_VWS";
    case RuntimeAcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P4_VWS:
      return "NVIDIA_TESLA_P4_VWS";
    case RuntimeAcceleratorConfig_AcceleratorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a custom encryption key configuration that can be applied to
 * a resource. This will encrypt all disks in Virtual Machine.
 */
export interface EncryptionConfig {
  /**
   * The Cloud KMS resource identifier of the customer-managed encryption key
   * used to protect a resource, such as a disks. It has the following
   * format:
   * `projects/{PROJECT_ID}/locations/{REGION}/keyRings/{KEY_RING_NAME}/cryptoKeys/{KEY_NAME}`
   */
  kmsKey: string;
}

/** A Local attached disk resource. */
export interface LocalDisk {
  /**
   * Optional. Output only. Specifies whether the disk will be auto-deleted when
   * the instance is deleted (but not when the disk is detached from the
   * instance).
   */
  autoDelete: boolean;
  /**
   * Optional. Output only. Indicates that this is a boot disk. The virtual
   * machine will use the first partition of the disk for its root filesystem.
   */
  boot: boolean;
  /**
   * Optional. Output only. Specifies a unique device name
   * of your choice that is reflected into the
   * `/dev/disk/by-id/google-*` tree of a Linux operating system running within
   * the instance. This name can be used to reference the device for mounting,
   * resizing, and so on, from within the instance.
   *
   * If not specified, the server chooses a default device name to apply to this
   * disk, in the form persistent-disk-x, where x is a number assigned by Google
   * Compute Engine. This field is only applicable for persistent disks.
   */
  deviceName: string;
  /**
   * Output only. Indicates a list of features to enable on the guest operating
   * system. Applicable only for bootable images. Read  Enabling guest operating
   * system features to see a list of available options.
   */
  guestOsFeatures: LocalDisk_RuntimeGuestOsFeature[];
  /**
   * Output only. A zero-based index to this disk, where 0 is reserved for the
   * boot disk. If you have many disks attached to an instance, each disk would
   * have a unique index number.
   */
  index: number;
  /**
   * Specifies the disk interface to use for attaching this disk, which is
   * either SCSI or NVME. The default is SCSI. Persistent disks must always use
   * SCSI and the request will fail if you attempt to attach a persistent disk
   * in any other format than SCSI. Local SSDs can use either NVME or SCSI. For
   * performance characteristics of SCSI over NVMe, see Local SSD performance.
   * Valid values:
   *
   * * `NVME`
   * * `SCSI`
   */
  interface: string;
  /**
   * Output only. Type of the resource. Always compute#attachedDisk for attached
   * disks.
   */
  kind: string;
  /** Output only. Any valid publicly visible licenses. */
  licenses: string[];
  /**
   * The mode in which to attach this disk, either `READ_WRITE` or `READ_ONLY`.
   * If not specified, the default is to attach the disk in `READ_WRITE` mode.
   * Valid values:
   *
   * * `READ_ONLY`
   * * `READ_WRITE`
   */
  mode: string;
  /**
   * Specifies a valid partial or full URL to an existing Persistent Disk
   * resource.
   */
  source: string;
  /**
   * Specifies the type of the disk, either `SCRATCH` or `PERSISTENT`. If not
   * specified, the default is `PERSISTENT`.
   * Valid values:
   *
   * * `PERSISTENT`
   * * `SCRATCH`
   */
  type: string;
}

/**
 * Optional. A list of features to enable on the guest operating system.
 * Applicable only for bootable images.
 * Read [Enabling guest operating system
 * features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features)
 * to see a list of available options.
 * Guest OS features for boot disk.
 */
export interface LocalDisk_RuntimeGuestOsFeature {
  /**
   * The ID of a supported feature. Read [Enabling guest operating system
   * features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features)
   * to see a list of available options.
   *
   * Valid values:
   *
   * * `FEATURE_TYPE_UNSPECIFIED`
   * * `MULTI_IP_SUBNET`
   * * `SECURE_BOOT`
   * * `UEFI_COMPATIBLE`
   * * `VIRTIO_SCSI_MULTIQUEUE`
   * * `WINDOWS`
   */
  type: string;
}

/**
 * Input only. Specifies the parameters for a new disk that will be created
 * alongside the new instance. Use initialization parameters to create boot
 * disks or local SSDs attached to the new runtime.
 * This property is mutually exclusive with the source property; you can only
 * define one or the other, but not both.
 */
export interface LocalDiskInitializeParams {
  /** Optional. Provide this property when creating the disk. */
  description: string;
  /**
   * Optional. Specifies the disk name. If not specified, the default is to use
   * the name of the instance. If the disk with the instance name exists already
   * in the given zone/region, a new name will be automatically generated.
   */
  diskName: string;
  /**
   * Optional. Specifies the size of the disk in base-2 GB. If not specified,
   * the disk will be the same size as the image (usually 10GB). If specified,
   * the size must be equal to or larger than 10GB. Default 100 GB.
   */
  diskSizeGb: Long;
  /**
   * Optional. Labels to apply to this disk. These can be later modified by the
   * disks.setLabels method. This field is only applicable for persistent disks.
   */
  labels: { [key: string]: string };
}

/** Possible disk types. */
export enum LocalDiskInitializeParams_DiskType {
  /** DISK_TYPE_UNSPECIFIED - Disk type not set. */
  DISK_TYPE_UNSPECIFIED = 0,
  /** PD_STANDARD - Standard persistent disk type. */
  PD_STANDARD = 1,
  /** PD_SSD - SSD persistent disk type. */
  PD_SSD = 2,
  /** PD_BALANCED - Balanced persistent disk type. */
  PD_BALANCED = 3,
  /** PD_EXTREME - Extreme persistent disk type. */
  PD_EXTREME = 4,
  UNRECOGNIZED = -1,
}

export function localDiskInitializeParams_DiskTypeFromJSON(object: any): LocalDiskInitializeParams_DiskType {
  switch (object) {
    case 0:
    case "DISK_TYPE_UNSPECIFIED":
      return LocalDiskInitializeParams_DiskType.DISK_TYPE_UNSPECIFIED;
    case 1:
    case "PD_STANDARD":
      return LocalDiskInitializeParams_DiskType.PD_STANDARD;
    case 2:
    case "PD_SSD":
      return LocalDiskInitializeParams_DiskType.PD_SSD;
    case 3:
    case "PD_BALANCED":
      return LocalDiskInitializeParams_DiskType.PD_BALANCED;
    case 4:
    case "PD_EXTREME":
      return LocalDiskInitializeParams_DiskType.PD_EXTREME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LocalDiskInitializeParams_DiskType.UNRECOGNIZED;
  }
}

export function localDiskInitializeParams_DiskTypeToJSON(object: LocalDiskInitializeParams_DiskType): string {
  switch (object) {
    case LocalDiskInitializeParams_DiskType.DISK_TYPE_UNSPECIFIED:
      return "DISK_TYPE_UNSPECIFIED";
    case LocalDiskInitializeParams_DiskType.PD_STANDARD:
      return "PD_STANDARD";
    case LocalDiskInitializeParams_DiskType.PD_SSD:
      return "PD_SSD";
    case LocalDiskInitializeParams_DiskType.PD_BALANCED:
      return "PD_BALANCED";
    case LocalDiskInitializeParams_DiskType.PD_EXTREME:
      return "PD_EXTREME";
    case LocalDiskInitializeParams_DiskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LocalDiskInitializeParams_LabelsEntry {
  key: string;
  value: string;
}

/** Specifies the login configuration for Runtime */
export interface RuntimeAccessConfig {
  /** The type of access mode this instance. */
  accessType: RuntimeAccessConfig_RuntimeAccessType;
  /**
   * The owner of this runtime after creation. Format: `alias@example.com`
   * Currently supports one owner only.
   */
  runtimeOwner: string;
  /** Output only. The proxy endpoint that is used to access the runtime. */
  proxyUri: string;
}

/**
 * Possible ways to access runtime. Authentication mode.
 * Currently supports: Single User only.
 */
export enum RuntimeAccessConfig_RuntimeAccessType {
  /** RUNTIME_ACCESS_TYPE_UNSPECIFIED - Unspecified access. */
  RUNTIME_ACCESS_TYPE_UNSPECIFIED = 0,
  /** SINGLE_USER - Single user login. */
  SINGLE_USER = 1,
  /**
   * SERVICE_ACCOUNT - Service Account mode.
   * In Service Account mode, Runtime creator will specify a SA that exists
   * in the consumer project. Using Runtime Service Account field.
   * Users accessing the Runtime need ActAs (Service Account User) permission.
   */
  SERVICE_ACCOUNT = 2,
  UNRECOGNIZED = -1,
}

export function runtimeAccessConfig_RuntimeAccessTypeFromJSON(object: any): RuntimeAccessConfig_RuntimeAccessType {
  switch (object) {
    case 0:
    case "RUNTIME_ACCESS_TYPE_UNSPECIFIED":
      return RuntimeAccessConfig_RuntimeAccessType.RUNTIME_ACCESS_TYPE_UNSPECIFIED;
    case 1:
    case "SINGLE_USER":
      return RuntimeAccessConfig_RuntimeAccessType.SINGLE_USER;
    case 2:
    case "SERVICE_ACCOUNT":
      return RuntimeAccessConfig_RuntimeAccessType.SERVICE_ACCOUNT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuntimeAccessConfig_RuntimeAccessType.UNRECOGNIZED;
  }
}

export function runtimeAccessConfig_RuntimeAccessTypeToJSON(object: RuntimeAccessConfig_RuntimeAccessType): string {
  switch (object) {
    case RuntimeAccessConfig_RuntimeAccessType.RUNTIME_ACCESS_TYPE_UNSPECIFIED:
      return "RUNTIME_ACCESS_TYPE_UNSPECIFIED";
    case RuntimeAccessConfig_RuntimeAccessType.SINGLE_USER:
      return "SINGLE_USER";
    case RuntimeAccessConfig_RuntimeAccessType.SERVICE_ACCOUNT:
      return "SERVICE_ACCOUNT";
    case RuntimeAccessConfig_RuntimeAccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies the selection and configuration of software inside the runtime.
 * The properties to set on runtime.
 * Properties keys are specified in `key:value` format, for example:
 *
 * * `idle_shutdown: true`
 * * `idle_shutdown_timeout: 180`
 * * `enable_health_monitoring: true`
 */
export interface RuntimeSoftwareConfig {
  /**
   * Cron expression in UTC timezone, used to schedule instance auto upgrade.
   * Please follow the [cron format](https://en.wikipedia.org/wiki/Cron).
   */
  notebookUpgradeSchedule: string;
  /**
   * Verifies core internal services are running.
   * Default: True
   */
  enableHealthMonitoring?:
    | boolean
    | undefined;
  /**
   * Runtime will automatically shutdown after idle_shutdown_time.
   * Default: True
   */
  idleShutdown?:
    | boolean
    | undefined;
  /** Time in minutes to wait before shutting down runtime. Default: 180 minutes */
  idleShutdownTimeout: number;
  /**
   * Install Nvidia Driver automatically.
   * Default: True
   */
  installGpuDriver: boolean;
  /**
   * Specify a custom Cloud Storage path where the GPU driver is stored.
   * If not specified, we'll automatically choose from official GPU drivers.
   */
  customGpuDriverPath: string;
  /**
   * Path to a Bash script that automatically runs after a notebook instance
   * fully boots up. The path must be a URL or
   * Cloud Storage path (`gs://path-to-file/file-name`).
   */
  postStartupScript: string;
  /**
   * Optional. Use a list of container images to use as Kernels in the notebook
   * instance.
   */
  kernels: ContainerImage[];
  /**
   * Output only. Bool indicating whether an newer image is available in an
   * image family.
   */
  upgradeable?:
    | boolean
    | undefined;
  /** Behavior for the post startup script. */
  postStartupScriptBehavior: RuntimeSoftwareConfig_PostStartupScriptBehavior;
  /**
   * Bool indicating whether JupyterLab terminal will be available or not.
   * Default: False
   */
  disableTerminal?:
    | boolean
    | undefined;
  /**
   * Output only. version of boot image such as M100, from release label of the
   * image.
   */
  version?:
    | string
    | undefined;
  /**
   * Bool indicating whether mixer client should be disabled.
   * Default: False
   */
  mixerDisabled?: boolean | undefined;
}

/** Behavior for the post startup script. */
export enum RuntimeSoftwareConfig_PostStartupScriptBehavior {
  /** POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED - Unspecified post startup script behavior. Will run only once at creation. */
  POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED = 0,
  /** RUN_EVERY_START - Runs the post startup script provided during creation at every start. */
  RUN_EVERY_START = 1,
  /** DOWNLOAD_AND_RUN_EVERY_START - Downloads and runs the provided post startup script at every start. */
  DOWNLOAD_AND_RUN_EVERY_START = 2,
  UNRECOGNIZED = -1,
}

export function runtimeSoftwareConfig_PostStartupScriptBehaviorFromJSON(
  object: any,
): RuntimeSoftwareConfig_PostStartupScriptBehavior {
  switch (object) {
    case 0:
    case "POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED":
      return RuntimeSoftwareConfig_PostStartupScriptBehavior.POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED;
    case 1:
    case "RUN_EVERY_START":
      return RuntimeSoftwareConfig_PostStartupScriptBehavior.RUN_EVERY_START;
    case 2:
    case "DOWNLOAD_AND_RUN_EVERY_START":
      return RuntimeSoftwareConfig_PostStartupScriptBehavior.DOWNLOAD_AND_RUN_EVERY_START;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuntimeSoftwareConfig_PostStartupScriptBehavior.UNRECOGNIZED;
  }
}

export function runtimeSoftwareConfig_PostStartupScriptBehaviorToJSON(
  object: RuntimeSoftwareConfig_PostStartupScriptBehavior,
): string {
  switch (object) {
    case RuntimeSoftwareConfig_PostStartupScriptBehavior.POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED:
      return "POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED";
    case RuntimeSoftwareConfig_PostStartupScriptBehavior.RUN_EVERY_START:
      return "RUN_EVERY_START";
    case RuntimeSoftwareConfig_PostStartupScriptBehavior.DOWNLOAD_AND_RUN_EVERY_START:
      return "DOWNLOAD_AND_RUN_EVERY_START";
    case RuntimeSoftwareConfig_PostStartupScriptBehavior.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Contains runtime daemon metrics, such as OS and kernels and sessions stats. */
export interface RuntimeMetrics {
  /** Output only. The system metrics. */
  systemMetrics: { [key: string]: string };
}

export interface RuntimeMetrics_SystemMetricsEntry {
  key: string;
  value: string;
}

/**
 * A set of Shielded Instance options.
 * See [Images using supported Shielded VM
 * features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
 * Not all combinations are valid.
 */
export interface RuntimeShieldedInstanceConfig {
  /**
   * Defines whether the instance has Secure Boot enabled.
   *
   * Secure Boot helps ensure that the system only runs authentic software by
   * verifying the digital signature of all boot components, and halting the
   * boot process if signature verification fails. Disabled by default.
   */
  enableSecureBoot: boolean;
  /** Defines whether the instance has the vTPM enabled. Enabled by default. */
  enableVtpm: boolean;
  /**
   * Defines whether the instance has integrity monitoring enabled.
   *
   * Enables monitoring and attestation of the boot integrity of the instance.
   * The attestation is performed against the integrity policy baseline. This
   * baseline is initially derived from the implicitly trusted boot image when
   * the instance is created. Enabled by default.
   */
  enableIntegrityMonitoring: boolean;
}

/** Runtime using Virtual Machine for computing. */
export interface VirtualMachine {
  /** Output only. The user-friendly name of the Managed Compute Engine instance. */
  instanceName: string;
  /** Output only. The unique identifier of the Managed Compute Engine instance. */
  instanceId: string;
  /** Virtual Machine configuration settings. */
  virtualMachineConfig?: VirtualMachineConfig | undefined;
}

/** The config settings for virtual machine. */
export interface VirtualMachineConfig {
  /**
   * Output only. The zone where the virtual machine is located.
   * If using regional request, the notebooks service will pick a location
   * in the corresponding runtime region.
   * On a get request, zone will always be present. Example:
   * * `us-central1-b`
   */
  zone: string;
  /**
   * Required. The Compute Engine machine type used for runtimes.
   * Short name is valid. Examples:
   * * `n1-standard-2`
   * * `e2-standard-8`
   */
  machineType: string;
  /**
   * Optional. Use a list of container images to use as Kernels in the notebook
   * instance.
   */
  containerImages: ContainerImage[];
  /** Required. Data disk option configuration settings. */
  dataDisk?:
    | LocalDisk
    | undefined;
  /** Optional. Encryption settings for virtual machine data disk. */
  encryptionConfig?:
    | EncryptionConfig
    | undefined;
  /** Optional. Shielded VM Instance configuration settings. */
  shieldedInstanceConfig?:
    | RuntimeShieldedInstanceConfig
    | undefined;
  /** Optional. The Compute Engine accelerator configuration for this runtime. */
  acceleratorConfig?:
    | RuntimeAcceleratorConfig
    | undefined;
  /**
   * Optional. The Compute Engine network to be used for machine
   * communications. Cannot be specified with subnetwork. If neither
   * `network` nor `subnet` is specified, the "default" network of
   * the project is used, if it exists.
   *
   * A full URL or partial URI. Examples:
   *
   * * `https://www.googleapis.com/compute/v1/projects/[project_id]/global/networks/default`
   * * `projects/[project_id]/global/networks/default`
   *
   * Runtimes are managed resources inside Google Infrastructure.
   * Runtimes support the following network configurations:
   *
   * * Google Managed Network (Network & subnet are empty)
   * * Consumer Project VPC (network & subnet are required). Requires
   * configuring Private Service Access.
   * * Shared VPC (network & subnet are required). Requires configuring Private
   * Service Access.
   */
  network: string;
  /**
   * Optional. The Compute Engine subnetwork to be used for machine
   * communications. Cannot be specified with network.
   *
   * A full URL or partial URI are valid. Examples:
   *
   * * `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/us-east1/subnetworks/sub0`
   * * `projects/[project_id]/regions/us-east1/subnetworks/sub0`
   */
  subnet: string;
  /**
   * Optional. If true, runtime will only have internal IP
   * addresses. By default, runtimes are not restricted to internal IP
   * addresses, and will have ephemeral external IP addresses assigned to each
   * vm. This `internal_ip_only` restriction can only be enabled for
   * subnetwork enabled networks, and all dependencies must be
   * configured to be accessible without external IP addresses.
   */
  internalIpOnly: boolean;
  /**
   * Optional. The Compute Engine tags to add to runtime (see [Tagging
   * instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
   */
  tags: string[];
  /**
   * Output only. The Compute Engine guest attributes. (see
   * [Project and instance
   * guest
   * attributes](https://cloud.google.com/compute/docs/storing-retrieving-metadata#guest_attributes)).
   */
  guestAttributes: { [key: string]: string };
  /**
   * Optional. The Compute Engine metadata entries to add to virtual machine.
   * (see [Project and instance
   * metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
   */
  metadata: { [key: string]: string };
  /**
   * Optional. The labels to associate with this runtime.
   * Label **keys** must contain 1 to 63 characters, and must conform to
   * [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
   * Label **values** may be empty, but, if present, must contain 1 to 63
   * characters, and must conform to [RFC
   * 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
   * associated with a cluster.
   */
  labels: { [key: string]: string };
  /**
   * Optional. The type of vNIC to be used on this interface. This may be gVNIC
   * or VirtioNet.
   */
  nicType: VirtualMachineConfig_NicType;
  /**
   * Optional. Reserved IP Range name is used for VPC Peering.
   * The subnetwork allocation will use the range *name* if it's assigned.
   *
   * Example: managed-notebooks-range-c
   *
   *     PEERING_RANGE_NAME_3=managed-notebooks-range-c
   *     gcloud compute addresses create $PEERING_RANGE_NAME_3 \
   *       --global \
   *       --prefix-length=24 \
   *       --description="Google Cloud Managed Notebooks Range 24 c" \
   *       --network=$NETWORK \
   *       --addresses=192.168.0.0 \
   *       --purpose=VPC_PEERING
   *
   * Field value will be: `managed-notebooks-range-c`
   */
  reservedIpRange: string;
  /** Optional. Boot image metadata used for runtime upgradeability. */
  bootImage?: VirtualMachineConfig_BootImage | undefined;
}

/**
 * The type of vNIC driver.
 * Default should be UNSPECIFIED_NIC_TYPE.
 */
export enum VirtualMachineConfig_NicType {
  /** UNSPECIFIED_NIC_TYPE - No type specified. */
  UNSPECIFIED_NIC_TYPE = 0,
  /** VIRTIO_NET - VIRTIO */
  VIRTIO_NET = 1,
  /** GVNIC - GVNIC */
  GVNIC = 2,
  UNRECOGNIZED = -1,
}

export function virtualMachineConfig_NicTypeFromJSON(object: any): VirtualMachineConfig_NicType {
  switch (object) {
    case 0:
    case "UNSPECIFIED_NIC_TYPE":
      return VirtualMachineConfig_NicType.UNSPECIFIED_NIC_TYPE;
    case 1:
    case "VIRTIO_NET":
      return VirtualMachineConfig_NicType.VIRTIO_NET;
    case 2:
    case "GVNIC":
      return VirtualMachineConfig_NicType.GVNIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VirtualMachineConfig_NicType.UNRECOGNIZED;
  }
}

export function virtualMachineConfig_NicTypeToJSON(object: VirtualMachineConfig_NicType): string {
  switch (object) {
    case VirtualMachineConfig_NicType.UNSPECIFIED_NIC_TYPE:
      return "UNSPECIFIED_NIC_TYPE";
    case VirtualMachineConfig_NicType.VIRTIO_NET:
      return "VIRTIO_NET";
    case VirtualMachineConfig_NicType.GVNIC:
      return "GVNIC";
    case VirtualMachineConfig_NicType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Definition of the boot image used by the Runtime.
 * Used to facilitate runtime upgradeability.
 */
export interface VirtualMachineConfig_BootImage {
}

export interface VirtualMachineConfig_GuestAttributesEntry {
  key: string;
  value: string;
}

export interface VirtualMachineConfig_MetadataEntry {
  key: string;
  value: string;
}

export interface VirtualMachineConfig_LabelsEntry {
  key: string;
  value: string;
}

/** The description a notebook execution workload. */
export interface ExecutionTemplate {
  /**
   * Required. Scale tier of the hardware used for notebook execution.
   * DEPRECATED Will be discontinued. As right now only CUSTOM is supported.
   */
  scaleTier: ExecutionTemplate_ScaleTier;
  /**
   * Specifies the type of virtual machine to use for your training
   * job's master worker. You must specify this field when `scaleTier` is set to
   * `CUSTOM`.
   *
   * You can use certain Compute Engine machine types directly in this field.
   * The following types are supported:
   *
   * - `n1-standard-4`
   * - `n1-standard-8`
   * - `n1-standard-16`
   * - `n1-standard-32`
   * - `n1-standard-64`
   * - `n1-standard-96`
   * - `n1-highmem-2`
   * - `n1-highmem-4`
   * - `n1-highmem-8`
   * - `n1-highmem-16`
   * - `n1-highmem-32`
   * - `n1-highmem-64`
   * - `n1-highmem-96`
   * - `n1-highcpu-16`
   * - `n1-highcpu-32`
   * - `n1-highcpu-64`
   * - `n1-highcpu-96`
   *
   * Alternatively, you can use the following legacy machine types:
   *
   * - `standard`
   * - `large_model`
   * - `complex_model_s`
   * - `complex_model_m`
   * - `complex_model_l`
   * - `standard_gpu`
   * - `complex_model_m_gpu`
   * - `complex_model_l_gpu`
   * - `standard_p100`
   * - `complex_model_m_p100`
   * - `standard_v100`
   * - `large_model_v100`
   * - `complex_model_m_v100`
   * - `complex_model_l_v100`
   *
   * Finally, if you want to use a TPU for training, specify `cloud_tpu` in this
   * field. Learn more about the [special configuration options for training
   * with
   * TPU](https://cloud.google.com/ai-platform/training/docs/using-tpus#configuring_a_custom_tpu_machine).
   */
  masterType: string;
  /**
   * Configuration (count and accelerator type) for hardware running notebook
   * execution.
   */
  acceleratorConfig?:
    | ExecutionTemplate_SchedulerAcceleratorConfig
    | undefined;
  /**
   * Labels for execution.
   * If execution is scheduled, a field included will be 'nbs-scheduled'.
   * Otherwise, it is an immediate execution, and an included field will be
   * 'nbs-immediate'. Use fields to efficiently index between various types of
   * executions.
   */
  labels: { [key: string]: string };
  /**
   * Path to the notebook file to execute.
   * Must be in a Google Cloud Storage bucket.
   * Format: `gs://{bucket_name}/{folder}/{notebook_file_name}`
   * Ex: `gs://notebook_user/scheduled_notebooks/sentiment_notebook.ipynb`
   */
  inputNotebookFile: string;
  /**
   * Container Image URI to a DLVM
   * Example: 'gcr.io/deeplearning-platform-release/base-cu100'
   * More examples can be found at:
   * https://cloud.google.com/ai-platform/deep-learning-containers/docs/choosing-container
   */
  containerImageUri: string;
  /**
   * Path to the notebook folder to write to.
   * Must be in a Google Cloud Storage bucket path.
   * Format: `gs://{bucket_name}/{folder}`
   * Ex: `gs://notebook_user/scheduled_notebooks`
   */
  outputNotebookFolder: string;
  /**
   * Parameters to be overridden in the notebook during execution.
   * Ref https://papermill.readthedocs.io/en/latest/usage-parameterize.html on
   * how to specifying parameters in the input notebook and pass them here
   * in an YAML file.
   * Ex: `gs://notebook_user/scheduled_notebooks/sentiment_notebook_params.yaml`
   */
  paramsYamlFile: string;
  /** Parameters used within the 'input_notebook_file' notebook. */
  parameters: string;
  /**
   * The email address of a service account to use when running the execution.
   * You must have the `iam.serviceAccounts.actAs` permission for the specified
   * service account.
   */
  serviceAccount: string;
  /** The type of Job to be used on this execution. */
  jobType: ExecutionTemplate_JobType;
  /** Parameters used in Dataproc JobType executions. */
  dataprocParameters?:
    | ExecutionTemplate_DataprocParameters
    | undefined;
  /** Parameters used in Vertex AI JobType executions. */
  vertexAiParameters?:
    | ExecutionTemplate_VertexAIParameters
    | undefined;
  /**
   * Name of the kernel spec to use. This must be specified if the
   * kernel spec name on the execution target does not match the name in the
   * input notebook file.
   */
  kernelSpec: string;
  /**
   * The name of a Vertex AI [Tensorboard] resource to which this execution
   * will upload Tensorboard logs.
   * Format:
   * `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
   */
  tensorboard: string;
}

/**
 * Required. Specifies the machine types, the number of replicas for workers
 * and parameter servers.
 */
export enum ExecutionTemplate_ScaleTier {
  /** SCALE_TIER_UNSPECIFIED - Unspecified Scale Tier. */
  SCALE_TIER_UNSPECIFIED = 0,
  /**
   * BASIC - A single worker instance. This tier is suitable for learning how to use
   * Cloud ML, and for experimenting with new models using small datasets.
   */
  BASIC = 1,
  /** STANDARD_1 - Many workers and a few parameter servers. */
  STANDARD_1 = 2,
  /** PREMIUM_1 - A large number of workers with many parameter servers. */
  PREMIUM_1 = 3,
  /** BASIC_GPU - A single worker instance with a K80 GPU. */
  BASIC_GPU = 4,
  /** BASIC_TPU - A single worker instance with a Cloud TPU. */
  BASIC_TPU = 5,
  /**
   * CUSTOM - The CUSTOM tier is not a set tier, but rather enables you to use your
   * own cluster specification. When you use this tier, set values to
   * configure your processing cluster according to these guidelines:
   *
   * *   You _must_ set `ExecutionTemplate.masterType` to specify the type
   *     of machine to use for your master node. This is the only required
   *     setting.
   */
  CUSTOM = 6,
  UNRECOGNIZED = -1,
}

export function executionTemplate_ScaleTierFromJSON(object: any): ExecutionTemplate_ScaleTier {
  switch (object) {
    case 0:
    case "SCALE_TIER_UNSPECIFIED":
      return ExecutionTemplate_ScaleTier.SCALE_TIER_UNSPECIFIED;
    case 1:
    case "BASIC":
      return ExecutionTemplate_ScaleTier.BASIC;
    case 2:
    case "STANDARD_1":
      return ExecutionTemplate_ScaleTier.STANDARD_1;
    case 3:
    case "PREMIUM_1":
      return ExecutionTemplate_ScaleTier.PREMIUM_1;
    case 4:
    case "BASIC_GPU":
      return ExecutionTemplate_ScaleTier.BASIC_GPU;
    case 5:
    case "BASIC_TPU":
      return ExecutionTemplate_ScaleTier.BASIC_TPU;
    case 6:
    case "CUSTOM":
      return ExecutionTemplate_ScaleTier.CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionTemplate_ScaleTier.UNRECOGNIZED;
  }
}

export function executionTemplate_ScaleTierToJSON(object: ExecutionTemplate_ScaleTier): string {
  switch (object) {
    case ExecutionTemplate_ScaleTier.SCALE_TIER_UNSPECIFIED:
      return "SCALE_TIER_UNSPECIFIED";
    case ExecutionTemplate_ScaleTier.BASIC:
      return "BASIC";
    case ExecutionTemplate_ScaleTier.STANDARD_1:
      return "STANDARD_1";
    case ExecutionTemplate_ScaleTier.PREMIUM_1:
      return "PREMIUM_1";
    case ExecutionTemplate_ScaleTier.BASIC_GPU:
      return "BASIC_GPU";
    case ExecutionTemplate_ScaleTier.BASIC_TPU:
      return "BASIC_TPU";
    case ExecutionTemplate_ScaleTier.CUSTOM:
      return "CUSTOM";
    case ExecutionTemplate_ScaleTier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Hardware accelerator types for AI Platform Training jobs. */
export enum ExecutionTemplate_SchedulerAcceleratorType {
  /** SCHEDULER_ACCELERATOR_TYPE_UNSPECIFIED - Unspecified accelerator type. Default to no GPU. */
  SCHEDULER_ACCELERATOR_TYPE_UNSPECIFIED = 0,
  /** NVIDIA_TESLA_K80 - Nvidia Tesla K80 GPU. */
  NVIDIA_TESLA_K80 = 1,
  /** NVIDIA_TESLA_P100 - Nvidia Tesla P100 GPU. */
  NVIDIA_TESLA_P100 = 2,
  /** NVIDIA_TESLA_V100 - Nvidia Tesla V100 GPU. */
  NVIDIA_TESLA_V100 = 3,
  /** NVIDIA_TESLA_P4 - Nvidia Tesla P4 GPU. */
  NVIDIA_TESLA_P4 = 4,
  /** NVIDIA_TESLA_T4 - Nvidia Tesla T4 GPU. */
  NVIDIA_TESLA_T4 = 5,
  /** NVIDIA_TESLA_A100 - Nvidia Tesla A100 GPU. */
  NVIDIA_TESLA_A100 = 10,
  /** TPU_V2 - TPU v2. */
  TPU_V2 = 6,
  /** TPU_V3 - TPU v3. */
  TPU_V3 = 7,
  UNRECOGNIZED = -1,
}

export function executionTemplate_SchedulerAcceleratorTypeFromJSON(
  object: any,
): ExecutionTemplate_SchedulerAcceleratorType {
  switch (object) {
    case 0:
    case "SCHEDULER_ACCELERATOR_TYPE_UNSPECIFIED":
      return ExecutionTemplate_SchedulerAcceleratorType.SCHEDULER_ACCELERATOR_TYPE_UNSPECIFIED;
    case 1:
    case "NVIDIA_TESLA_K80":
      return ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_K80;
    case 2:
    case "NVIDIA_TESLA_P100":
      return ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_P100;
    case 3:
    case "NVIDIA_TESLA_V100":
      return ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_V100;
    case 4:
    case "NVIDIA_TESLA_P4":
      return ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_P4;
    case 5:
    case "NVIDIA_TESLA_T4":
      return ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_T4;
    case 10:
    case "NVIDIA_TESLA_A100":
      return ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_A100;
    case 6:
    case "TPU_V2":
      return ExecutionTemplate_SchedulerAcceleratorType.TPU_V2;
    case 7:
    case "TPU_V3":
      return ExecutionTemplate_SchedulerAcceleratorType.TPU_V3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionTemplate_SchedulerAcceleratorType.UNRECOGNIZED;
  }
}

export function executionTemplate_SchedulerAcceleratorTypeToJSON(
  object: ExecutionTemplate_SchedulerAcceleratorType,
): string {
  switch (object) {
    case ExecutionTemplate_SchedulerAcceleratorType.SCHEDULER_ACCELERATOR_TYPE_UNSPECIFIED:
      return "SCHEDULER_ACCELERATOR_TYPE_UNSPECIFIED";
    case ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_K80:
      return "NVIDIA_TESLA_K80";
    case ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_P100:
      return "NVIDIA_TESLA_P100";
    case ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_V100:
      return "NVIDIA_TESLA_V100";
    case ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_P4:
      return "NVIDIA_TESLA_P4";
    case ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_T4:
      return "NVIDIA_TESLA_T4";
    case ExecutionTemplate_SchedulerAcceleratorType.NVIDIA_TESLA_A100:
      return "NVIDIA_TESLA_A100";
    case ExecutionTemplate_SchedulerAcceleratorType.TPU_V2:
      return "TPU_V2";
    case ExecutionTemplate_SchedulerAcceleratorType.TPU_V3:
      return "TPU_V3";
    case ExecutionTemplate_SchedulerAcceleratorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The backend used for this execution. */
export enum ExecutionTemplate_JobType {
  /** JOB_TYPE_UNSPECIFIED - No type specified. */
  JOB_TYPE_UNSPECIFIED = 0,
  /**
   * VERTEX_AI - Custom Job in `aiplatform.googleapis.com`.
   * Default value for an execution.
   */
  VERTEX_AI = 1,
  /**
   * DATAPROC - Run execution on a cluster with Dataproc as a job.
   * https://cloud.google.com/dataproc/docs/reference/rest/v1/projects.regions.jobs
   */
  DATAPROC = 2,
  UNRECOGNIZED = -1,
}

export function executionTemplate_JobTypeFromJSON(object: any): ExecutionTemplate_JobType {
  switch (object) {
    case 0:
    case "JOB_TYPE_UNSPECIFIED":
      return ExecutionTemplate_JobType.JOB_TYPE_UNSPECIFIED;
    case 1:
    case "VERTEX_AI":
      return ExecutionTemplate_JobType.VERTEX_AI;
    case 2:
    case "DATAPROC":
      return ExecutionTemplate_JobType.DATAPROC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionTemplate_JobType.UNRECOGNIZED;
  }
}

export function executionTemplate_JobTypeToJSON(object: ExecutionTemplate_JobType): string {
  switch (object) {
    case ExecutionTemplate_JobType.JOB_TYPE_UNSPECIFIED:
      return "JOB_TYPE_UNSPECIFIED";
    case ExecutionTemplate_JobType.VERTEX_AI:
      return "VERTEX_AI";
    case ExecutionTemplate_JobType.DATAPROC:
      return "DATAPROC";
    case ExecutionTemplate_JobType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Definition of a hardware accelerator. Note that not all combinations
 * of `type` and `core_count` are valid. See [GPUs on
 * Compute Engine](https://cloud.google.com/compute/docs/gpus) to find a valid
 * combination. TPUs are not supported.
 */
export interface ExecutionTemplate_SchedulerAcceleratorConfig {
  /** Type of this accelerator. */
  type: ExecutionTemplate_SchedulerAcceleratorType;
  /** Count of cores of this accelerator. */
  coreCount: Long;
}

/** Parameters used in Dataproc JobType executions. */
export interface ExecutionTemplate_DataprocParameters {
  /**
   * URI for cluster used to run Dataproc execution.
   * Format: `projects/{PROJECT_ID}/regions/{REGION}/clusters/{CLUSTER_NAME}`
   */
  cluster: string;
}

/** Parameters used in Vertex AI JobType executions. */
export interface ExecutionTemplate_VertexAIParameters {
  /**
   * The full name of the Compute Engine
   * [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
   * to which the Job should be peered. For example,
   * `projects/12345/global/networks/myVPC`.
   * [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert)
   * is of the form `projects/{project}/global/networks/{network}`.
   * Where `{project}` is a project number, as in `12345`, and `{network}` is
   * a network name.
   *
   * Private services access must already be configured for the network. If
   * left unspecified, the job is not peered with any network.
   */
  network: string;
  /**
   * Environment variables.
   * At most 100 environment variables can be specified and unique.
   * Example: `GCP_BUCKET=gs://my-bucket/samples/`
   */
  env: { [key: string]: string };
}

export interface ExecutionTemplate_VertexAIParameters_EnvEntry {
  key: string;
  value: string;
}

export interface ExecutionTemplate_LabelsEntry {
  key: string;
  value: string;
}

/** The definition of a single executed notebook. */
export interface Execution {
  /** execute metadata including name, hardware spec, region, labels, etc. */
  executionTemplate?:
    | ExecutionTemplate
    | undefined;
  /**
   * Output only. The resource name of the execute. Format:
   * `projects/{project_id}/locations/{location}/executions/{execution_id}`
   */
  name: string;
  /**
   * Output only. Name used for UI purposes.
   * Name can only contain alphanumeric characters and underscores '_'.
   */
  displayName: string;
  /** A brief description of this execution. */
  description: string;
  /** Output only. Time the Execution was instantiated. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Time the Execution was last updated. */
  updateTime?:
    | Date
    | undefined;
  /** Output only. State of the underlying AI Platform job. */
  state: Execution_State;
  /** Output notebook file generated by this execution */
  outputNotebookFile: string;
  /** Output only. The URI of the external job used to execute the notebook. */
  jobUri: string;
}

/** Enum description of the state of the underlying AIP job. */
export enum Execution_State {
  /** STATE_UNSPECIFIED - The job state is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** QUEUED - The job has been just created and processing has not yet begun. */
  QUEUED = 1,
  /** PREPARING - The service is preparing to execution the job. */
  PREPARING = 2,
  /** RUNNING - The job is in progress. */
  RUNNING = 3,
  /** SUCCEEDED - The job completed successfully. */
  SUCCEEDED = 4,
  /**
   * FAILED - The job failed.
   * `error_message` should contain the details of the failure.
   */
  FAILED = 5,
  /**
   * CANCELLING - The job is being cancelled.
   * `error_message` should describe the reason for the cancellation.
   */
  CANCELLING = 6,
  /**
   * CANCELLED - The job has been cancelled.
   * `error_message` should describe the reason for the cancellation.
   */
  CANCELLED = 7,
  /**
   * EXPIRED - The job has become expired (relevant to Vertex AI jobs)
   * https://cloud.google.com/vertex-ai/docs/reference/rest/v1/JobState
   */
  EXPIRED = 9,
  /** INITIALIZING - The Execution is being created. */
  INITIALIZING = 10,
  UNRECOGNIZED = -1,
}

export function execution_StateFromJSON(object: any): Execution_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Execution_State.STATE_UNSPECIFIED;
    case 1:
    case "QUEUED":
      return Execution_State.QUEUED;
    case 2:
    case "PREPARING":
      return Execution_State.PREPARING;
    case 3:
    case "RUNNING":
      return Execution_State.RUNNING;
    case 4:
    case "SUCCEEDED":
      return Execution_State.SUCCEEDED;
    case 5:
    case "FAILED":
      return Execution_State.FAILED;
    case 6:
    case "CANCELLING":
      return Execution_State.CANCELLING;
    case 7:
    case "CANCELLED":
      return Execution_State.CANCELLED;
    case 9:
    case "EXPIRED":
      return Execution_State.EXPIRED;
    case 10:
    case "INITIALIZING":
      return Execution_State.INITIALIZING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Execution_State.UNRECOGNIZED;
  }
}

export function execution_StateToJSON(object: Execution_State): string {
  switch (object) {
    case Execution_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Execution_State.QUEUED:
      return "QUEUED";
    case Execution_State.PREPARING:
      return "PREPARING";
    case Execution_State.RUNNING:
      return "RUNNING";
    case Execution_State.SUCCEEDED:
      return "SUCCEEDED";
    case Execution_State.FAILED:
      return "FAILED";
    case Execution_State.CANCELLING:
      return "CANCELLING";
    case Execution_State.CANCELLED:
      return "CANCELLED";
    case Execution_State.EXPIRED:
      return "EXPIRED";
    case Execution_State.INITIALIZING:
      return "INITIALIZING";
    case Execution_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Reservation Affinity for consuming Zonal reservation. */
export interface ReservationAffinity {
  /** Optional. Type of reservation to consume */
  consumeReservationType: ReservationAffinity_Type;
  /** Optional. Corresponds to the label key of reservation resource. */
  key: string;
  /** Optional. Corresponds to the label values of reservation resource. */
  values: string[];
}

/** Indicates whether to consume capacity from an reservation or not. */
export enum ReservationAffinity_Type {
  /** TYPE_UNSPECIFIED - Default type. */
  TYPE_UNSPECIFIED = 0,
  /** NO_RESERVATION - Do not consume from any allocated capacity. */
  NO_RESERVATION = 1,
  /** ANY_RESERVATION - Consume any reservation available. */
  ANY_RESERVATION = 2,
  /**
   * SPECIFIC_RESERVATION - Must consume from a specific reservation. Must specify key value fields
   * for specifying the reservations.
   */
  SPECIFIC_RESERVATION = 3,
  UNRECOGNIZED = -1,
}

export function reservationAffinity_TypeFromJSON(object: any): ReservationAffinity_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return ReservationAffinity_Type.TYPE_UNSPECIFIED;
    case 1:
    case "NO_RESERVATION":
      return ReservationAffinity_Type.NO_RESERVATION;
    case 2:
    case "ANY_RESERVATION":
      return ReservationAffinity_Type.ANY_RESERVATION;
    case 3:
    case "SPECIFIC_RESERVATION":
      return ReservationAffinity_Type.SPECIFIC_RESERVATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReservationAffinity_Type.UNRECOGNIZED;
  }
}

export function reservationAffinity_TypeToJSON(object: ReservationAffinity_Type): string {
  switch (object) {
    case ReservationAffinity_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case ReservationAffinity_Type.NO_RESERVATION:
      return "NO_RESERVATION";
    case ReservationAffinity_Type.ANY_RESERVATION:
      return "ANY_RESERVATION";
    case ReservationAffinity_Type.SPECIFIC_RESERVATION:
      return "SPECIFIC_RESERVATION";
    case ReservationAffinity_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of a notebook instance. */
export interface Instance {
  /**
   * Output only. The name of this notebook instance. Format:
   * `projects/{project_id}/locations/{location}/instances/{instance_id}`
   */
  name: string;
  /** Use a Compute Engine VM image to start the notebook instance. */
  vmImage?:
    | VmImage
    | undefined;
  /** Use a container image to start the notebook instance. */
  containerImage?:
    | ContainerImage
    | undefined;
  /**
   * Path to a Bash script that automatically runs after a notebook instance
   * fully boots up. The path must be a URL or
   * Cloud Storage path (`gs://path-to-file/file-name`).
   */
  postStartupScript: string;
  /**
   * Output only. The proxy endpoint that is used to access the Jupyter
   * notebook.
   */
  proxyUri: string;
  /**
   * The service account on this instance, giving access to other Google
   * Cloud services.
   * You can use any service account within the same project, but you
   * must have the service account user permission to use the instance.
   *
   * If not specified, the [Compute Engine default service
   * account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
   * is used.
   */
  serviceAccount: string;
  /**
   * Optional. The URIs of service account scopes to be included in
   * Compute Engine instances.
   *
   * If not specified, the following
   * [scopes](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)
   * are defined:
   *  - https://www.googleapis.com/auth/cloud-platform
   *  - https://www.googleapis.com/auth/userinfo.email
   * If not using default scopes, you need at least:
   *    https://www.googleapis.com/auth/compute
   */
  serviceAccountScopes: string[];
  /**
   * Required. The [Compute Engine machine
   * type](https://cloud.google.com/compute/docs/machine-types) of this
   * instance.
   */
  machineType: string;
  /**
   * The hardware accelerator used on this instance. If you use
   * accelerators, make sure that your configuration has
   * [enough vCPUs and memory to support the `machine_type` you have
   * selected](https://cloud.google.com/compute/docs/gpus/#gpus-list).
   */
  acceleratorConfig?:
    | Instance_AcceleratorConfig
    | undefined;
  /** Output only. The state of this instance. */
  state: Instance_State;
  /**
   * Whether the end user authorizes Google Cloud to install GPU driver
   * on this instance.
   * If this field is empty or set to false, the GPU driver won't be installed.
   * Only applicable to instances with GPUs.
   */
  installGpuDriver: boolean;
  /**
   * Specify a custom Cloud Storage path where the GPU driver is stored.
   * If not specified, we'll automatically choose from official GPU drivers.
   */
  customGpuDriverPath: string;
  /** Output only. Attached disks to notebook instance. */
  disks: Instance_Disk[];
  /**
   * Optional. Shielded VM configuration.
   * [Images using supported Shielded VM
   * features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
   */
  shieldedInstanceConfig?:
    | Instance_ShieldedInstanceConfig
    | undefined;
  /** If true, no external IP will be assigned to this instance. */
  noPublicIp: boolean;
  /** If true, the notebook instance will not register with the proxy. */
  noProxyAccess: boolean;
  /**
   * The name of the VPC that this instance is in.
   * Format:
   * `projects/{project_id}/global/networks/{network_id}`
   */
  network: string;
  /**
   * The name of the subnet that this instance is in.
   * Format:
   * `projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}`
   */
  subnet: string;
  /**
   * Labels to apply to this instance.
   * These can be later modified by the setLabels method.
   */
  labels: { [key: string]: string };
  /** Custom metadata to apply to this instance. */
  metadata: { [key: string]: string };
  /**
   * Optional. The Compute Engine tags to add to runtime (see [Tagging
   * instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
   */
  tags: string[];
  /** The upgrade history of this instance. */
  upgradeHistory: Instance_UpgradeHistoryEntry[];
  /**
   * Optional. The type of vNIC to be used on this interface. This may be gVNIC
   * or VirtioNet.
   */
  nicType: Instance_NicType;
  /**
   * Optional. The optional reservation affinity. Setting this field will apply
   * the specified [Zonal Compute
   * Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
   * to this notebook instance.
   */
  reservationAffinity?:
    | ReservationAffinity
    | undefined;
  /**
   * Output only. Email address of entity that sent original CreateInstance
   * request.
   */
  creator: string;
  /**
   * Optional. Flag to enable ip forwarding or not, default false/off.
   * https://cloud.google.com/vpc/docs/using-routes#canipforward
   */
  canIpForward: boolean;
  /** Output only. Instance creation time. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Instance update time. */
  updateTime?: Date | undefined;
}

/**
 * Definition of the types of hardware accelerators that can be used on this
 * instance.
 */
export enum Instance_AcceleratorType {
  /** ACCELERATOR_TYPE_UNSPECIFIED - Accelerator type is not specified. */
  ACCELERATOR_TYPE_UNSPECIFIED = 0,
  /** NVIDIA_TESLA_K80 - Accelerator type is Nvidia Tesla K80. */
  NVIDIA_TESLA_K80 = 1,
  /** NVIDIA_TESLA_P100 - Accelerator type is Nvidia Tesla P100. */
  NVIDIA_TESLA_P100 = 2,
  /** NVIDIA_TESLA_V100 - Accelerator type is Nvidia Tesla V100. */
  NVIDIA_TESLA_V100 = 3,
  /** NVIDIA_TESLA_P4 - Accelerator type is Nvidia Tesla P4. */
  NVIDIA_TESLA_P4 = 4,
  /** NVIDIA_TESLA_T4 - Accelerator type is Nvidia Tesla T4. */
  NVIDIA_TESLA_T4 = 5,
  /** NVIDIA_TESLA_A100 - Accelerator type is Nvidia Tesla A100. */
  NVIDIA_TESLA_A100 = 11,
  /** NVIDIA_TESLA_T4_VWS - Accelerator type is NVIDIA Tesla T4 Virtual Workstations. */
  NVIDIA_TESLA_T4_VWS = 8,
  /** NVIDIA_TESLA_P100_VWS - Accelerator type is NVIDIA Tesla P100 Virtual Workstations. */
  NVIDIA_TESLA_P100_VWS = 9,
  /** NVIDIA_TESLA_P4_VWS - Accelerator type is NVIDIA Tesla P4 Virtual Workstations. */
  NVIDIA_TESLA_P4_VWS = 10,
  /** TPU_V2 - (Coming soon) Accelerator type is TPU V2. */
  TPU_V2 = 6,
  /** TPU_V3 - (Coming soon) Accelerator type is TPU V3. */
  TPU_V3 = 7,
  UNRECOGNIZED = -1,
}

export function instance_AcceleratorTypeFromJSON(object: any): Instance_AcceleratorType {
  switch (object) {
    case 0:
    case "ACCELERATOR_TYPE_UNSPECIFIED":
      return Instance_AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED;
    case 1:
    case "NVIDIA_TESLA_K80":
      return Instance_AcceleratorType.NVIDIA_TESLA_K80;
    case 2:
    case "NVIDIA_TESLA_P100":
      return Instance_AcceleratorType.NVIDIA_TESLA_P100;
    case 3:
    case "NVIDIA_TESLA_V100":
      return Instance_AcceleratorType.NVIDIA_TESLA_V100;
    case 4:
    case "NVIDIA_TESLA_P4":
      return Instance_AcceleratorType.NVIDIA_TESLA_P4;
    case 5:
    case "NVIDIA_TESLA_T4":
      return Instance_AcceleratorType.NVIDIA_TESLA_T4;
    case 11:
    case "NVIDIA_TESLA_A100":
      return Instance_AcceleratorType.NVIDIA_TESLA_A100;
    case 8:
    case "NVIDIA_TESLA_T4_VWS":
      return Instance_AcceleratorType.NVIDIA_TESLA_T4_VWS;
    case 9:
    case "NVIDIA_TESLA_P100_VWS":
      return Instance_AcceleratorType.NVIDIA_TESLA_P100_VWS;
    case 10:
    case "NVIDIA_TESLA_P4_VWS":
      return Instance_AcceleratorType.NVIDIA_TESLA_P4_VWS;
    case 6:
    case "TPU_V2":
      return Instance_AcceleratorType.TPU_V2;
    case 7:
    case "TPU_V3":
      return Instance_AcceleratorType.TPU_V3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_AcceleratorType.UNRECOGNIZED;
  }
}

export function instance_AcceleratorTypeToJSON(object: Instance_AcceleratorType): string {
  switch (object) {
    case Instance_AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED:
      return "ACCELERATOR_TYPE_UNSPECIFIED";
    case Instance_AcceleratorType.NVIDIA_TESLA_K80:
      return "NVIDIA_TESLA_K80";
    case Instance_AcceleratorType.NVIDIA_TESLA_P100:
      return "NVIDIA_TESLA_P100";
    case Instance_AcceleratorType.NVIDIA_TESLA_V100:
      return "NVIDIA_TESLA_V100";
    case Instance_AcceleratorType.NVIDIA_TESLA_P4:
      return "NVIDIA_TESLA_P4";
    case Instance_AcceleratorType.NVIDIA_TESLA_T4:
      return "NVIDIA_TESLA_T4";
    case Instance_AcceleratorType.NVIDIA_TESLA_A100:
      return "NVIDIA_TESLA_A100";
    case Instance_AcceleratorType.NVIDIA_TESLA_T4_VWS:
      return "NVIDIA_TESLA_T4_VWS";
    case Instance_AcceleratorType.NVIDIA_TESLA_P100_VWS:
      return "NVIDIA_TESLA_P100_VWS";
    case Instance_AcceleratorType.NVIDIA_TESLA_P4_VWS:
      return "NVIDIA_TESLA_P4_VWS";
    case Instance_AcceleratorType.TPU_V2:
      return "TPU_V2";
    case Instance_AcceleratorType.TPU_V3:
      return "TPU_V3";
    case Instance_AcceleratorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of the states of this instance. */
export enum Instance_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTING - The control logic is starting the instance. */
  STARTING = 1,
  /**
   * PROVISIONING - The control logic is installing required frameworks and registering the
   * instance with notebook proxy
   */
  PROVISIONING = 2,
  /** ACTIVE - The instance is running. */
  ACTIVE = 3,
  /** STOPPING - The control logic is stopping the instance. */
  STOPPING = 4,
  /** STOPPED - The instance is stopped. */
  STOPPED = 5,
  /** DELETED - The instance is deleted. */
  DELETED = 6,
  /** UPGRADING - The instance is upgrading. */
  UPGRADING = 7,
  /** INITIALIZING - The instance is being created. */
  INITIALIZING = 8,
  /** REGISTERING - The instance is getting registered. */
  REGISTERING = 9,
  /** SUSPENDING - The instance is suspending. */
  SUSPENDING = 10,
  /** SUSPENDED - The instance is suspended. */
  SUSPENDED = 11,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTING":
      return Instance_State.STARTING;
    case 2:
    case "PROVISIONING":
      return Instance_State.PROVISIONING;
    case 3:
    case "ACTIVE":
      return Instance_State.ACTIVE;
    case 4:
    case "STOPPING":
      return Instance_State.STOPPING;
    case 5:
    case "STOPPED":
      return Instance_State.STOPPED;
    case 6:
    case "DELETED":
      return Instance_State.DELETED;
    case 7:
    case "UPGRADING":
      return Instance_State.UPGRADING;
    case 8:
    case "INITIALIZING":
      return Instance_State.INITIALIZING;
    case 9:
    case "REGISTERING":
      return Instance_State.REGISTERING;
    case 10:
    case "SUSPENDING":
      return Instance_State.SUSPENDING;
    case 11:
    case "SUSPENDED":
      return Instance_State.SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.STARTING:
      return "STARTING";
    case Instance_State.PROVISIONING:
      return "PROVISIONING";
    case Instance_State.ACTIVE:
      return "ACTIVE";
    case Instance_State.STOPPING:
      return "STOPPING";
    case Instance_State.STOPPED:
      return "STOPPED";
    case Instance_State.DELETED:
      return "DELETED";
    case Instance_State.UPGRADING:
      return "UPGRADING";
    case Instance_State.INITIALIZING:
      return "INITIALIZING";
    case Instance_State.REGISTERING:
      return "REGISTERING";
    case Instance_State.SUSPENDING:
      return "SUSPENDING";
    case Instance_State.SUSPENDED:
      return "SUSPENDED";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible disk types for notebook instances. */
export enum Instance_DiskType {
  /** DISK_TYPE_UNSPECIFIED - Disk type not set. */
  DISK_TYPE_UNSPECIFIED = 0,
  /** PD_STANDARD - Standard persistent disk type. */
  PD_STANDARD = 1,
  /** PD_SSD - SSD persistent disk type. */
  PD_SSD = 2,
  /** PD_BALANCED - Balanced persistent disk type. */
  PD_BALANCED = 3,
  /** PD_EXTREME - Extreme persistent disk type. */
  PD_EXTREME = 4,
  UNRECOGNIZED = -1,
}

export function instance_DiskTypeFromJSON(object: any): Instance_DiskType {
  switch (object) {
    case 0:
    case "DISK_TYPE_UNSPECIFIED":
      return Instance_DiskType.DISK_TYPE_UNSPECIFIED;
    case 1:
    case "PD_STANDARD":
      return Instance_DiskType.PD_STANDARD;
    case 2:
    case "PD_SSD":
      return Instance_DiskType.PD_SSD;
    case 3:
    case "PD_BALANCED":
      return Instance_DiskType.PD_BALANCED;
    case 4:
    case "PD_EXTREME":
      return Instance_DiskType.PD_EXTREME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_DiskType.UNRECOGNIZED;
  }
}

export function instance_DiskTypeToJSON(object: Instance_DiskType): string {
  switch (object) {
    case Instance_DiskType.DISK_TYPE_UNSPECIFIED:
      return "DISK_TYPE_UNSPECIFIED";
    case Instance_DiskType.PD_STANDARD:
      return "PD_STANDARD";
    case Instance_DiskType.PD_SSD:
      return "PD_SSD";
    case Instance_DiskType.PD_BALANCED:
      return "PD_BALANCED";
    case Instance_DiskType.PD_EXTREME:
      return "PD_EXTREME";
    case Instance_DiskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Definition of the disk encryption options. */
export enum Instance_DiskEncryption {
  /** DISK_ENCRYPTION_UNSPECIFIED - Disk encryption is not specified. */
  DISK_ENCRYPTION_UNSPECIFIED = 0,
  /** GMEK - Use Google managed encryption keys to encrypt the boot disk. */
  GMEK = 1,
  /** CMEK - Use customer managed encryption keys to encrypt the boot disk. */
  CMEK = 2,
  UNRECOGNIZED = -1,
}

export function instance_DiskEncryptionFromJSON(object: any): Instance_DiskEncryption {
  switch (object) {
    case 0:
    case "DISK_ENCRYPTION_UNSPECIFIED":
      return Instance_DiskEncryption.DISK_ENCRYPTION_UNSPECIFIED;
    case 1:
    case "GMEK":
      return Instance_DiskEncryption.GMEK;
    case 2:
    case "CMEK":
      return Instance_DiskEncryption.CMEK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_DiskEncryption.UNRECOGNIZED;
  }
}

export function instance_DiskEncryptionToJSON(object: Instance_DiskEncryption): string {
  switch (object) {
    case Instance_DiskEncryption.DISK_ENCRYPTION_UNSPECIFIED:
      return "DISK_ENCRYPTION_UNSPECIFIED";
    case Instance_DiskEncryption.GMEK:
      return "GMEK";
    case Instance_DiskEncryption.CMEK:
      return "CMEK";
    case Instance_DiskEncryption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The type of vNIC driver.
 * Default should be UNSPECIFIED_NIC_TYPE.
 */
export enum Instance_NicType {
  /** UNSPECIFIED_NIC_TYPE - No type specified. */
  UNSPECIFIED_NIC_TYPE = 0,
  /** VIRTIO_NET - VIRTIO */
  VIRTIO_NET = 1,
  /** GVNIC - GVNIC */
  GVNIC = 2,
  UNRECOGNIZED = -1,
}

export function instance_NicTypeFromJSON(object: any): Instance_NicType {
  switch (object) {
    case 0:
    case "UNSPECIFIED_NIC_TYPE":
      return Instance_NicType.UNSPECIFIED_NIC_TYPE;
    case 1:
    case "VIRTIO_NET":
      return Instance_NicType.VIRTIO_NET;
    case 2:
    case "GVNIC":
      return Instance_NicType.GVNIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_NicType.UNRECOGNIZED;
  }
}

export function instance_NicTypeToJSON(object: Instance_NicType): string {
  switch (object) {
    case Instance_NicType.UNSPECIFIED_NIC_TYPE:
      return "UNSPECIFIED_NIC_TYPE";
    case Instance_NicType.VIRTIO_NET:
      return "VIRTIO_NET";
    case Instance_NicType.GVNIC:
      return "GVNIC";
    case Instance_NicType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Definition of a hardware accelerator. Note that not all combinations
 * of `type` and `core_count` are valid. See [GPUs on Compute
 * Engine](https://cloud.google.com/compute/docs/gpus/#gpus-list) to find a
 * valid combination. TPUs are not supported.
 */
export interface Instance_AcceleratorConfig {
  /** Type of this accelerator. */
  type: Instance_AcceleratorType;
  /** Count of cores of this accelerator. */
  coreCount: Long;
}

/** An instance-attached disk resource. */
export interface Instance_Disk {
  /**
   * Indicates whether the disk will be auto-deleted when the instance is
   * deleted (but not when the disk is detached from the instance).
   */
  autoDelete: boolean;
  /**
   * Indicates that this is a boot disk. The virtual machine will use the
   * first partition of the disk for its root filesystem.
   */
  boot: boolean;
  /**
   * Indicates a unique device name of your choice that is reflected into the
   * `/dev/disk/by-id/google-*` tree of a Linux operating system running
   * within the instance. This name can be used to reference the device for
   * mounting, resizing, and so on, from within the instance.
   *
   * If not specified, the server chooses a default device name to apply to
   * this disk, in the form persistent-disk-x, where x is a number assigned by
   * Google Compute Engine.This field is only applicable for persistent disks.
   */
  deviceName: string;
  /** Indicates the size of the disk in base-2 GB. */
  diskSizeGb: Long;
  /**
   * Indicates a list of features to enable on the guest operating system.
   * Applicable only for bootable images. Read  Enabling guest operating
   * system features to see a list of available options.
   */
  guestOsFeatures: Instance_Disk_GuestOsFeature[];
  /**
   * A zero-based index to this disk, where 0 is reserved for the
   * boot disk. If you have many disks attached to an instance, each disk
   * would have a unique index number.
   */
  index: Long;
  /**
   * Indicates the disk interface to use for attaching this disk, which is
   * either SCSI or NVME. The default is SCSI. Persistent disks must always
   * use SCSI and the request will fail if you attempt to attach a persistent
   * disk in any other format than SCSI. Local SSDs can use either NVME or
   * SCSI. For performance characteristics of SCSI over NVMe, see Local SSD
   * performance.
   * Valid values:
   *
   * * `NVME`
   * * `SCSI`
   */
  interface: string;
  /**
   * Type of the resource. Always compute#attachedDisk for attached
   * disks.
   */
  kind: string;
  /**
   * A list of publicly visible licenses. Reserved for Google's use.
   * A License represents billing and aggregate usage data for public
   * and marketplace images.
   */
  licenses: string[];
  /**
   * The mode in which to attach this disk, either `READ_WRITE` or
   * `READ_ONLY`. If not specified, the default is to attach the disk in
   * `READ_WRITE` mode. Valid values:
   *
   * * `READ_ONLY`
   * * `READ_WRITE`
   */
  mode: string;
  /**
   * Indicates a valid partial or full URL to an existing Persistent Disk
   * resource.
   */
  source: string;
  /**
   * Indicates the type of the disk, either `SCRATCH` or `PERSISTENT`.
   * Valid values:
   *
   * * `PERSISTENT`
   * * `SCRATCH`
   */
  type: string;
}

/** Guest OS features for boot disk. */
export interface Instance_Disk_GuestOsFeature {
  /**
   * The ID of a supported feature. Read  Enabling guest operating system
   * features to see a list of available options.
   * Valid values:
   *
   * * `FEATURE_TYPE_UNSPECIFIED`
   * * `MULTI_IP_SUBNET`
   * * `SECURE_BOOT`
   * * `UEFI_COMPATIBLE`
   * * `VIRTIO_SCSI_MULTIQUEUE`
   * * `WINDOWS`
   */
  type: string;
}

/**
 * A set of Shielded Instance options.
 * See [Images using supported Shielded VM
 * features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
 * Not all combinations are valid.
 */
export interface Instance_ShieldedInstanceConfig {
  /**
   * Defines whether the instance has Secure Boot enabled.
   *
   * Secure Boot helps ensure that the system only runs authentic software by
   * verifying the digital signature of all boot components, and halting the
   * boot process if signature verification fails. Disabled by default.
   */
  enableSecureBoot: boolean;
  /** Defines whether the instance has the vTPM enabled. Enabled by default. */
  enableVtpm: boolean;
  /**
   * Defines whether the instance has integrity monitoring enabled.
   *
   * Enables monitoring and attestation of the boot integrity of the instance.
   * The attestation is performed against the integrity policy baseline. This
   * baseline is initially derived from the implicitly trusted boot image when
   * the instance is created. Enabled by default.
   */
  enableIntegrityMonitoring: boolean;
}

/** The entry of VM image upgrade history. */
export interface Instance_UpgradeHistoryEntry {
  /** The snapshot of the boot disk of this notebook instance before upgrade. */
  snapshot: string;
  /** The VM image before this instance upgrade. */
  vmImage: string;
  /** The container image before this instance upgrade. */
  containerImage: string;
  /** The framework of this notebook instance. */
  framework: string;
  /** The version of the notebook instance before this upgrade. */
  version: string;
  /** The state of this instance upgrade history entry. */
  state: Instance_UpgradeHistoryEntry_State;
  /** The time that this instance upgrade history entry is created. */
  createTime?:
    | Date
    | undefined;
  /** Target VM Image. Format: `ainotebooks-vm/project/image-name/name`. */
  targetImage: string;
  /** Action. Rolloback or Upgrade. */
  action: Instance_UpgradeHistoryEntry_Action;
  /** Target VM Version, like m63. */
  targetVersion: string;
}

/** The definition of the states of this upgrade history entry. */
export enum Instance_UpgradeHistoryEntry_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTED - The instance upgrade is started. */
  STARTED = 1,
  /** SUCCEEDED - The instance upgrade is succeeded. */
  SUCCEEDED = 2,
  /** FAILED - The instance upgrade is failed. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function instance_UpgradeHistoryEntry_StateFromJSON(object: any): Instance_UpgradeHistoryEntry_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_UpgradeHistoryEntry_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTED":
      return Instance_UpgradeHistoryEntry_State.STARTED;
    case 2:
    case "SUCCEEDED":
      return Instance_UpgradeHistoryEntry_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return Instance_UpgradeHistoryEntry_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_UpgradeHistoryEntry_State.UNRECOGNIZED;
  }
}

export function instance_UpgradeHistoryEntry_StateToJSON(object: Instance_UpgradeHistoryEntry_State): string {
  switch (object) {
    case Instance_UpgradeHistoryEntry_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_UpgradeHistoryEntry_State.STARTED:
      return "STARTED";
    case Instance_UpgradeHistoryEntry_State.SUCCEEDED:
      return "SUCCEEDED";
    case Instance_UpgradeHistoryEntry_State.FAILED:
      return "FAILED";
    case Instance_UpgradeHistoryEntry_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of operations of this upgrade history entry. */
export enum Instance_UpgradeHistoryEntry_Action {
  /** ACTION_UNSPECIFIED - Operation is not specified. */
  ACTION_UNSPECIFIED = 0,
  /** UPGRADE - Upgrade. */
  UPGRADE = 1,
  /** ROLLBACK - Rollback. */
  ROLLBACK = 2,
  UNRECOGNIZED = -1,
}

export function instance_UpgradeHistoryEntry_ActionFromJSON(object: any): Instance_UpgradeHistoryEntry_Action {
  switch (object) {
    case 0:
    case "ACTION_UNSPECIFIED":
      return Instance_UpgradeHistoryEntry_Action.ACTION_UNSPECIFIED;
    case 1:
    case "UPGRADE":
      return Instance_UpgradeHistoryEntry_Action.UPGRADE;
    case 2:
    case "ROLLBACK":
      return Instance_UpgradeHistoryEntry_Action.ROLLBACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_UpgradeHistoryEntry_Action.UNRECOGNIZED;
  }
}

export function instance_UpgradeHistoryEntry_ActionToJSON(object: Instance_UpgradeHistoryEntry_Action): string {
  switch (object) {
    case Instance_UpgradeHistoryEntry_Action.ACTION_UNSPECIFIED:
      return "ACTION_UNSPECIFIED";
    case Instance_UpgradeHistoryEntry_Action.UPGRADE:
      return "UPGRADE";
    case Instance_UpgradeHistoryEntry_Action.ROLLBACK:
      return "ROLLBACK";
    case Instance_UpgradeHistoryEntry_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

export interface Instance_MetadataEntry {
  key: string;
  value: string;
}

/** The definition of a schedule. */
export interface Schedule {
  /**
   * Output only. The name of this schedule. Format:
   * `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
   */
  name: string;
  /**
   * Output only. Display name used for UI purposes.
   * Name can only contain alphanumeric characters, hyphens `-`,
   * and underscores `_`.
   */
  displayName: string;
  /** A brief description of this environment. */
  description: string;
  state: Schedule_State;
  /**
   * Cron-tab formatted schedule by which the job will execute.
   * Format: minute, hour, day of month, month, day of week,
   * e.g. `0 0 * * WED` = every Wednesday
   * More examples: https://crontab.guru/examples.html
   */
  cronSchedule: string;
  /**
   * Timezone on which the cron_schedule.
   * The value of this field must be a time zone name from the tz database.
   * TZ Database: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
   *
   * Note that some time zones include a provision for daylight savings time.
   * The rules for daylight saving time are determined by the chosen tz.
   * For UTC use the string "utc". If a time zone is not specified,
   * the default will be in UTC (also known as GMT).
   */
  timeZone: string;
  /** Output only. Time the schedule was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. Time the schedule was last updated. */
  updateTime?:
    | Date
    | undefined;
  /** Notebook Execution Template corresponding to this schedule. */
  executionTemplate?:
    | ExecutionTemplate
    | undefined;
  /**
   * Output only. The most recent execution names triggered from this schedule
   * and their corresponding states.
   */
  recentExecutions: Execution[];
}

/** State of the job. */
export enum Schedule_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** ENABLED - The job is executing normally. */
  ENABLED = 1,
  /**
   * PAUSED - The job is paused by the user. It will not execute. A user can
   * intentionally pause the job using
   * [PauseJobRequest][].
   */
  PAUSED = 2,
  /**
   * DISABLED - The job is disabled by the system due to error. The user
   * cannot directly set a job to be disabled.
   */
  DISABLED = 3,
  /**
   * UPDATE_FAILED - The job state resulting from a failed [CloudScheduler.UpdateJob][]
   * operation. To recover a job from this state, retry
   * [CloudScheduler.UpdateJob][] until a successful response is received.
   */
  UPDATE_FAILED = 4,
  /** INITIALIZING - The schedule resource is being created. */
  INITIALIZING = 5,
  /** DELETING - The schedule resource is being deleted. */
  DELETING = 6,
  UNRECOGNIZED = -1,
}

export function schedule_StateFromJSON(object: any): Schedule_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Schedule_State.STATE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return Schedule_State.ENABLED;
    case 2:
    case "PAUSED":
      return Schedule_State.PAUSED;
    case 3:
    case "DISABLED":
      return Schedule_State.DISABLED;
    case 4:
    case "UPDATE_FAILED":
      return Schedule_State.UPDATE_FAILED;
    case 5:
    case "INITIALIZING":
      return Schedule_State.INITIALIZING;
    case 6:
    case "DELETING":
      return Schedule_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Schedule_State.UNRECOGNIZED;
  }
}

export function schedule_StateToJSON(object: Schedule_State): string {
  switch (object) {
    case Schedule_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Schedule_State.ENABLED:
      return "ENABLED";
    case Schedule_State.PAUSED:
      return "PAUSED";
    case Schedule_State.DISABLED:
      return "DISABLED";
    case Schedule_State.UPDATE_FAILED:
      return "UPDATE_FAILED";
    case Schedule_State.INITIALIZING:
      return "INITIALIZING";
    case Schedule_State.DELETING:
      return "DELETING";
    case Schedule_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The data within all Runtime events. */
export interface RuntimeEventData {
  /** Optional. The Runtime event payload. Unset for deletion events. */
  payload?: Runtime | undefined;
}

/** The data within all Execution events. */
export interface ExecutionEventData {
  /** Optional. The Execution event payload. Unset for deletion events. */
  payload?: Execution | undefined;
}

/** The data within all Instance events. */
export interface InstanceEventData {
  /** Optional. The Instance event payload. Unset for deletion events. */
  payload?: Instance | undefined;
}

/** The data within all Schedule events. */
export interface ScheduleEventData {
  /** Optional. The Schedule event payload. Unset for deletion events. */
  payload?: Schedule | undefined;
}

/** The data within all Environment events. */
export interface EnvironmentEventData {
  /** Optional. The Environment event payload. Unset for deletion events. */
  payload?: Environment | undefined;
}

function createBaseEnvironment(): Environment {
  return {
    name: "",
    displayName: "",
    description: "",
    vmImage: undefined,
    containerImage: undefined,
    postStartupScript: "",
    createTime: undefined,
  };
}

export const Environment: MessageFns<Environment> = {
  encode(message: Environment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.vmImage !== undefined) {
      VmImage.encode(message.vmImage, writer.uint32(50).fork()).join();
    }
    if (message.containerImage !== undefined) {
      ContainerImage.encode(message.containerImage, writer.uint32(58).fork()).join();
    }
    if (message.postStartupScript !== "") {
      writer.uint32(66).string(message.postStartupScript);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.vmImage = VmImage.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.containerImage = ContainerImage.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.postStartupScript = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      vmImage: isSet(object.vmImage) ? VmImage.fromJSON(object.vmImage) : undefined,
      containerImage: isSet(object.containerImage) ? ContainerImage.fromJSON(object.containerImage) : undefined,
      postStartupScript: isSet(object.postStartupScript) ? globalThis.String(object.postStartupScript) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: Environment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.vmImage !== undefined) {
      obj.vmImage = VmImage.toJSON(message.vmImage);
    }
    if (message.containerImage !== undefined) {
      obj.containerImage = ContainerImage.toJSON(message.containerImage);
    }
    if (message.postStartupScript !== "") {
      obj.postStartupScript = message.postStartupScript;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Environment>, I>>(base?: I): Environment {
    return Environment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Environment>, I>>(object: I): Environment {
    const message = createBaseEnvironment();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.vmImage = (object.vmImage !== undefined && object.vmImage !== null)
      ? VmImage.fromPartial(object.vmImage)
      : undefined;
    message.containerImage = (object.containerImage !== undefined && object.containerImage !== null)
      ? ContainerImage.fromPartial(object.containerImage)
      : undefined;
    message.postStartupScript = object.postStartupScript ?? "";
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseVmImage(): VmImage {
  return { project: "", imageName: undefined, imageFamily: undefined };
}

export const VmImage: MessageFns<VmImage> = {
  encode(message: VmImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.imageName !== undefined) {
      writer.uint32(18).string(message.imageName);
    }
    if (message.imageFamily !== undefined) {
      writer.uint32(26).string(message.imageFamily);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.imageName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.imageFamily = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmImage {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      imageName: isSet(object.imageName) ? globalThis.String(object.imageName) : undefined,
      imageFamily: isSet(object.imageFamily) ? globalThis.String(object.imageFamily) : undefined,
    };
  },

  toJSON(message: VmImage): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.imageName !== undefined) {
      obj.imageName = message.imageName;
    }
    if (message.imageFamily !== undefined) {
      obj.imageFamily = message.imageFamily;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VmImage>, I>>(base?: I): VmImage {
    return VmImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VmImage>, I>>(object: I): VmImage {
    const message = createBaseVmImage();
    message.project = object.project ?? "";
    message.imageName = object.imageName ?? undefined;
    message.imageFamily = object.imageFamily ?? undefined;
    return message;
  },
};

function createBaseContainerImage(): ContainerImage {
  return { repository: "", tag: "" };
}

export const ContainerImage: MessageFns<ContainerImage> = {
  encode(message: ContainerImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repository !== "") {
      writer.uint32(10).string(message.repository);
    }
    if (message.tag !== "") {
      writer.uint32(18).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.repository = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerImage {
    return {
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: ContainerImage): unknown {
    const obj: any = {};
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerImage>, I>>(base?: I): ContainerImage {
    return ContainerImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerImage>, I>>(object: I): ContainerImage {
    const message = createBaseContainerImage();
    message.repository = object.repository ?? "";
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseRuntime(): Runtime {
  return {
    name: "",
    virtualMachine: undefined,
    state: 0,
    healthState: 0,
    accessConfig: undefined,
    softwareConfig: undefined,
    metrics: undefined,
    createTime: undefined,
    updateTime: undefined,
    labels: {},
  };
}

export const Runtime: MessageFns<Runtime> = {
  encode(message: Runtime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.virtualMachine !== undefined) {
      VirtualMachine.encode(message.virtualMachine, writer.uint32(18).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.healthState !== 0) {
      writer.uint32(32).int32(message.healthState);
    }
    if (message.accessConfig !== undefined) {
      RuntimeAccessConfig.encode(message.accessConfig, writer.uint32(42).fork()).join();
    }
    if (message.softwareConfig !== undefined) {
      RuntimeSoftwareConfig.encode(message.softwareConfig, writer.uint32(50).fork()).join();
    }
    if (message.metrics !== undefined) {
      RuntimeMetrics.encode(message.metrics, writer.uint32(58).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(162).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(170).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Runtime_LabelsEntry.encode({ key: key as any, value }, writer.uint32(186).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runtime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.virtualMachine = VirtualMachine.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.healthState = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accessConfig = RuntimeAccessConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.softwareConfig = RuntimeSoftwareConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metrics = RuntimeMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          const entry23 = Runtime_LabelsEntry.decode(reader, reader.uint32());
          if (entry23.value !== undefined) {
            message.labels[entry23.key] = entry23.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runtime {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      virtualMachine: isSet(object.virtualMachine) ? VirtualMachine.fromJSON(object.virtualMachine) : undefined,
      state: isSet(object.state) ? runtime_StateFromJSON(object.state) : 0,
      healthState: isSet(object.healthState) ? runtime_HealthStateFromJSON(object.healthState) : 0,
      accessConfig: isSet(object.accessConfig) ? RuntimeAccessConfig.fromJSON(object.accessConfig) : undefined,
      softwareConfig: isSet(object.softwareConfig) ? RuntimeSoftwareConfig.fromJSON(object.softwareConfig) : undefined,
      metrics: isSet(object.metrics) ? RuntimeMetrics.fromJSON(object.metrics) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Runtime): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.virtualMachine !== undefined) {
      obj.virtualMachine = VirtualMachine.toJSON(message.virtualMachine);
    }
    if (message.state !== 0) {
      obj.state = runtime_StateToJSON(message.state);
    }
    if (message.healthState !== 0) {
      obj.healthState = runtime_HealthStateToJSON(message.healthState);
    }
    if (message.accessConfig !== undefined) {
      obj.accessConfig = RuntimeAccessConfig.toJSON(message.accessConfig);
    }
    if (message.softwareConfig !== undefined) {
      obj.softwareConfig = RuntimeSoftwareConfig.toJSON(message.softwareConfig);
    }
    if (message.metrics !== undefined) {
      obj.metrics = RuntimeMetrics.toJSON(message.metrics);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Runtime>, I>>(base?: I): Runtime {
    return Runtime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Runtime>, I>>(object: I): Runtime {
    const message = createBaseRuntime();
    message.name = object.name ?? "";
    message.virtualMachine = (object.virtualMachine !== undefined && object.virtualMachine !== null)
      ? VirtualMachine.fromPartial(object.virtualMachine)
      : undefined;
    message.state = object.state ?? 0;
    message.healthState = object.healthState ?? 0;
    message.accessConfig = (object.accessConfig !== undefined && object.accessConfig !== null)
      ? RuntimeAccessConfig.fromPartial(object.accessConfig)
      : undefined;
    message.softwareConfig = (object.softwareConfig !== undefined && object.softwareConfig !== null)
      ? RuntimeSoftwareConfig.fromPartial(object.softwareConfig)
      : undefined;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? RuntimeMetrics.fromPartial(object.metrics)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRuntime_LabelsEntry(): Runtime_LabelsEntry {
  return { key: "", value: "" };
}

export const Runtime_LabelsEntry: MessageFns<Runtime_LabelsEntry> = {
  encode(message: Runtime_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runtime_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntime_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runtime_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Runtime_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Runtime_LabelsEntry>, I>>(base?: I): Runtime_LabelsEntry {
    return Runtime_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Runtime_LabelsEntry>, I>>(object: I): Runtime_LabelsEntry {
    const message = createBaseRuntime_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRuntimeAcceleratorConfig(): RuntimeAcceleratorConfig {
  return { type: 0, coreCount: Long.ZERO };
}

export const RuntimeAcceleratorConfig: MessageFns<RuntimeAcceleratorConfig> = {
  encode(message: RuntimeAcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.coreCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeAcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeAcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.coreCount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeAcceleratorConfig {
    return {
      type: isSet(object.type) ? runtimeAcceleratorConfig_AcceleratorTypeFromJSON(object.type) : 0,
      coreCount: isSet(object.coreCount) ? Long.fromValue(object.coreCount) : Long.ZERO,
    };
  },

  toJSON(message: RuntimeAcceleratorConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = runtimeAcceleratorConfig_AcceleratorTypeToJSON(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      obj.coreCount = (message.coreCount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeAcceleratorConfig>, I>>(base?: I): RuntimeAcceleratorConfig {
    return RuntimeAcceleratorConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeAcceleratorConfig>, I>>(object: I): RuntimeAcceleratorConfig {
    const message = createBaseRuntimeAcceleratorConfig();
    message.type = object.type ?? 0;
    message.coreCount = (object.coreCount !== undefined && object.coreCount !== null)
      ? Long.fromValue(object.coreCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseEncryptionConfig(): EncryptionConfig {
  return { kmsKey: "" };
}

export const EncryptionConfig: MessageFns<EncryptionConfig> = {
  encode(message: EncryptionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kmsKey !== "") {
      writer.uint32(10).string(message.kmsKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptionConfig {
    return { kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "" };
  },

  toJSON(message: EncryptionConfig): unknown {
    const obj: any = {};
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncryptionConfig>, I>>(base?: I): EncryptionConfig {
    return EncryptionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncryptionConfig>, I>>(object: I): EncryptionConfig {
    const message = createBaseEncryptionConfig();
    message.kmsKey = object.kmsKey ?? "";
    return message;
  },
};

function createBaseLocalDisk(): LocalDisk {
  return {
    autoDelete: false,
    boot: false,
    deviceName: "",
    guestOsFeatures: [],
    index: 0,
    interface: "",
    kind: "",
    licenses: [],
    mode: "",
    source: "",
    type: "",
  };
}

export const LocalDisk: MessageFns<LocalDisk> = {
  encode(message: LocalDisk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoDelete !== false) {
      writer.uint32(8).bool(message.autoDelete);
    }
    if (message.boot !== false) {
      writer.uint32(16).bool(message.boot);
    }
    if (message.deviceName !== "") {
      writer.uint32(26).string(message.deviceName);
    }
    for (const v of message.guestOsFeatures) {
      LocalDisk_RuntimeGuestOsFeature.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.index !== 0) {
      writer.uint32(40).int32(message.index);
    }
    if (message.interface !== "") {
      writer.uint32(58).string(message.interface);
    }
    if (message.kind !== "") {
      writer.uint32(66).string(message.kind);
    }
    for (const v of message.licenses) {
      writer.uint32(74).string(v!);
    }
    if (message.mode !== "") {
      writer.uint32(82).string(message.mode);
    }
    if (message.source !== "") {
      writer.uint32(90).string(message.source);
    }
    if (message.type !== "") {
      writer.uint32(98).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.autoDelete = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boot = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.guestOsFeatures.push(LocalDisk_RuntimeGuestOsFeature.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.interface = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.licenses.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalDisk {
    return {
      autoDelete: isSet(object.autoDelete) ? globalThis.Boolean(object.autoDelete) : false,
      boot: isSet(object.boot) ? globalThis.Boolean(object.boot) : false,
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : "",
      guestOsFeatures: globalThis.Array.isArray(object?.guestOsFeatures)
        ? object.guestOsFeatures.map((e: any) => LocalDisk_RuntimeGuestOsFeature.fromJSON(e))
        : [],
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      interface: isSet(object.interface) ? globalThis.String(object.interface) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      licenses: globalThis.Array.isArray(object?.licenses) ? object.licenses.map((e: any) => globalThis.String(e)) : [],
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: LocalDisk): unknown {
    const obj: any = {};
    if (message.autoDelete !== false) {
      obj.autoDelete = message.autoDelete;
    }
    if (message.boot !== false) {
      obj.boot = message.boot;
    }
    if (message.deviceName !== "") {
      obj.deviceName = message.deviceName;
    }
    if (message.guestOsFeatures?.length) {
      obj.guestOsFeatures = message.guestOsFeatures.map((e) => LocalDisk_RuntimeGuestOsFeature.toJSON(e));
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.interface !== "") {
      obj.interface = message.interface;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.licenses?.length) {
      obj.licenses = message.licenses;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalDisk>, I>>(base?: I): LocalDisk {
    return LocalDisk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalDisk>, I>>(object: I): LocalDisk {
    const message = createBaseLocalDisk();
    message.autoDelete = object.autoDelete ?? false;
    message.boot = object.boot ?? false;
    message.deviceName = object.deviceName ?? "";
    message.guestOsFeatures = object.guestOsFeatures?.map((e) => LocalDisk_RuntimeGuestOsFeature.fromPartial(e)) || [];
    message.index = object.index ?? 0;
    message.interface = object.interface ?? "";
    message.kind = object.kind ?? "";
    message.licenses = object.licenses?.map((e) => e) || [];
    message.mode = object.mode ?? "";
    message.source = object.source ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseLocalDisk_RuntimeGuestOsFeature(): LocalDisk_RuntimeGuestOsFeature {
  return { type: "" };
}

export const LocalDisk_RuntimeGuestOsFeature: MessageFns<LocalDisk_RuntimeGuestOsFeature> = {
  encode(message: LocalDisk_RuntimeGuestOsFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalDisk_RuntimeGuestOsFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalDisk_RuntimeGuestOsFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalDisk_RuntimeGuestOsFeature {
    return { type: isSet(object.type) ? globalThis.String(object.type) : "" };
  },

  toJSON(message: LocalDisk_RuntimeGuestOsFeature): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalDisk_RuntimeGuestOsFeature>, I>>(base?: I): LocalDisk_RuntimeGuestOsFeature {
    return LocalDisk_RuntimeGuestOsFeature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalDisk_RuntimeGuestOsFeature>, I>>(
    object: I,
  ): LocalDisk_RuntimeGuestOsFeature {
    const message = createBaseLocalDisk_RuntimeGuestOsFeature();
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseLocalDiskInitializeParams(): LocalDiskInitializeParams {
  return { description: "", diskName: "", diskSizeGb: Long.ZERO, labels: {} };
}

export const LocalDiskInitializeParams: MessageFns<LocalDiskInitializeParams> = {
  encode(message: LocalDiskInitializeParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.diskName !== "") {
      writer.uint32(18).string(message.diskName);
    }
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.diskSizeGb.toString());
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      LocalDiskInitializeParams_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalDiskInitializeParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalDiskInitializeParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diskName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.diskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = LocalDiskInitializeParams_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalDiskInitializeParams {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      diskName: isSet(object.diskName) ? globalThis.String(object.diskName) : "",
      diskSizeGb: isSet(object.diskSizeGb) ? Long.fromValue(object.diskSizeGb) : Long.ZERO,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LocalDiskInitializeParams): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.diskName !== "") {
      obj.diskName = message.diskName;
    }
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      obj.diskSizeGb = (message.diskSizeGb || Long.ZERO).toString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalDiskInitializeParams>, I>>(base?: I): LocalDiskInitializeParams {
    return LocalDiskInitializeParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalDiskInitializeParams>, I>>(object: I): LocalDiskInitializeParams {
    const message = createBaseLocalDiskInitializeParams();
    message.description = object.description ?? "";
    message.diskName = object.diskName ?? "";
    message.diskSizeGb = (object.diskSizeGb !== undefined && object.diskSizeGb !== null)
      ? Long.fromValue(object.diskSizeGb)
      : Long.ZERO;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseLocalDiskInitializeParams_LabelsEntry(): LocalDiskInitializeParams_LabelsEntry {
  return { key: "", value: "" };
}

export const LocalDiskInitializeParams_LabelsEntry: MessageFns<LocalDiskInitializeParams_LabelsEntry> = {
  encode(message: LocalDiskInitializeParams_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalDiskInitializeParams_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalDiskInitializeParams_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalDiskInitializeParams_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LocalDiskInitializeParams_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalDiskInitializeParams_LabelsEntry>, I>>(
    base?: I,
  ): LocalDiskInitializeParams_LabelsEntry {
    return LocalDiskInitializeParams_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalDiskInitializeParams_LabelsEntry>, I>>(
    object: I,
  ): LocalDiskInitializeParams_LabelsEntry {
    const message = createBaseLocalDiskInitializeParams_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRuntimeAccessConfig(): RuntimeAccessConfig {
  return { accessType: 0, runtimeOwner: "", proxyUri: "" };
}

export const RuntimeAccessConfig: MessageFns<RuntimeAccessConfig> = {
  encode(message: RuntimeAccessConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessType !== 0) {
      writer.uint32(8).int32(message.accessType);
    }
    if (message.runtimeOwner !== "") {
      writer.uint32(18).string(message.runtimeOwner);
    }
    if (message.proxyUri !== "") {
      writer.uint32(26).string(message.proxyUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeAccessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeAccessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accessType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtimeOwner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proxyUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeAccessConfig {
    return {
      accessType: isSet(object.accessType) ? runtimeAccessConfig_RuntimeAccessTypeFromJSON(object.accessType) : 0,
      runtimeOwner: isSet(object.runtimeOwner) ? globalThis.String(object.runtimeOwner) : "",
      proxyUri: isSet(object.proxyUri) ? globalThis.String(object.proxyUri) : "",
    };
  },

  toJSON(message: RuntimeAccessConfig): unknown {
    const obj: any = {};
    if (message.accessType !== 0) {
      obj.accessType = runtimeAccessConfig_RuntimeAccessTypeToJSON(message.accessType);
    }
    if (message.runtimeOwner !== "") {
      obj.runtimeOwner = message.runtimeOwner;
    }
    if (message.proxyUri !== "") {
      obj.proxyUri = message.proxyUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeAccessConfig>, I>>(base?: I): RuntimeAccessConfig {
    return RuntimeAccessConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeAccessConfig>, I>>(object: I): RuntimeAccessConfig {
    const message = createBaseRuntimeAccessConfig();
    message.accessType = object.accessType ?? 0;
    message.runtimeOwner = object.runtimeOwner ?? "";
    message.proxyUri = object.proxyUri ?? "";
    return message;
  },
};

function createBaseRuntimeSoftwareConfig(): RuntimeSoftwareConfig {
  return {
    notebookUpgradeSchedule: "",
    enableHealthMonitoring: undefined,
    idleShutdown: undefined,
    idleShutdownTimeout: 0,
    installGpuDriver: false,
    customGpuDriverPath: "",
    postStartupScript: "",
    kernels: [],
    upgradeable: undefined,
    postStartupScriptBehavior: 0,
    disableTerminal: undefined,
    version: undefined,
    mixerDisabled: undefined,
  };
}

export const RuntimeSoftwareConfig: MessageFns<RuntimeSoftwareConfig> = {
  encode(message: RuntimeSoftwareConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notebookUpgradeSchedule !== "") {
      writer.uint32(10).string(message.notebookUpgradeSchedule);
    }
    if (message.enableHealthMonitoring !== undefined) {
      writer.uint32(16).bool(message.enableHealthMonitoring);
    }
    if (message.idleShutdown !== undefined) {
      writer.uint32(24).bool(message.idleShutdown);
    }
    if (message.idleShutdownTimeout !== 0) {
      writer.uint32(32).int32(message.idleShutdownTimeout);
    }
    if (message.installGpuDriver !== false) {
      writer.uint32(40).bool(message.installGpuDriver);
    }
    if (message.customGpuDriverPath !== "") {
      writer.uint32(50).string(message.customGpuDriverPath);
    }
    if (message.postStartupScript !== "") {
      writer.uint32(58).string(message.postStartupScript);
    }
    for (const v of message.kernels) {
      ContainerImage.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.upgradeable !== undefined) {
      writer.uint32(72).bool(message.upgradeable);
    }
    if (message.postStartupScriptBehavior !== 0) {
      writer.uint32(80).int32(message.postStartupScriptBehavior);
    }
    if (message.disableTerminal !== undefined) {
      writer.uint32(88).bool(message.disableTerminal);
    }
    if (message.version !== undefined) {
      writer.uint32(98).string(message.version);
    }
    if (message.mixerDisabled !== undefined) {
      writer.uint32(104).bool(message.mixerDisabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeSoftwareConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeSoftwareConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notebookUpgradeSchedule = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableHealthMonitoring = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.idleShutdown = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.idleShutdownTimeout = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.installGpuDriver = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.customGpuDriverPath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.postStartupScript = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.kernels.push(ContainerImage.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.upgradeable = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.postStartupScriptBehavior = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.disableTerminal = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.mixerDisabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeSoftwareConfig {
    return {
      notebookUpgradeSchedule: isSet(object.notebookUpgradeSchedule)
        ? globalThis.String(object.notebookUpgradeSchedule)
        : "",
      enableHealthMonitoring: isSet(object.enableHealthMonitoring)
        ? globalThis.Boolean(object.enableHealthMonitoring)
        : undefined,
      idleShutdown: isSet(object.idleShutdown) ? globalThis.Boolean(object.idleShutdown) : undefined,
      idleShutdownTimeout: isSet(object.idleShutdownTimeout) ? globalThis.Number(object.idleShutdownTimeout) : 0,
      installGpuDriver: isSet(object.installGpuDriver) ? globalThis.Boolean(object.installGpuDriver) : false,
      customGpuDriverPath: isSet(object.customGpuDriverPath) ? globalThis.String(object.customGpuDriverPath) : "",
      postStartupScript: isSet(object.postStartupScript) ? globalThis.String(object.postStartupScript) : "",
      kernels: globalThis.Array.isArray(object?.kernels)
        ? object.kernels.map((e: any) => ContainerImage.fromJSON(e))
        : [],
      upgradeable: isSet(object.upgradeable) ? globalThis.Boolean(object.upgradeable) : undefined,
      postStartupScriptBehavior: isSet(object.postStartupScriptBehavior)
        ? runtimeSoftwareConfig_PostStartupScriptBehaviorFromJSON(object.postStartupScriptBehavior)
        : 0,
      disableTerminal: isSet(object.disableTerminal) ? globalThis.Boolean(object.disableTerminal) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      mixerDisabled: isSet(object.mixerDisabled) ? globalThis.Boolean(object.mixerDisabled) : undefined,
    };
  },

  toJSON(message: RuntimeSoftwareConfig): unknown {
    const obj: any = {};
    if (message.notebookUpgradeSchedule !== "") {
      obj.notebookUpgradeSchedule = message.notebookUpgradeSchedule;
    }
    if (message.enableHealthMonitoring !== undefined) {
      obj.enableHealthMonitoring = message.enableHealthMonitoring;
    }
    if (message.idleShutdown !== undefined) {
      obj.idleShutdown = message.idleShutdown;
    }
    if (message.idleShutdownTimeout !== 0) {
      obj.idleShutdownTimeout = Math.round(message.idleShutdownTimeout);
    }
    if (message.installGpuDriver !== false) {
      obj.installGpuDriver = message.installGpuDriver;
    }
    if (message.customGpuDriverPath !== "") {
      obj.customGpuDriverPath = message.customGpuDriverPath;
    }
    if (message.postStartupScript !== "") {
      obj.postStartupScript = message.postStartupScript;
    }
    if (message.kernels?.length) {
      obj.kernels = message.kernels.map((e) => ContainerImage.toJSON(e));
    }
    if (message.upgradeable !== undefined) {
      obj.upgradeable = message.upgradeable;
    }
    if (message.postStartupScriptBehavior !== 0) {
      obj.postStartupScriptBehavior = runtimeSoftwareConfig_PostStartupScriptBehaviorToJSON(
        message.postStartupScriptBehavior,
      );
    }
    if (message.disableTerminal !== undefined) {
      obj.disableTerminal = message.disableTerminal;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.mixerDisabled !== undefined) {
      obj.mixerDisabled = message.mixerDisabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeSoftwareConfig>, I>>(base?: I): RuntimeSoftwareConfig {
    return RuntimeSoftwareConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeSoftwareConfig>, I>>(object: I): RuntimeSoftwareConfig {
    const message = createBaseRuntimeSoftwareConfig();
    message.notebookUpgradeSchedule = object.notebookUpgradeSchedule ?? "";
    message.enableHealthMonitoring = object.enableHealthMonitoring ?? undefined;
    message.idleShutdown = object.idleShutdown ?? undefined;
    message.idleShutdownTimeout = object.idleShutdownTimeout ?? 0;
    message.installGpuDriver = object.installGpuDriver ?? false;
    message.customGpuDriverPath = object.customGpuDriverPath ?? "";
    message.postStartupScript = object.postStartupScript ?? "";
    message.kernels = object.kernels?.map((e) => ContainerImage.fromPartial(e)) || [];
    message.upgradeable = object.upgradeable ?? undefined;
    message.postStartupScriptBehavior = object.postStartupScriptBehavior ?? 0;
    message.disableTerminal = object.disableTerminal ?? undefined;
    message.version = object.version ?? undefined;
    message.mixerDisabled = object.mixerDisabled ?? undefined;
    return message;
  },
};

function createBaseRuntimeMetrics(): RuntimeMetrics {
  return { systemMetrics: {} };
}

export const RuntimeMetrics: MessageFns<RuntimeMetrics> = {
  encode(message: RuntimeMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.systemMetrics).forEach(([key, value]) => {
      RuntimeMetrics_SystemMetricsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = RuntimeMetrics_SystemMetricsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.systemMetrics[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeMetrics {
    return {
      systemMetrics: isObject(object.systemMetrics)
        ? Object.entries(object.systemMetrics).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RuntimeMetrics): unknown {
    const obj: any = {};
    if (message.systemMetrics) {
      const entries = Object.entries(message.systemMetrics);
      if (entries.length > 0) {
        obj.systemMetrics = {};
        entries.forEach(([k, v]) => {
          obj.systemMetrics[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeMetrics>, I>>(base?: I): RuntimeMetrics {
    return RuntimeMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeMetrics>, I>>(object: I): RuntimeMetrics {
    const message = createBaseRuntimeMetrics();
    message.systemMetrics = Object.entries(object.systemMetrics ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRuntimeMetrics_SystemMetricsEntry(): RuntimeMetrics_SystemMetricsEntry {
  return { key: "", value: "" };
}

export const RuntimeMetrics_SystemMetricsEntry: MessageFns<RuntimeMetrics_SystemMetricsEntry> = {
  encode(message: RuntimeMetrics_SystemMetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeMetrics_SystemMetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeMetrics_SystemMetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeMetrics_SystemMetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RuntimeMetrics_SystemMetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeMetrics_SystemMetricsEntry>, I>>(
    base?: I,
  ): RuntimeMetrics_SystemMetricsEntry {
    return RuntimeMetrics_SystemMetricsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeMetrics_SystemMetricsEntry>, I>>(
    object: I,
  ): RuntimeMetrics_SystemMetricsEntry {
    const message = createBaseRuntimeMetrics_SystemMetricsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRuntimeShieldedInstanceConfig(): RuntimeShieldedInstanceConfig {
  return { enableSecureBoot: false, enableVtpm: false, enableIntegrityMonitoring: false };
}

export const RuntimeShieldedInstanceConfig: MessageFns<RuntimeShieldedInstanceConfig> = {
  encode(message: RuntimeShieldedInstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSecureBoot !== false) {
      writer.uint32(8).bool(message.enableSecureBoot);
    }
    if (message.enableVtpm !== false) {
      writer.uint32(16).bool(message.enableVtpm);
    }
    if (message.enableIntegrityMonitoring !== false) {
      writer.uint32(24).bool(message.enableIntegrityMonitoring);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeShieldedInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeShieldedInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enableSecureBoot = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableVtpm = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enableIntegrityMonitoring = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeShieldedInstanceConfig {
    return {
      enableSecureBoot: isSet(object.enableSecureBoot) ? globalThis.Boolean(object.enableSecureBoot) : false,
      enableVtpm: isSet(object.enableVtpm) ? globalThis.Boolean(object.enableVtpm) : false,
      enableIntegrityMonitoring: isSet(object.enableIntegrityMonitoring)
        ? globalThis.Boolean(object.enableIntegrityMonitoring)
        : false,
    };
  },

  toJSON(message: RuntimeShieldedInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableSecureBoot !== false) {
      obj.enableSecureBoot = message.enableSecureBoot;
    }
    if (message.enableVtpm !== false) {
      obj.enableVtpm = message.enableVtpm;
    }
    if (message.enableIntegrityMonitoring !== false) {
      obj.enableIntegrityMonitoring = message.enableIntegrityMonitoring;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeShieldedInstanceConfig>, I>>(base?: I): RuntimeShieldedInstanceConfig {
    return RuntimeShieldedInstanceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeShieldedInstanceConfig>, I>>(
    object: I,
  ): RuntimeShieldedInstanceConfig {
    const message = createBaseRuntimeShieldedInstanceConfig();
    message.enableSecureBoot = object.enableSecureBoot ?? false;
    message.enableVtpm = object.enableVtpm ?? false;
    message.enableIntegrityMonitoring = object.enableIntegrityMonitoring ?? false;
    return message;
  },
};

function createBaseVirtualMachine(): VirtualMachine {
  return { instanceName: "", instanceId: "", virtualMachineConfig: undefined };
}

export const VirtualMachine: MessageFns<VirtualMachine> = {
  encode(message: VirtualMachine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceName !== "") {
      writer.uint32(10).string(message.instanceName);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.virtualMachineConfig !== undefined) {
      VirtualMachineConfig.encode(message.virtualMachineConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualMachine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualMachine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instanceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.virtualMachineConfig = VirtualMachineConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualMachine {
    return {
      instanceName: isSet(object.instanceName) ? globalThis.String(object.instanceName) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      virtualMachineConfig: isSet(object.virtualMachineConfig)
        ? VirtualMachineConfig.fromJSON(object.virtualMachineConfig)
        : undefined,
    };
  },

  toJSON(message: VirtualMachine): unknown {
    const obj: any = {};
    if (message.instanceName !== "") {
      obj.instanceName = message.instanceName;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.virtualMachineConfig !== undefined) {
      obj.virtualMachineConfig = VirtualMachineConfig.toJSON(message.virtualMachineConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualMachine>, I>>(base?: I): VirtualMachine {
    return VirtualMachine.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualMachine>, I>>(object: I): VirtualMachine {
    const message = createBaseVirtualMachine();
    message.instanceName = object.instanceName ?? "";
    message.instanceId = object.instanceId ?? "";
    message.virtualMachineConfig = (object.virtualMachineConfig !== undefined && object.virtualMachineConfig !== null)
      ? VirtualMachineConfig.fromPartial(object.virtualMachineConfig)
      : undefined;
    return message;
  },
};

function createBaseVirtualMachineConfig(): VirtualMachineConfig {
  return {
    zone: "",
    machineType: "",
    containerImages: [],
    dataDisk: undefined,
    encryptionConfig: undefined,
    shieldedInstanceConfig: undefined,
    acceleratorConfig: undefined,
    network: "",
    subnet: "",
    internalIpOnly: false,
    tags: [],
    guestAttributes: {},
    metadata: {},
    labels: {},
    nicType: 0,
    reservedIpRange: "",
    bootImage: undefined,
  };
}

export const VirtualMachineConfig: MessageFns<VirtualMachineConfig> = {
  encode(message: VirtualMachineConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.zone !== "") {
      writer.uint32(10).string(message.zone);
    }
    if (message.machineType !== "") {
      writer.uint32(18).string(message.machineType);
    }
    for (const v of message.containerImages) {
      ContainerImage.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.dataDisk !== undefined) {
      LocalDisk.encode(message.dataDisk, writer.uint32(34).fork()).join();
    }
    if (message.encryptionConfig !== undefined) {
      EncryptionConfig.encode(message.encryptionConfig, writer.uint32(42).fork()).join();
    }
    if (message.shieldedInstanceConfig !== undefined) {
      RuntimeShieldedInstanceConfig.encode(message.shieldedInstanceConfig, writer.uint32(50).fork()).join();
    }
    if (message.acceleratorConfig !== undefined) {
      RuntimeAcceleratorConfig.encode(message.acceleratorConfig, writer.uint32(58).fork()).join();
    }
    if (message.network !== "") {
      writer.uint32(66).string(message.network);
    }
    if (message.subnet !== "") {
      writer.uint32(74).string(message.subnet);
    }
    if (message.internalIpOnly !== false) {
      writer.uint32(80).bool(message.internalIpOnly);
    }
    for (const v of message.tags) {
      writer.uint32(106).string(v!);
    }
    Object.entries(message.guestAttributes).forEach(([key, value]) => {
      VirtualMachineConfig_GuestAttributesEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    Object.entries(message.metadata).forEach(([key, value]) => {
      VirtualMachineConfig_MetadataEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      VirtualMachineConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.nicType !== 0) {
      writer.uint32(136).int32(message.nicType);
    }
    if (message.reservedIpRange !== "") {
      writer.uint32(146).string(message.reservedIpRange);
    }
    if (message.bootImage !== undefined) {
      VirtualMachineConfig_BootImage.encode(message.bootImage, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualMachineConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualMachineConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.containerImages.push(ContainerImage.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dataDisk = LocalDisk.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.encryptionConfig = EncryptionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.shieldedInstanceConfig = RuntimeShieldedInstanceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.acceleratorConfig = RuntimeAcceleratorConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.subnet = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.internalIpOnly = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = VirtualMachineConfig_GuestAttributesEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.guestAttributes[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = VirtualMachineConfig_MetadataEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.metadata[entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          const entry16 = VirtualMachineConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.labels[entry16.key] = entry16.value;
          }
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.nicType = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.reservedIpRange = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.bootImage = VirtualMachineConfig_BootImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualMachineConfig {
    return {
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      containerImages: globalThis.Array.isArray(object?.containerImages)
        ? object.containerImages.map((e: any) => ContainerImage.fromJSON(e))
        : [],
      dataDisk: isSet(object.dataDisk) ? LocalDisk.fromJSON(object.dataDisk) : undefined,
      encryptionConfig: isSet(object.encryptionConfig) ? EncryptionConfig.fromJSON(object.encryptionConfig) : undefined,
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? RuntimeShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      acceleratorConfig: isSet(object.acceleratorConfig)
        ? RuntimeAcceleratorConfig.fromJSON(object.acceleratorConfig)
        : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnet: isSet(object.subnet) ? globalThis.String(object.subnet) : "",
      internalIpOnly: isSet(object.internalIpOnly) ? globalThis.Boolean(object.internalIpOnly) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      guestAttributes: isObject(object.guestAttributes)
        ? Object.entries(object.guestAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      nicType: isSet(object.nicType) ? virtualMachineConfig_NicTypeFromJSON(object.nicType) : 0,
      reservedIpRange: isSet(object.reservedIpRange) ? globalThis.String(object.reservedIpRange) : "",
      bootImage: isSet(object.bootImage) ? VirtualMachineConfig_BootImage.fromJSON(object.bootImage) : undefined,
    };
  },

  toJSON(message: VirtualMachineConfig): unknown {
    const obj: any = {};
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.containerImages?.length) {
      obj.containerImages = message.containerImages.map((e) => ContainerImage.toJSON(e));
    }
    if (message.dataDisk !== undefined) {
      obj.dataDisk = LocalDisk.toJSON(message.dataDisk);
    }
    if (message.encryptionConfig !== undefined) {
      obj.encryptionConfig = EncryptionConfig.toJSON(message.encryptionConfig);
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = RuntimeShieldedInstanceConfig.toJSON(message.shieldedInstanceConfig);
    }
    if (message.acceleratorConfig !== undefined) {
      obj.acceleratorConfig = RuntimeAcceleratorConfig.toJSON(message.acceleratorConfig);
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnet !== "") {
      obj.subnet = message.subnet;
    }
    if (message.internalIpOnly !== false) {
      obj.internalIpOnly = message.internalIpOnly;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.guestAttributes) {
      const entries = Object.entries(message.guestAttributes);
      if (entries.length > 0) {
        obj.guestAttributes = {};
        entries.forEach(([k, v]) => {
          obj.guestAttributes[k] = v;
        });
      }
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.nicType !== 0) {
      obj.nicType = virtualMachineConfig_NicTypeToJSON(message.nicType);
    }
    if (message.reservedIpRange !== "") {
      obj.reservedIpRange = message.reservedIpRange;
    }
    if (message.bootImage !== undefined) {
      obj.bootImage = VirtualMachineConfig_BootImage.toJSON(message.bootImage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualMachineConfig>, I>>(base?: I): VirtualMachineConfig {
    return VirtualMachineConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualMachineConfig>, I>>(object: I): VirtualMachineConfig {
    const message = createBaseVirtualMachineConfig();
    message.zone = object.zone ?? "";
    message.machineType = object.machineType ?? "";
    message.containerImages = object.containerImages?.map((e) => ContainerImage.fromPartial(e)) || [];
    message.dataDisk = (object.dataDisk !== undefined && object.dataDisk !== null)
      ? LocalDisk.fromPartial(object.dataDisk)
      : undefined;
    message.encryptionConfig = (object.encryptionConfig !== undefined && object.encryptionConfig !== null)
      ? EncryptionConfig.fromPartial(object.encryptionConfig)
      : undefined;
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? RuntimeShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.acceleratorConfig = (object.acceleratorConfig !== undefined && object.acceleratorConfig !== null)
      ? RuntimeAcceleratorConfig.fromPartial(object.acceleratorConfig)
      : undefined;
    message.network = object.network ?? "";
    message.subnet = object.subnet ?? "";
    message.internalIpOnly = object.internalIpOnly ?? false;
    message.tags = object.tags?.map((e) => e) || [];
    message.guestAttributes = Object.entries(object.guestAttributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.nicType = object.nicType ?? 0;
    message.reservedIpRange = object.reservedIpRange ?? "";
    message.bootImage = (object.bootImage !== undefined && object.bootImage !== null)
      ? VirtualMachineConfig_BootImage.fromPartial(object.bootImage)
      : undefined;
    return message;
  },
};

function createBaseVirtualMachineConfig_BootImage(): VirtualMachineConfig_BootImage {
  return {};
}

export const VirtualMachineConfig_BootImage: MessageFns<VirtualMachineConfig_BootImage> = {
  encode(_: VirtualMachineConfig_BootImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualMachineConfig_BootImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualMachineConfig_BootImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VirtualMachineConfig_BootImage {
    return {};
  },

  toJSON(_: VirtualMachineConfig_BootImage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualMachineConfig_BootImage>, I>>(base?: I): VirtualMachineConfig_BootImage {
    return VirtualMachineConfig_BootImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualMachineConfig_BootImage>, I>>(_: I): VirtualMachineConfig_BootImage {
    const message = createBaseVirtualMachineConfig_BootImage();
    return message;
  },
};

function createBaseVirtualMachineConfig_GuestAttributesEntry(): VirtualMachineConfig_GuestAttributesEntry {
  return { key: "", value: "" };
}

export const VirtualMachineConfig_GuestAttributesEntry: MessageFns<VirtualMachineConfig_GuestAttributesEntry> = {
  encode(message: VirtualMachineConfig_GuestAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualMachineConfig_GuestAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualMachineConfig_GuestAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualMachineConfig_GuestAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VirtualMachineConfig_GuestAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualMachineConfig_GuestAttributesEntry>, I>>(
    base?: I,
  ): VirtualMachineConfig_GuestAttributesEntry {
    return VirtualMachineConfig_GuestAttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualMachineConfig_GuestAttributesEntry>, I>>(
    object: I,
  ): VirtualMachineConfig_GuestAttributesEntry {
    const message = createBaseVirtualMachineConfig_GuestAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVirtualMachineConfig_MetadataEntry(): VirtualMachineConfig_MetadataEntry {
  return { key: "", value: "" };
}

export const VirtualMachineConfig_MetadataEntry: MessageFns<VirtualMachineConfig_MetadataEntry> = {
  encode(message: VirtualMachineConfig_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualMachineConfig_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualMachineConfig_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualMachineConfig_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VirtualMachineConfig_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualMachineConfig_MetadataEntry>, I>>(
    base?: I,
  ): VirtualMachineConfig_MetadataEntry {
    return VirtualMachineConfig_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualMachineConfig_MetadataEntry>, I>>(
    object: I,
  ): VirtualMachineConfig_MetadataEntry {
    const message = createBaseVirtualMachineConfig_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVirtualMachineConfig_LabelsEntry(): VirtualMachineConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const VirtualMachineConfig_LabelsEntry: MessageFns<VirtualMachineConfig_LabelsEntry> = {
  encode(message: VirtualMachineConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualMachineConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualMachineConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualMachineConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VirtualMachineConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualMachineConfig_LabelsEntry>, I>>(
    base?: I,
  ): VirtualMachineConfig_LabelsEntry {
    return VirtualMachineConfig_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualMachineConfig_LabelsEntry>, I>>(
    object: I,
  ): VirtualMachineConfig_LabelsEntry {
    const message = createBaseVirtualMachineConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExecutionTemplate(): ExecutionTemplate {
  return {
    scaleTier: 0,
    masterType: "",
    acceleratorConfig: undefined,
    labels: {},
    inputNotebookFile: "",
    containerImageUri: "",
    outputNotebookFolder: "",
    paramsYamlFile: "",
    parameters: "",
    serviceAccount: "",
    jobType: 0,
    dataprocParameters: undefined,
    vertexAiParameters: undefined,
    kernelSpec: "",
    tensorboard: "",
  };
}

export const ExecutionTemplate: MessageFns<ExecutionTemplate> = {
  encode(message: ExecutionTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scaleTier !== 0) {
      writer.uint32(8).int32(message.scaleTier);
    }
    if (message.masterType !== "") {
      writer.uint32(18).string(message.masterType);
    }
    if (message.acceleratorConfig !== undefined) {
      ExecutionTemplate_SchedulerAcceleratorConfig.encode(message.acceleratorConfig, writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ExecutionTemplate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.inputNotebookFile !== "") {
      writer.uint32(42).string(message.inputNotebookFile);
    }
    if (message.containerImageUri !== "") {
      writer.uint32(50).string(message.containerImageUri);
    }
    if (message.outputNotebookFolder !== "") {
      writer.uint32(58).string(message.outputNotebookFolder);
    }
    if (message.paramsYamlFile !== "") {
      writer.uint32(66).string(message.paramsYamlFile);
    }
    if (message.parameters !== "") {
      writer.uint32(74).string(message.parameters);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(82).string(message.serviceAccount);
    }
    if (message.jobType !== 0) {
      writer.uint32(88).int32(message.jobType);
    }
    if (message.dataprocParameters !== undefined) {
      ExecutionTemplate_DataprocParameters.encode(message.dataprocParameters, writer.uint32(98).fork()).join();
    }
    if (message.vertexAiParameters !== undefined) {
      ExecutionTemplate_VertexAIParameters.encode(message.vertexAiParameters, writer.uint32(106).fork()).join();
    }
    if (message.kernelSpec !== "") {
      writer.uint32(114).string(message.kernelSpec);
    }
    if (message.tensorboard !== "") {
      writer.uint32(122).string(message.tensorboard);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scaleTier = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.masterType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.acceleratorConfig = ExecutionTemplate_SchedulerAcceleratorConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ExecutionTemplate_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputNotebookFile = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.containerImageUri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputNotebookFolder = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.paramsYamlFile = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.parameters = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.jobType = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dataprocParameters = ExecutionTemplate_DataprocParameters.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.vertexAiParameters = ExecutionTemplate_VertexAIParameters.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.kernelSpec = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tensorboard = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionTemplate {
    return {
      scaleTier: isSet(object.scaleTier) ? executionTemplate_ScaleTierFromJSON(object.scaleTier) : 0,
      masterType: isSet(object.masterType) ? globalThis.String(object.masterType) : "",
      acceleratorConfig: isSet(object.acceleratorConfig)
        ? ExecutionTemplate_SchedulerAcceleratorConfig.fromJSON(object.acceleratorConfig)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      inputNotebookFile: isSet(object.inputNotebookFile) ? globalThis.String(object.inputNotebookFile) : "",
      containerImageUri: isSet(object.containerImageUri) ? globalThis.String(object.containerImageUri) : "",
      outputNotebookFolder: isSet(object.outputNotebookFolder) ? globalThis.String(object.outputNotebookFolder) : "",
      paramsYamlFile: isSet(object.paramsYamlFile) ? globalThis.String(object.paramsYamlFile) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      jobType: isSet(object.jobType) ? executionTemplate_JobTypeFromJSON(object.jobType) : 0,
      dataprocParameters: isSet(object.dataprocParameters)
        ? ExecutionTemplate_DataprocParameters.fromJSON(object.dataprocParameters)
        : undefined,
      vertexAiParameters: isSet(object.vertexAiParameters)
        ? ExecutionTemplate_VertexAIParameters.fromJSON(object.vertexAiParameters)
        : undefined,
      kernelSpec: isSet(object.kernelSpec) ? globalThis.String(object.kernelSpec) : "",
      tensorboard: isSet(object.tensorboard) ? globalThis.String(object.tensorboard) : "",
    };
  },

  toJSON(message: ExecutionTemplate): unknown {
    const obj: any = {};
    if (message.scaleTier !== 0) {
      obj.scaleTier = executionTemplate_ScaleTierToJSON(message.scaleTier);
    }
    if (message.masterType !== "") {
      obj.masterType = message.masterType;
    }
    if (message.acceleratorConfig !== undefined) {
      obj.acceleratorConfig = ExecutionTemplate_SchedulerAcceleratorConfig.toJSON(message.acceleratorConfig);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.inputNotebookFile !== "") {
      obj.inputNotebookFile = message.inputNotebookFile;
    }
    if (message.containerImageUri !== "") {
      obj.containerImageUri = message.containerImageUri;
    }
    if (message.outputNotebookFolder !== "") {
      obj.outputNotebookFolder = message.outputNotebookFolder;
    }
    if (message.paramsYamlFile !== "") {
      obj.paramsYamlFile = message.paramsYamlFile;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.jobType !== 0) {
      obj.jobType = executionTemplate_JobTypeToJSON(message.jobType);
    }
    if (message.dataprocParameters !== undefined) {
      obj.dataprocParameters = ExecutionTemplate_DataprocParameters.toJSON(message.dataprocParameters);
    }
    if (message.vertexAiParameters !== undefined) {
      obj.vertexAiParameters = ExecutionTemplate_VertexAIParameters.toJSON(message.vertexAiParameters);
    }
    if (message.kernelSpec !== "") {
      obj.kernelSpec = message.kernelSpec;
    }
    if (message.tensorboard !== "") {
      obj.tensorboard = message.tensorboard;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionTemplate>, I>>(base?: I): ExecutionTemplate {
    return ExecutionTemplate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionTemplate>, I>>(object: I): ExecutionTemplate {
    const message = createBaseExecutionTemplate();
    message.scaleTier = object.scaleTier ?? 0;
    message.masterType = object.masterType ?? "";
    message.acceleratorConfig = (object.acceleratorConfig !== undefined && object.acceleratorConfig !== null)
      ? ExecutionTemplate_SchedulerAcceleratorConfig.fromPartial(object.acceleratorConfig)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.inputNotebookFile = object.inputNotebookFile ?? "";
    message.containerImageUri = object.containerImageUri ?? "";
    message.outputNotebookFolder = object.outputNotebookFolder ?? "";
    message.paramsYamlFile = object.paramsYamlFile ?? "";
    message.parameters = object.parameters ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.jobType = object.jobType ?? 0;
    message.dataprocParameters = (object.dataprocParameters !== undefined && object.dataprocParameters !== null)
      ? ExecutionTemplate_DataprocParameters.fromPartial(object.dataprocParameters)
      : undefined;
    message.vertexAiParameters = (object.vertexAiParameters !== undefined && object.vertexAiParameters !== null)
      ? ExecutionTemplate_VertexAIParameters.fromPartial(object.vertexAiParameters)
      : undefined;
    message.kernelSpec = object.kernelSpec ?? "";
    message.tensorboard = object.tensorboard ?? "";
    return message;
  },
};

function createBaseExecutionTemplate_SchedulerAcceleratorConfig(): ExecutionTemplate_SchedulerAcceleratorConfig {
  return { type: 0, coreCount: Long.ZERO };
}

export const ExecutionTemplate_SchedulerAcceleratorConfig: MessageFns<ExecutionTemplate_SchedulerAcceleratorConfig> = {
  encode(
    message: ExecutionTemplate_SchedulerAcceleratorConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.coreCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionTemplate_SchedulerAcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionTemplate_SchedulerAcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.coreCount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionTemplate_SchedulerAcceleratorConfig {
    return {
      type: isSet(object.type) ? executionTemplate_SchedulerAcceleratorTypeFromJSON(object.type) : 0,
      coreCount: isSet(object.coreCount) ? Long.fromValue(object.coreCount) : Long.ZERO,
    };
  },

  toJSON(message: ExecutionTemplate_SchedulerAcceleratorConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = executionTemplate_SchedulerAcceleratorTypeToJSON(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      obj.coreCount = (message.coreCount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionTemplate_SchedulerAcceleratorConfig>, I>>(
    base?: I,
  ): ExecutionTemplate_SchedulerAcceleratorConfig {
    return ExecutionTemplate_SchedulerAcceleratorConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionTemplate_SchedulerAcceleratorConfig>, I>>(
    object: I,
  ): ExecutionTemplate_SchedulerAcceleratorConfig {
    const message = createBaseExecutionTemplate_SchedulerAcceleratorConfig();
    message.type = object.type ?? 0;
    message.coreCount = (object.coreCount !== undefined && object.coreCount !== null)
      ? Long.fromValue(object.coreCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseExecutionTemplate_DataprocParameters(): ExecutionTemplate_DataprocParameters {
  return { cluster: "" };
}

export const ExecutionTemplate_DataprocParameters: MessageFns<ExecutionTemplate_DataprocParameters> = {
  encode(message: ExecutionTemplate_DataprocParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionTemplate_DataprocParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionTemplate_DataprocParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionTemplate_DataprocParameters {
    return { cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "" };
  },

  toJSON(message: ExecutionTemplate_DataprocParameters): unknown {
    const obj: any = {};
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionTemplate_DataprocParameters>, I>>(
    base?: I,
  ): ExecutionTemplate_DataprocParameters {
    return ExecutionTemplate_DataprocParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionTemplate_DataprocParameters>, I>>(
    object: I,
  ): ExecutionTemplate_DataprocParameters {
    const message = createBaseExecutionTemplate_DataprocParameters();
    message.cluster = object.cluster ?? "";
    return message;
  },
};

function createBaseExecutionTemplate_VertexAIParameters(): ExecutionTemplate_VertexAIParameters {
  return { network: "", env: {} };
}

export const ExecutionTemplate_VertexAIParameters: MessageFns<ExecutionTemplate_VertexAIParameters> = {
  encode(message: ExecutionTemplate_VertexAIParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    Object.entries(message.env).forEach(([key, value]) => {
      ExecutionTemplate_VertexAIParameters_EnvEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionTemplate_VertexAIParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionTemplate_VertexAIParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ExecutionTemplate_VertexAIParameters_EnvEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.env[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionTemplate_VertexAIParameters {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ExecutionTemplate_VertexAIParameters): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.env) {
      const entries = Object.entries(message.env);
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionTemplate_VertexAIParameters>, I>>(
    base?: I,
  ): ExecutionTemplate_VertexAIParameters {
    return ExecutionTemplate_VertexAIParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionTemplate_VertexAIParameters>, I>>(
    object: I,
  ): ExecutionTemplate_VertexAIParameters {
    const message = createBaseExecutionTemplate_VertexAIParameters();
    message.network = object.network ?? "";
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseExecutionTemplate_VertexAIParameters_EnvEntry(): ExecutionTemplate_VertexAIParameters_EnvEntry {
  return { key: "", value: "" };
}

export const ExecutionTemplate_VertexAIParameters_EnvEntry: MessageFns<ExecutionTemplate_VertexAIParameters_EnvEntry> =
  {
    encode(
      message: ExecutionTemplate_VertexAIParameters_EnvEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ExecutionTemplate_VertexAIParameters_EnvEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseExecutionTemplate_VertexAIParameters_EnvEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ExecutionTemplate_VertexAIParameters_EnvEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: ExecutionTemplate_VertexAIParameters_EnvEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ExecutionTemplate_VertexAIParameters_EnvEntry>, I>>(
      base?: I,
    ): ExecutionTemplate_VertexAIParameters_EnvEntry {
      return ExecutionTemplate_VertexAIParameters_EnvEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ExecutionTemplate_VertexAIParameters_EnvEntry>, I>>(
      object: I,
    ): ExecutionTemplate_VertexAIParameters_EnvEntry {
      const message = createBaseExecutionTemplate_VertexAIParameters_EnvEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseExecutionTemplate_LabelsEntry(): ExecutionTemplate_LabelsEntry {
  return { key: "", value: "" };
}

export const ExecutionTemplate_LabelsEntry: MessageFns<ExecutionTemplate_LabelsEntry> = {
  encode(message: ExecutionTemplate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionTemplate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionTemplate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionTemplate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ExecutionTemplate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionTemplate_LabelsEntry>, I>>(base?: I): ExecutionTemplate_LabelsEntry {
    return ExecutionTemplate_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionTemplate_LabelsEntry>, I>>(
    object: I,
  ): ExecutionTemplate_LabelsEntry {
    const message = createBaseExecutionTemplate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExecution(): Execution {
  return {
    executionTemplate: undefined,
    name: "",
    displayName: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    outputNotebookFile: "",
    jobUri: "",
  };
}

export const Execution: MessageFns<Execution> = {
  encode(message: Execution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executionTemplate !== undefined) {
      ExecutionTemplate.encode(message.executionTemplate, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.outputNotebookFile !== "") {
      writer.uint32(66).string(message.outputNotebookFile);
    }
    if (message.jobUri !== "") {
      writer.uint32(74).string(message.jobUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Execution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executionTemplate = ExecutionTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputNotebookFile = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.jobUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Execution {
    return {
      executionTemplate: isSet(object.executionTemplate)
        ? ExecutionTemplate.fromJSON(object.executionTemplate)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? execution_StateFromJSON(object.state) : 0,
      outputNotebookFile: isSet(object.outputNotebookFile) ? globalThis.String(object.outputNotebookFile) : "",
      jobUri: isSet(object.jobUri) ? globalThis.String(object.jobUri) : "",
    };
  },

  toJSON(message: Execution): unknown {
    const obj: any = {};
    if (message.executionTemplate !== undefined) {
      obj.executionTemplate = ExecutionTemplate.toJSON(message.executionTemplate);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = execution_StateToJSON(message.state);
    }
    if (message.outputNotebookFile !== "") {
      obj.outputNotebookFile = message.outputNotebookFile;
    }
    if (message.jobUri !== "") {
      obj.jobUri = message.jobUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Execution>, I>>(base?: I): Execution {
    return Execution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Execution>, I>>(object: I): Execution {
    const message = createBaseExecution();
    message.executionTemplate = (object.executionTemplate !== undefined && object.executionTemplate !== null)
      ? ExecutionTemplate.fromPartial(object.executionTemplate)
      : undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.outputNotebookFile = object.outputNotebookFile ?? "";
    message.jobUri = object.jobUri ?? "";
    return message;
  },
};

function createBaseReservationAffinity(): ReservationAffinity {
  return { consumeReservationType: 0, key: "", values: [] };
}

export const ReservationAffinity: MessageFns<ReservationAffinity> = {
  encode(message: ReservationAffinity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumeReservationType !== 0) {
      writer.uint32(8).int32(message.consumeReservationType);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    for (const v of message.values) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReservationAffinity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservationAffinity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.consumeReservationType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReservationAffinity {
    return {
      consumeReservationType: isSet(object.consumeReservationType)
        ? reservationAffinity_TypeFromJSON(object.consumeReservationType)
        : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ReservationAffinity): unknown {
    const obj: any = {};
    if (message.consumeReservationType !== 0) {
      obj.consumeReservationType = reservationAffinity_TypeToJSON(message.consumeReservationType);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReservationAffinity>, I>>(base?: I): ReservationAffinity {
    return ReservationAffinity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReservationAffinity>, I>>(object: I): ReservationAffinity {
    const message = createBaseReservationAffinity();
    message.consumeReservationType = object.consumeReservationType ?? 0;
    message.key = object.key ?? "";
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseInstance(): Instance {
  return {
    name: "",
    vmImage: undefined,
    containerImage: undefined,
    postStartupScript: "",
    proxyUri: "",
    serviceAccount: "",
    serviceAccountScopes: [],
    machineType: "",
    acceleratorConfig: undefined,
    state: 0,
    installGpuDriver: false,
    customGpuDriverPath: "",
    disks: [],
    shieldedInstanceConfig: undefined,
    noPublicIp: false,
    noProxyAccess: false,
    network: "",
    subnet: "",
    labels: {},
    metadata: {},
    tags: [],
    upgradeHistory: [],
    nicType: 0,
    reservationAffinity: undefined,
    creator: "",
    canIpForward: false,
    createTime: undefined,
    updateTime: undefined,
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vmImage !== undefined) {
      VmImage.encode(message.vmImage, writer.uint32(18).fork()).join();
    }
    if (message.containerImage !== undefined) {
      ContainerImage.encode(message.containerImage, writer.uint32(26).fork()).join();
    }
    if (message.postStartupScript !== "") {
      writer.uint32(34).string(message.postStartupScript);
    }
    if (message.proxyUri !== "") {
      writer.uint32(42).string(message.proxyUri);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(58).string(message.serviceAccount);
    }
    for (const v of message.serviceAccountScopes) {
      writer.uint32(250).string(v!);
    }
    if (message.machineType !== "") {
      writer.uint32(66).string(message.machineType);
    }
    if (message.acceleratorConfig !== undefined) {
      Instance_AcceleratorConfig.encode(message.acceleratorConfig, writer.uint32(74).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.installGpuDriver !== false) {
      writer.uint32(88).bool(message.installGpuDriver);
    }
    if (message.customGpuDriverPath !== "") {
      writer.uint32(98).string(message.customGpuDriverPath);
    }
    for (const v of message.disks) {
      Instance_Disk.encode(v!, writer.uint32(226).fork()).join();
    }
    if (message.shieldedInstanceConfig !== undefined) {
      Instance_ShieldedInstanceConfig.encode(message.shieldedInstanceConfig, writer.uint32(242).fork()).join();
    }
    if (message.noPublicIp !== false) {
      writer.uint32(136).bool(message.noPublicIp);
    }
    if (message.noProxyAccess !== false) {
      writer.uint32(144).bool(message.noProxyAccess);
    }
    if (message.network !== "") {
      writer.uint32(154).string(message.network);
    }
    if (message.subnet !== "") {
      writer.uint32(162).string(message.subnet);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(170).fork()).join();
    });
    Object.entries(message.metadata).forEach(([key, value]) => {
      Instance_MetadataEntry.encode({ key: key as any, value }, writer.uint32(178).fork()).join();
    });
    for (const v of message.tags) {
      writer.uint32(258).string(v!);
    }
    for (const v of message.upgradeHistory) {
      Instance_UpgradeHistoryEntry.encode(v!, writer.uint32(234).fork()).join();
    }
    if (message.nicType !== 0) {
      writer.uint32(264).int32(message.nicType);
    }
    if (message.reservationAffinity !== undefined) {
      ReservationAffinity.encode(message.reservationAffinity, writer.uint32(274).fork()).join();
    }
    if (message.creator !== "") {
      writer.uint32(290).string(message.creator);
    }
    if (message.canIpForward !== false) {
      writer.uint32(312).bool(message.canIpForward);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(186).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vmImage = VmImage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.containerImage = ContainerImage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.postStartupScript = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.proxyUri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.serviceAccountScopes.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.acceleratorConfig = Instance_AcceleratorConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.installGpuDriver = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.customGpuDriverPath = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.disks.push(Instance_Disk.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.shieldedInstanceConfig = Instance_ShieldedInstanceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.noPublicIp = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.noProxyAccess = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.subnet = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          const entry21 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry21.value !== undefined) {
            message.labels[entry21.key] = entry21.value;
          }
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          const entry22 = Instance_MetadataEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            message.metadata[entry22.key] = entry22.value;
          }
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.upgradeHistory.push(Instance_UpgradeHistoryEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.nicType = reader.int32() as any;
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.reservationAffinity = ReservationAffinity.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.canIpForward = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      vmImage: isSet(object.vmImage) ? VmImage.fromJSON(object.vmImage) : undefined,
      containerImage: isSet(object.containerImage) ? ContainerImage.fromJSON(object.containerImage) : undefined,
      postStartupScript: isSet(object.postStartupScript) ? globalThis.String(object.postStartupScript) : "",
      proxyUri: isSet(object.proxyUri) ? globalThis.String(object.proxyUri) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      serviceAccountScopes: globalThis.Array.isArray(object?.serviceAccountScopes)
        ? object.serviceAccountScopes.map((e: any) => globalThis.String(e))
        : [],
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      acceleratorConfig: isSet(object.acceleratorConfig)
        ? Instance_AcceleratorConfig.fromJSON(object.acceleratorConfig)
        : undefined,
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
      installGpuDriver: isSet(object.installGpuDriver) ? globalThis.Boolean(object.installGpuDriver) : false,
      customGpuDriverPath: isSet(object.customGpuDriverPath) ? globalThis.String(object.customGpuDriverPath) : "",
      disks: globalThis.Array.isArray(object?.disks) ? object.disks.map((e: any) => Instance_Disk.fromJSON(e)) : [],
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? Instance_ShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      noPublicIp: isSet(object.noPublicIp) ? globalThis.Boolean(object.noPublicIp) : false,
      noProxyAccess: isSet(object.noProxyAccess) ? globalThis.Boolean(object.noProxyAccess) : false,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnet: isSet(object.subnet) ? globalThis.String(object.subnet) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      upgradeHistory: globalThis.Array.isArray(object?.upgradeHistory)
        ? object.upgradeHistory.map((e: any) => Instance_UpgradeHistoryEntry.fromJSON(e))
        : [],
      nicType: isSet(object.nicType) ? instance_NicTypeFromJSON(object.nicType) : 0,
      reservationAffinity: isSet(object.reservationAffinity)
        ? ReservationAffinity.fromJSON(object.reservationAffinity)
        : undefined,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      canIpForward: isSet(object.canIpForward) ? globalThis.Boolean(object.canIpForward) : false,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vmImage !== undefined) {
      obj.vmImage = VmImage.toJSON(message.vmImage);
    }
    if (message.containerImage !== undefined) {
      obj.containerImage = ContainerImage.toJSON(message.containerImage);
    }
    if (message.postStartupScript !== "") {
      obj.postStartupScript = message.postStartupScript;
    }
    if (message.proxyUri !== "") {
      obj.proxyUri = message.proxyUri;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.serviceAccountScopes?.length) {
      obj.serviceAccountScopes = message.serviceAccountScopes;
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.acceleratorConfig !== undefined) {
      obj.acceleratorConfig = Instance_AcceleratorConfig.toJSON(message.acceleratorConfig);
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    if (message.installGpuDriver !== false) {
      obj.installGpuDriver = message.installGpuDriver;
    }
    if (message.customGpuDriverPath !== "") {
      obj.customGpuDriverPath = message.customGpuDriverPath;
    }
    if (message.disks?.length) {
      obj.disks = message.disks.map((e) => Instance_Disk.toJSON(e));
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = Instance_ShieldedInstanceConfig.toJSON(message.shieldedInstanceConfig);
    }
    if (message.noPublicIp !== false) {
      obj.noPublicIp = message.noPublicIp;
    }
    if (message.noProxyAccess !== false) {
      obj.noProxyAccess = message.noProxyAccess;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnet !== "") {
      obj.subnet = message.subnet;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.upgradeHistory?.length) {
      obj.upgradeHistory = message.upgradeHistory.map((e) => Instance_UpgradeHistoryEntry.toJSON(e));
    }
    if (message.nicType !== 0) {
      obj.nicType = instance_NicTypeToJSON(message.nicType);
    }
    if (message.reservationAffinity !== undefined) {
      obj.reservationAffinity = ReservationAffinity.toJSON(message.reservationAffinity);
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.canIpForward !== false) {
      obj.canIpForward = message.canIpForward;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance>, I>>(base?: I): Instance {
    return Instance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance>, I>>(object: I): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.vmImage = (object.vmImage !== undefined && object.vmImage !== null)
      ? VmImage.fromPartial(object.vmImage)
      : undefined;
    message.containerImage = (object.containerImage !== undefined && object.containerImage !== null)
      ? ContainerImage.fromPartial(object.containerImage)
      : undefined;
    message.postStartupScript = object.postStartupScript ?? "";
    message.proxyUri = object.proxyUri ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.serviceAccountScopes = object.serviceAccountScopes?.map((e) => e) || [];
    message.machineType = object.machineType ?? "";
    message.acceleratorConfig = (object.acceleratorConfig !== undefined && object.acceleratorConfig !== null)
      ? Instance_AcceleratorConfig.fromPartial(object.acceleratorConfig)
      : undefined;
    message.state = object.state ?? 0;
    message.installGpuDriver = object.installGpuDriver ?? false;
    message.customGpuDriverPath = object.customGpuDriverPath ?? "";
    message.disks = object.disks?.map((e) => Instance_Disk.fromPartial(e)) || [];
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? Instance_ShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.noPublicIp = object.noPublicIp ?? false;
    message.noProxyAccess = object.noProxyAccess ?? false;
    message.network = object.network ?? "";
    message.subnet = object.subnet ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.tags = object.tags?.map((e) => e) || [];
    message.upgradeHistory = object.upgradeHistory?.map((e) => Instance_UpgradeHistoryEntry.fromPartial(e)) || [];
    message.nicType = object.nicType ?? 0;
    message.reservationAffinity = (object.reservationAffinity !== undefined && object.reservationAffinity !== null)
      ? ReservationAffinity.fromPartial(object.reservationAffinity)
      : undefined;
    message.creator = object.creator ?? "";
    message.canIpForward = object.canIpForward ?? false;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseInstance_AcceleratorConfig(): Instance_AcceleratorConfig {
  return { type: 0, coreCount: Long.ZERO };
}

export const Instance_AcceleratorConfig: MessageFns<Instance_AcceleratorConfig> = {
  encode(message: Instance_AcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.coreCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_AcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_AcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.coreCount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_AcceleratorConfig {
    return {
      type: isSet(object.type) ? instance_AcceleratorTypeFromJSON(object.type) : 0,
      coreCount: isSet(object.coreCount) ? Long.fromValue(object.coreCount) : Long.ZERO,
    };
  },

  toJSON(message: Instance_AcceleratorConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = instance_AcceleratorTypeToJSON(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      obj.coreCount = (message.coreCount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_AcceleratorConfig>, I>>(base?: I): Instance_AcceleratorConfig {
    return Instance_AcceleratorConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_AcceleratorConfig>, I>>(object: I): Instance_AcceleratorConfig {
    const message = createBaseInstance_AcceleratorConfig();
    message.type = object.type ?? 0;
    message.coreCount = (object.coreCount !== undefined && object.coreCount !== null)
      ? Long.fromValue(object.coreCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseInstance_Disk(): Instance_Disk {
  return {
    autoDelete: false,
    boot: false,
    deviceName: "",
    diskSizeGb: Long.ZERO,
    guestOsFeatures: [],
    index: Long.ZERO,
    interface: "",
    kind: "",
    licenses: [],
    mode: "",
    source: "",
    type: "",
  };
}

export const Instance_Disk: MessageFns<Instance_Disk> = {
  encode(message: Instance_Disk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoDelete !== false) {
      writer.uint32(8).bool(message.autoDelete);
    }
    if (message.boot !== false) {
      writer.uint32(16).bool(message.boot);
    }
    if (message.deviceName !== "") {
      writer.uint32(26).string(message.deviceName);
    }
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.diskSizeGb.toString());
    }
    for (const v of message.guestOsFeatures) {
      Instance_Disk_GuestOsFeature.encode(v!, writer.uint32(42).fork()).join();
    }
    if (!message.index.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.index.toString());
    }
    if (message.interface !== "") {
      writer.uint32(58).string(message.interface);
    }
    if (message.kind !== "") {
      writer.uint32(66).string(message.kind);
    }
    for (const v of message.licenses) {
      writer.uint32(74).string(v!);
    }
    if (message.mode !== "") {
      writer.uint32(82).string(message.mode);
    }
    if (message.source !== "") {
      writer.uint32(90).string(message.source);
    }
    if (message.type !== "") {
      writer.uint32(98).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_Disk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_Disk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.autoDelete = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boot = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.diskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.guestOsFeatures.push(Instance_Disk_GuestOsFeature.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.index = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.interface = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.licenses.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_Disk {
    return {
      autoDelete: isSet(object.autoDelete) ? globalThis.Boolean(object.autoDelete) : false,
      boot: isSet(object.boot) ? globalThis.Boolean(object.boot) : false,
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : "",
      diskSizeGb: isSet(object.diskSizeGb) ? Long.fromValue(object.diskSizeGb) : Long.ZERO,
      guestOsFeatures: globalThis.Array.isArray(object?.guestOsFeatures)
        ? object.guestOsFeatures.map((e: any) => Instance_Disk_GuestOsFeature.fromJSON(e))
        : [],
      index: isSet(object.index) ? Long.fromValue(object.index) : Long.ZERO,
      interface: isSet(object.interface) ? globalThis.String(object.interface) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      licenses: globalThis.Array.isArray(object?.licenses) ? object.licenses.map((e: any) => globalThis.String(e)) : [],
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: Instance_Disk): unknown {
    const obj: any = {};
    if (message.autoDelete !== false) {
      obj.autoDelete = message.autoDelete;
    }
    if (message.boot !== false) {
      obj.boot = message.boot;
    }
    if (message.deviceName !== "") {
      obj.deviceName = message.deviceName;
    }
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      obj.diskSizeGb = (message.diskSizeGb || Long.ZERO).toString();
    }
    if (message.guestOsFeatures?.length) {
      obj.guestOsFeatures = message.guestOsFeatures.map((e) => Instance_Disk_GuestOsFeature.toJSON(e));
    }
    if (!message.index.equals(Long.ZERO)) {
      obj.index = (message.index || Long.ZERO).toString();
    }
    if (message.interface !== "") {
      obj.interface = message.interface;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.licenses?.length) {
      obj.licenses = message.licenses;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_Disk>, I>>(base?: I): Instance_Disk {
    return Instance_Disk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_Disk>, I>>(object: I): Instance_Disk {
    const message = createBaseInstance_Disk();
    message.autoDelete = object.autoDelete ?? false;
    message.boot = object.boot ?? false;
    message.deviceName = object.deviceName ?? "";
    message.diskSizeGb = (object.diskSizeGb !== undefined && object.diskSizeGb !== null)
      ? Long.fromValue(object.diskSizeGb)
      : Long.ZERO;
    message.guestOsFeatures = object.guestOsFeatures?.map((e) => Instance_Disk_GuestOsFeature.fromPartial(e)) || [];
    message.index = (object.index !== undefined && object.index !== null) ? Long.fromValue(object.index) : Long.ZERO;
    message.interface = object.interface ?? "";
    message.kind = object.kind ?? "";
    message.licenses = object.licenses?.map((e) => e) || [];
    message.mode = object.mode ?? "";
    message.source = object.source ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseInstance_Disk_GuestOsFeature(): Instance_Disk_GuestOsFeature {
  return { type: "" };
}

export const Instance_Disk_GuestOsFeature: MessageFns<Instance_Disk_GuestOsFeature> = {
  encode(message: Instance_Disk_GuestOsFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_Disk_GuestOsFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_Disk_GuestOsFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_Disk_GuestOsFeature {
    return { type: isSet(object.type) ? globalThis.String(object.type) : "" };
  },

  toJSON(message: Instance_Disk_GuestOsFeature): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_Disk_GuestOsFeature>, I>>(base?: I): Instance_Disk_GuestOsFeature {
    return Instance_Disk_GuestOsFeature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_Disk_GuestOsFeature>, I>>(object: I): Instance_Disk_GuestOsFeature {
    const message = createBaseInstance_Disk_GuestOsFeature();
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseInstance_ShieldedInstanceConfig(): Instance_ShieldedInstanceConfig {
  return { enableSecureBoot: false, enableVtpm: false, enableIntegrityMonitoring: false };
}

export const Instance_ShieldedInstanceConfig: MessageFns<Instance_ShieldedInstanceConfig> = {
  encode(message: Instance_ShieldedInstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSecureBoot !== false) {
      writer.uint32(8).bool(message.enableSecureBoot);
    }
    if (message.enableVtpm !== false) {
      writer.uint32(16).bool(message.enableVtpm);
    }
    if (message.enableIntegrityMonitoring !== false) {
      writer.uint32(24).bool(message.enableIntegrityMonitoring);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_ShieldedInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_ShieldedInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enableSecureBoot = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableVtpm = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enableIntegrityMonitoring = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_ShieldedInstanceConfig {
    return {
      enableSecureBoot: isSet(object.enableSecureBoot) ? globalThis.Boolean(object.enableSecureBoot) : false,
      enableVtpm: isSet(object.enableVtpm) ? globalThis.Boolean(object.enableVtpm) : false,
      enableIntegrityMonitoring: isSet(object.enableIntegrityMonitoring)
        ? globalThis.Boolean(object.enableIntegrityMonitoring)
        : false,
    };
  },

  toJSON(message: Instance_ShieldedInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableSecureBoot !== false) {
      obj.enableSecureBoot = message.enableSecureBoot;
    }
    if (message.enableVtpm !== false) {
      obj.enableVtpm = message.enableVtpm;
    }
    if (message.enableIntegrityMonitoring !== false) {
      obj.enableIntegrityMonitoring = message.enableIntegrityMonitoring;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_ShieldedInstanceConfig>, I>>(base?: I): Instance_ShieldedInstanceConfig {
    return Instance_ShieldedInstanceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_ShieldedInstanceConfig>, I>>(
    object: I,
  ): Instance_ShieldedInstanceConfig {
    const message = createBaseInstance_ShieldedInstanceConfig();
    message.enableSecureBoot = object.enableSecureBoot ?? false;
    message.enableVtpm = object.enableVtpm ?? false;
    message.enableIntegrityMonitoring = object.enableIntegrityMonitoring ?? false;
    return message;
  },
};

function createBaseInstance_UpgradeHistoryEntry(): Instance_UpgradeHistoryEntry {
  return {
    snapshot: "",
    vmImage: "",
    containerImage: "",
    framework: "",
    version: "",
    state: 0,
    createTime: undefined,
    targetImage: "",
    action: 0,
    targetVersion: "",
  };
}

export const Instance_UpgradeHistoryEntry: MessageFns<Instance_UpgradeHistoryEntry> = {
  encode(message: Instance_UpgradeHistoryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshot !== "") {
      writer.uint32(10).string(message.snapshot);
    }
    if (message.vmImage !== "") {
      writer.uint32(18).string(message.vmImage);
    }
    if (message.containerImage !== "") {
      writer.uint32(26).string(message.containerImage);
    }
    if (message.framework !== "") {
      writer.uint32(34).string(message.framework);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.targetImage !== "") {
      writer.uint32(66).string(message.targetImage);
    }
    if (message.action !== 0) {
      writer.uint32(72).int32(message.action);
    }
    if (message.targetVersion !== "") {
      writer.uint32(82).string(message.targetVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_UpgradeHistoryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_UpgradeHistoryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.snapshot = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vmImage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.containerImage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.framework = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.targetImage = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_UpgradeHistoryEntry {
    return {
      snapshot: isSet(object.snapshot) ? globalThis.String(object.snapshot) : "",
      vmImage: isSet(object.vmImage) ? globalThis.String(object.vmImage) : "",
      containerImage: isSet(object.containerImage) ? globalThis.String(object.containerImage) : "",
      framework: isSet(object.framework) ? globalThis.String(object.framework) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      state: isSet(object.state) ? instance_UpgradeHistoryEntry_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      targetImage: isSet(object.targetImage) ? globalThis.String(object.targetImage) : "",
      action: isSet(object.action) ? instance_UpgradeHistoryEntry_ActionFromJSON(object.action) : 0,
      targetVersion: isSet(object.targetVersion) ? globalThis.String(object.targetVersion) : "",
    };
  },

  toJSON(message: Instance_UpgradeHistoryEntry): unknown {
    const obj: any = {};
    if (message.snapshot !== "") {
      obj.snapshot = message.snapshot;
    }
    if (message.vmImage !== "") {
      obj.vmImage = message.vmImage;
    }
    if (message.containerImage !== "") {
      obj.containerImage = message.containerImage;
    }
    if (message.framework !== "") {
      obj.framework = message.framework;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.state !== 0) {
      obj.state = instance_UpgradeHistoryEntry_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.targetImage !== "") {
      obj.targetImage = message.targetImage;
    }
    if (message.action !== 0) {
      obj.action = instance_UpgradeHistoryEntry_ActionToJSON(message.action);
    }
    if (message.targetVersion !== "") {
      obj.targetVersion = message.targetVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_UpgradeHistoryEntry>, I>>(base?: I): Instance_UpgradeHistoryEntry {
    return Instance_UpgradeHistoryEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_UpgradeHistoryEntry>, I>>(object: I): Instance_UpgradeHistoryEntry {
    const message = createBaseInstance_UpgradeHistoryEntry();
    message.snapshot = object.snapshot ?? "";
    message.vmImage = object.vmImage ?? "";
    message.containerImage = object.containerImage ?? "";
    message.framework = object.framework ?? "";
    message.version = object.version ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.targetImage = object.targetImage ?? "";
    message.action = object.action ?? 0;
    message.targetVersion = object.targetVersion ?? "";
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_LabelsEntry>, I>>(base?: I): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_LabelsEntry>, I>>(object: I): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInstance_MetadataEntry(): Instance_MetadataEntry {
  return { key: "", value: "" };
}

export const Instance_MetadataEntry: MessageFns<Instance_MetadataEntry> = {
  encode(message: Instance_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_MetadataEntry>, I>>(base?: I): Instance_MetadataEntry {
    return Instance_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_MetadataEntry>, I>>(object: I): Instance_MetadataEntry {
    const message = createBaseInstance_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSchedule(): Schedule {
  return {
    name: "",
    displayName: "",
    description: "",
    state: 0,
    cronSchedule: "",
    timeZone: "",
    createTime: undefined,
    updateTime: undefined,
    executionTemplate: undefined,
    recentExecutions: [],
  };
}

export const Schedule: MessageFns<Schedule> = {
  encode(message: Schedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.cronSchedule !== "") {
      writer.uint32(42).string(message.cronSchedule);
    }
    if (message.timeZone !== "") {
      writer.uint32(50).string(message.timeZone);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.executionTemplate !== undefined) {
      ExecutionTemplate.encode(message.executionTemplate, writer.uint32(74).fork()).join();
    }
    for (const v of message.recentExecutions) {
      Execution.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cronSchedule = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.executionTemplate = ExecutionTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.recentExecutions.push(Execution.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schedule {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? schedule_StateFromJSON(object.state) : 0,
      cronSchedule: isSet(object.cronSchedule) ? globalThis.String(object.cronSchedule) : "",
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      executionTemplate: isSet(object.executionTemplate)
        ? ExecutionTemplate.fromJSON(object.executionTemplate)
        : undefined,
      recentExecutions: globalThis.Array.isArray(object?.recentExecutions)
        ? object.recentExecutions.map((e: any) => Execution.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Schedule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = schedule_StateToJSON(message.state);
    }
    if (message.cronSchedule !== "") {
      obj.cronSchedule = message.cronSchedule;
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.executionTemplate !== undefined) {
      obj.executionTemplate = ExecutionTemplate.toJSON(message.executionTemplate);
    }
    if (message.recentExecutions?.length) {
      obj.recentExecutions = message.recentExecutions.map((e) => Execution.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Schedule>, I>>(base?: I): Schedule {
    return Schedule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Schedule>, I>>(object: I): Schedule {
    const message = createBaseSchedule();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.cronSchedule = object.cronSchedule ?? "";
    message.timeZone = object.timeZone ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.executionTemplate = (object.executionTemplate !== undefined && object.executionTemplate !== null)
      ? ExecutionTemplate.fromPartial(object.executionTemplate)
      : undefined;
    message.recentExecutions = object.recentExecutions?.map((e) => Execution.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRuntimeEventData(): RuntimeEventData {
  return { payload: undefined };
}

export const RuntimeEventData: MessageFns<RuntimeEventData> = {
  encode(message: RuntimeEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Runtime.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Runtime.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeEventData {
    return { payload: isSet(object.payload) ? Runtime.fromJSON(object.payload) : undefined };
  },

  toJSON(message: RuntimeEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Runtime.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeEventData>, I>>(base?: I): RuntimeEventData {
    return RuntimeEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeEventData>, I>>(object: I): RuntimeEventData {
    const message = createBaseRuntimeEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Runtime.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseExecutionEventData(): ExecutionEventData {
  return { payload: undefined };
}

export const ExecutionEventData: MessageFns<ExecutionEventData> = {
  encode(message: ExecutionEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Execution.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Execution.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionEventData {
    return { payload: isSet(object.payload) ? Execution.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ExecutionEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Execution.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionEventData>, I>>(base?: I): ExecutionEventData {
    return ExecutionEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionEventData>, I>>(object: I): ExecutionEventData {
    const message = createBaseExecutionEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Execution.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseInstanceEventData(): InstanceEventData {
  return { payload: undefined };
}

export const InstanceEventData: MessageFns<InstanceEventData> = {
  encode(message: InstanceEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Instance.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Instance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceEventData {
    return { payload: isSet(object.payload) ? Instance.fromJSON(object.payload) : undefined };
  },

  toJSON(message: InstanceEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Instance.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceEventData>, I>>(base?: I): InstanceEventData {
    return InstanceEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceEventData>, I>>(object: I): InstanceEventData {
    const message = createBaseInstanceEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Instance.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseScheduleEventData(): ScheduleEventData {
  return { payload: undefined };
}

export const ScheduleEventData: MessageFns<ScheduleEventData> = {
  encode(message: ScheduleEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Schedule.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Schedule.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleEventData {
    return { payload: isSet(object.payload) ? Schedule.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ScheduleEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Schedule.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleEventData>, I>>(base?: I): ScheduleEventData {
    return ScheduleEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleEventData>, I>>(object: I): ScheduleEventData {
    const message = createBaseScheduleEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Schedule.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseEnvironmentEventData(): EnvironmentEventData {
  return { payload: undefined };
}

export const EnvironmentEventData: MessageFns<EnvironmentEventData> = {
  encode(message: EnvironmentEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Environment.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Environment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentEventData {
    return { payload: isSet(object.payload) ? Environment.fromJSON(object.payload) : undefined };
  },

  toJSON(message: EnvironmentEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Environment.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvironmentEventData>, I>>(base?: I): EnvironmentEventData {
    return EnvironmentEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvironmentEventData>, I>>(object: I): EnvironmentEventData {
    const message = createBaseEnvironmentEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Environment.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
