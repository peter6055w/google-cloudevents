// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/redis/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration";
import { Timestamp } from "../../../../protobuf/timestamp";
import { DayOfWeek, dayOfWeekFromJSON, dayOfWeekToJSON } from "../../../../type/dayofweek";
import { TimeOfDay } from "../../../../type/timeofday";

export const protobufPackage = "google.events.cloud.redis.v1";

/** Node specific properties. */
export interface NodeInfo {
  /** Output only. Node identifying string. e.g. 'node-0', 'node-1' */
  id: string;
  /** Output only. Location of the node. */
  zone: string;
}

/** A Memorystore for Redis instance. */
export interface Instance {
  /**
   * Required. Unique name of the resource in this scope including project and
   * location using the form:
   *     `projects/{project_id}/locations/{location_id}/instances/{instance_id}`
   *
   * Note: Redis instances are managed and addressed at regional level so
   * location_id here refers to a GCP region; however, users may choose which
   * specific zone (or collection of zones for cross-zone instances) an instance
   * should be provisioned in. Refer to
   * [location_id][google.cloud.redis.v1.Instance.location_id] and
   * [alternative_location_id][google.cloud.redis.v1.Instance.alternative_location_id]
   * fields for more details.
   */
  name: string;
  /** An arbitrary and optional user-provided name for the instance. */
  displayName: string;
  /** Resource labels to represent user provided metadata */
  labels: { [key: string]: string };
  /**
   * Optional. The zone where the instance will be provisioned. If not provided,
   * the service will choose a zone from the specified region for the instance.
   * For standard tier, additional nodes will be added across multiple zones for
   * protection against zonal failures. If specified, at least one node will be
   * provisioned in this zone.
   */
  locationId: string;
  /**
   * Optional. If specified, at least one node will be provisioned in this zone
   * in addition to the zone specified in location_id. Only applicable to
   * standard tier. If provided, it must be a different zone from the one
   * provided in [location_id]. Additional nodes beyond the first 2 will be
   * placed in zones selected by the service.
   */
  alternativeLocationId: string;
  /**
   * Optional. The version of Redis software.
   * If not provided, latest supported version will be used. Currently, the
   * supported values are:
   *
   *  *   `REDIS_3_2` for Redis 3.2 compatibility
   *  *   `REDIS_4_0` for Redis 4.0 compatibility (default)
   *  *   `REDIS_5_0` for Redis 5.0 compatibility
   *  *   `REDIS_6_X` for Redis 6.x compatibility
   */
  redisVersion: string;
  /**
   * Optional. For DIRECT_PEERING mode, the CIDR range of internal addresses
   * that are reserved for this instance. Range must
   * be unique and non-overlapping with existing subnets in an authorized
   * network. For PRIVATE_SERVICE_ACCESS mode, the name of one allocated IP
   * address ranges associated with this private service access connection.
   * If not provided, the service will choose an unused /29 block, for
   * example, 10.0.0.0/29 or 192.168.0.0/29.  For READ_REPLICAS_ENABLED
   * the default block size is /28.
   */
  reservedIpRange: string;
  /**
   * Optional. Additional IP range for node placement. Required when enabling
   * read replicas on an existing instance. For DIRECT_PEERING mode value must
   * be a CIDR range of size /28, or "auto". For PRIVATE_SERVICE_ACCESS mode
   * value must be the name of an allocated address range associated with the
   * private service access connection, or "auto".
   */
  secondaryIpRange: string;
  /**
   * Output only. Hostname or IP address of the exposed Redis endpoint used by
   * clients to connect to the service.
   */
  host: string;
  /** Output only. The port number of the exposed Redis endpoint. */
  port: number;
  /**
   * Output only. The current zone where the Redis primary node is located. In
   * basic tier, this will always be the same as [location_id]. In
   * standard tier, this can be the zone of any node in the instance.
   */
  currentLocationId: string;
  /** Output only. The time the instance was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The current state of this instance. */
  state: Instance_State;
  /**
   * Output only. Additional information about the current status of this
   * instance, if available.
   */
  statusMessage: string;
  /**
   * Optional. Redis configuration parameters, according to
   * http://redis.io/topics/config. Currently, the only supported parameters
   * are:
   *
   *  Redis version 3.2 and newer:
   *
   *  *   maxmemory-policy
   *  *   notify-keyspace-events
   *
   *  Redis version 4.0 and newer:
   *
   *  *   activedefrag
   *  *   lfu-decay-time
   *  *   lfu-log-factor
   *  *   maxmemory-gb
   *
   *  Redis version 5.0 and newer:
   *
   *  *   stream-node-max-bytes
   *  *   stream-node-max-entries
   */
  redisConfigs: { [key: string]: string };
  /** Required. The service tier of the instance. */
  tier: Instance_Tier;
  /** Required. Redis memory size in GiB. */
  memorySizeGb: number;
  /**
   * Optional. The full name of the Google Compute Engine
   * [network](https://cloud.google.com/vpc/docs/vpc) to which the
   * instance is connected. If left unspecified, the `default` network
   * will be used.
   */
  authorizedNetwork: string;
  /**
   * Output only. Cloud IAM identity used by import / export operations to
   * transfer data to/from Cloud Storage. Format is
   * "serviceAccount:<service_account_email>". The value may change over time
   * for a given instance so should be checked before each import/export
   * operation.
   */
  persistenceIamIdentity: string;
  /**
   * Optional. The network connect mode of the Redis instance.
   * If not provided, the connect mode defaults to DIRECT_PEERING.
   */
  connectMode: Instance_ConnectMode;
  /**
   * Optional. Indicates whether OSS Redis AUTH is enabled for the instance. If
   * set to "true" AUTH is enabled on the instance. Default value is "false"
   * meaning AUTH is disabled.
   */
  authEnabled: boolean;
  /** Output only. List of server CA certificates for the instance. */
  serverCaCerts: TlsCertificate[];
  /**
   * Optional. The TLS mode of the Redis instance.
   * If not provided, TLS is disabled for the instance.
   */
  transitEncryptionMode: Instance_TransitEncryptionMode;
  /**
   * Optional. The maintenance policy for the instance. If not provided,
   * maintenance events can be performed at any time.
   */
  maintenancePolicy?:
    | MaintenancePolicy
    | undefined;
  /**
   * Output only. Date and time of upcoming maintenance events which have been
   * scheduled.
   */
  maintenanceSchedule?:
    | MaintenanceSchedule
    | undefined;
  /**
   * Optional. The number of replica nodes. The valid range for the Standard
   * Tier with read replicas enabled is [1-5] and defaults to 2. If read
   * replicas are not enabled for a Standard Tier instance, the only valid value
   * is 1 and the default is 1. The valid value for basic tier is 0 and the
   * default is also 0.
   */
  replicaCount: number;
  /** Output only. Info per node. */
  nodes: NodeInfo[];
  /**
   * Output only. Hostname or IP address of the exposed readonly Redis
   * endpoint. Standard tier only. Targets all healthy replica nodes in
   * instance. Replication is asynchronous and replica nodes will exhibit some
   * lag behind the primary. Write requests must target 'host'.
   */
  readEndpoint: string;
  /**
   * Output only. The port number of the exposed readonly redis
   * endpoint. Standard tier only. Write requests should target 'port'.
   */
  readEndpointPort: number;
  /**
   * Optional. Read replicas mode for the instance. Defaults to
   * READ_REPLICAS_DISABLED.
   */
  readReplicasMode: Instance_ReadReplicasMode;
  /**
   * Optional. The KMS key reference that the customer provides when trying to
   * create the instance.
   */
  customerManagedKey: string;
  /** Optional. Persistence configuration parameters */
  persistenceConfig?:
    | PersistenceConfig
    | undefined;
  /** Optional. reasons that causes instance in "SUSPENDED" state. */
  suspensionReasons: Instance_SuspensionReason[];
  /**
   * Optional. The self service update maintenance version.
   * The version is date based such as "20210712_00_00".
   */
  maintenanceVersion: string;
  /**
   * Optional. The available maintenance versions that an instance could update
   * to.
   */
  availableMaintenanceVersions: string[];
}

/** Represents the different states of a Redis instance. */
export enum Instance_State {
  /** STATE_UNSPECIFIED - Not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - Redis instance is being created. */
  CREATING = 1,
  /** READY - Redis instance has been created and is fully usable. */
  READY = 2,
  /**
   * UPDATING - Redis instance configuration is being updated. Certain kinds of updates
   * may cause the instance to become unusable while the update is in
   * progress.
   */
  UPDATING = 3,
  /** DELETING - Redis instance is being deleted. */
  DELETING = 4,
  /** REPAIRING - Redis instance is being repaired and may be unusable. */
  REPAIRING = 5,
  /** MAINTENANCE - Maintenance is being performed on this Redis instance. */
  MAINTENANCE = 6,
  /** IMPORTING - Redis instance is importing data (availability may be affected). */
  IMPORTING = 8,
  /** FAILING_OVER - Redis instance is failing over (availability may be affected). */
  FAILING_OVER = 9,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Instance_State.CREATING;
    case 2:
    case "READY":
      return Instance_State.READY;
    case 3:
    case "UPDATING":
      return Instance_State.UPDATING;
    case 4:
    case "DELETING":
      return Instance_State.DELETING;
    case 5:
    case "REPAIRING":
      return Instance_State.REPAIRING;
    case 6:
    case "MAINTENANCE":
      return Instance_State.MAINTENANCE;
    case 8:
    case "IMPORTING":
      return Instance_State.IMPORTING;
    case 9:
    case "FAILING_OVER":
      return Instance_State.FAILING_OVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.CREATING:
      return "CREATING";
    case Instance_State.READY:
      return "READY";
    case Instance_State.UPDATING:
      return "UPDATING";
    case Instance_State.DELETING:
      return "DELETING";
    case Instance_State.REPAIRING:
      return "REPAIRING";
    case Instance_State.MAINTENANCE:
      return "MAINTENANCE";
    case Instance_State.IMPORTING:
      return "IMPORTING";
    case Instance_State.FAILING_OVER:
      return "FAILING_OVER";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available service tiers to choose from */
export enum Instance_Tier {
  /** TIER_UNSPECIFIED - Not set. */
  TIER_UNSPECIFIED = 0,
  /** BASIC - BASIC tier: standalone instance */
  BASIC = 1,
  /** STANDARD_HA - STANDARD_HA tier: highly available primary/replica instances */
  STANDARD_HA = 3,
  UNRECOGNIZED = -1,
}

export function instance_TierFromJSON(object: any): Instance_Tier {
  switch (object) {
    case 0:
    case "TIER_UNSPECIFIED":
      return Instance_Tier.TIER_UNSPECIFIED;
    case 1:
    case "BASIC":
      return Instance_Tier.BASIC;
    case 3:
    case "STANDARD_HA":
      return Instance_Tier.STANDARD_HA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_Tier.UNRECOGNIZED;
  }
}

export function instance_TierToJSON(object: Instance_Tier): string {
  switch (object) {
    case Instance_Tier.TIER_UNSPECIFIED:
      return "TIER_UNSPECIFIED";
    case Instance_Tier.BASIC:
      return "BASIC";
    case Instance_Tier.STANDARD_HA:
      return "STANDARD_HA";
    case Instance_Tier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available connection modes. */
export enum Instance_ConnectMode {
  /** CONNECT_MODE_UNSPECIFIED - Not set. */
  CONNECT_MODE_UNSPECIFIED = 0,
  /** DIRECT_PEERING - Connect via direct peering to the Memorystore for Redis hosted service. */
  DIRECT_PEERING = 1,
  /**
   * PRIVATE_SERVICE_ACCESS - Connect your Memorystore for Redis instance using Private Service
   * Access. Private services access provides an IP address range for multiple
   * Google Cloud services, including Memorystore.
   */
  PRIVATE_SERVICE_ACCESS = 2,
  UNRECOGNIZED = -1,
}

export function instance_ConnectModeFromJSON(object: any): Instance_ConnectMode {
  switch (object) {
    case 0:
    case "CONNECT_MODE_UNSPECIFIED":
      return Instance_ConnectMode.CONNECT_MODE_UNSPECIFIED;
    case 1:
    case "DIRECT_PEERING":
      return Instance_ConnectMode.DIRECT_PEERING;
    case 2:
    case "PRIVATE_SERVICE_ACCESS":
      return Instance_ConnectMode.PRIVATE_SERVICE_ACCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_ConnectMode.UNRECOGNIZED;
  }
}

export function instance_ConnectModeToJSON(object: Instance_ConnectMode): string {
  switch (object) {
    case Instance_ConnectMode.CONNECT_MODE_UNSPECIFIED:
      return "CONNECT_MODE_UNSPECIFIED";
    case Instance_ConnectMode.DIRECT_PEERING:
      return "DIRECT_PEERING";
    case Instance_ConnectMode.PRIVATE_SERVICE_ACCESS:
      return "PRIVATE_SERVICE_ACCESS";
    case Instance_ConnectMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available TLS modes. */
export enum Instance_TransitEncryptionMode {
  /** TRANSIT_ENCRYPTION_MODE_UNSPECIFIED - Not set. */
  TRANSIT_ENCRYPTION_MODE_UNSPECIFIED = 0,
  /** SERVER_AUTHENTICATION - Client to Server traffic encryption enabled with server authentication. */
  SERVER_AUTHENTICATION = 1,
  /** DISABLED - TLS is disabled for the instance. */
  DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function instance_TransitEncryptionModeFromJSON(object: any): Instance_TransitEncryptionMode {
  switch (object) {
    case 0:
    case "TRANSIT_ENCRYPTION_MODE_UNSPECIFIED":
      return Instance_TransitEncryptionMode.TRANSIT_ENCRYPTION_MODE_UNSPECIFIED;
    case 1:
    case "SERVER_AUTHENTICATION":
      return Instance_TransitEncryptionMode.SERVER_AUTHENTICATION;
    case 2:
    case "DISABLED":
      return Instance_TransitEncryptionMode.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_TransitEncryptionMode.UNRECOGNIZED;
  }
}

export function instance_TransitEncryptionModeToJSON(object: Instance_TransitEncryptionMode): string {
  switch (object) {
    case Instance_TransitEncryptionMode.TRANSIT_ENCRYPTION_MODE_UNSPECIFIED:
      return "TRANSIT_ENCRYPTION_MODE_UNSPECIFIED";
    case Instance_TransitEncryptionMode.SERVER_AUTHENTICATION:
      return "SERVER_AUTHENTICATION";
    case Instance_TransitEncryptionMode.DISABLED:
      return "DISABLED";
    case Instance_TransitEncryptionMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Read replicas mode. */
export enum Instance_ReadReplicasMode {
  /**
   * READ_REPLICAS_MODE_UNSPECIFIED - If not set, Memorystore Redis backend will default to
   * READ_REPLICAS_DISABLED.
   */
  READ_REPLICAS_MODE_UNSPECIFIED = 0,
  /**
   * READ_REPLICAS_DISABLED - If disabled, read endpoint will not be provided and the instance cannot
   * scale up or down the number of replicas.
   */
  READ_REPLICAS_DISABLED = 1,
  /**
   * READ_REPLICAS_ENABLED - If enabled, read endpoint will be provided and the instance can scale
   * up and down the number of replicas. Not valid for basic tier.
   */
  READ_REPLICAS_ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function instance_ReadReplicasModeFromJSON(object: any): Instance_ReadReplicasMode {
  switch (object) {
    case 0:
    case "READ_REPLICAS_MODE_UNSPECIFIED":
      return Instance_ReadReplicasMode.READ_REPLICAS_MODE_UNSPECIFIED;
    case 1:
    case "READ_REPLICAS_DISABLED":
      return Instance_ReadReplicasMode.READ_REPLICAS_DISABLED;
    case 2:
    case "READ_REPLICAS_ENABLED":
      return Instance_ReadReplicasMode.READ_REPLICAS_ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_ReadReplicasMode.UNRECOGNIZED;
  }
}

export function instance_ReadReplicasModeToJSON(object: Instance_ReadReplicasMode): string {
  switch (object) {
    case Instance_ReadReplicasMode.READ_REPLICAS_MODE_UNSPECIFIED:
      return "READ_REPLICAS_MODE_UNSPECIFIED";
    case Instance_ReadReplicasMode.READ_REPLICAS_DISABLED:
      return "READ_REPLICAS_DISABLED";
    case Instance_ReadReplicasMode.READ_REPLICAS_ENABLED:
      return "READ_REPLICAS_ENABLED";
    case Instance_ReadReplicasMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible reasons for the instance to be in a "SUSPENDED" state. */
export enum Instance_SuspensionReason {
  /** SUSPENSION_REASON_UNSPECIFIED - Not set. */
  SUSPENSION_REASON_UNSPECIFIED = 0,
  /** CUSTOMER_MANAGED_KEY_ISSUE - Something wrong with the CMEK key provided by customer. */
  CUSTOMER_MANAGED_KEY_ISSUE = 1,
  UNRECOGNIZED = -1,
}

export function instance_SuspensionReasonFromJSON(object: any): Instance_SuspensionReason {
  switch (object) {
    case 0:
    case "SUSPENSION_REASON_UNSPECIFIED":
      return Instance_SuspensionReason.SUSPENSION_REASON_UNSPECIFIED;
    case 1:
    case "CUSTOMER_MANAGED_KEY_ISSUE":
      return Instance_SuspensionReason.CUSTOMER_MANAGED_KEY_ISSUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_SuspensionReason.UNRECOGNIZED;
  }
}

export function instance_SuspensionReasonToJSON(object: Instance_SuspensionReason): string {
  switch (object) {
    case Instance_SuspensionReason.SUSPENSION_REASON_UNSPECIFIED:
      return "SUSPENSION_REASON_UNSPECIFIED";
    case Instance_SuspensionReason.CUSTOMER_MANAGED_KEY_ISSUE:
      return "CUSTOMER_MANAGED_KEY_ISSUE";
    case Instance_SuspensionReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

export interface Instance_RedisConfigsEntry {
  key: string;
  value: string;
}

/** Configuration of the persistence functionality. */
export interface PersistenceConfig {
  /**
   * Optional. Controls whether Persistence features are enabled.
   * If not provided, the existing value will be used.
   */
  persistenceMode: PersistenceConfig_PersistenceMode;
  /**
   * Optional. Period between RDB snapshots. Snapshots will be attempted every
   * period starting from the provided snapshot start time. For example, a start
   * time of 01/01/2033 06:45 and SIX_HOURS snapshot period will do nothing
   * until 01/01/2033, and then trigger snapshots every day at 06:45, 12:45,
   * 18:45, and 00:45 the next day, and so on. If not provided,
   * TWENTY_FOUR_HOURS will be used as default.
   */
  rdbSnapshotPeriod: PersistenceConfig_SnapshotPeriod;
  /** Output only. The next time that a snapshot attempt is scheduled to occur. */
  rdbNextSnapshotTime?:
    | Date
    | undefined;
  /**
   * Optional. Date and time that the first snapshot was/will be attempted, and
   * to which future snapshots will be aligned. If not provided, the current
   * time will be used.
   */
  rdbSnapshotStartTime?: Date | undefined;
}

/** Available Persistence modes. */
export enum PersistenceConfig_PersistenceMode {
  /** PERSISTENCE_MODE_UNSPECIFIED - Not set. */
  PERSISTENCE_MODE_UNSPECIFIED = 0,
  /**
   * DISABLED - Persistence is disabled for the instance,
   * and any existing snapshots are deleted.
   */
  DISABLED = 1,
  /** RDB - RDB based Persistence is enabled. */
  RDB = 2,
  UNRECOGNIZED = -1,
}

export function persistenceConfig_PersistenceModeFromJSON(object: any): PersistenceConfig_PersistenceMode {
  switch (object) {
    case 0:
    case "PERSISTENCE_MODE_UNSPECIFIED":
      return PersistenceConfig_PersistenceMode.PERSISTENCE_MODE_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return PersistenceConfig_PersistenceMode.DISABLED;
    case 2:
    case "RDB":
      return PersistenceConfig_PersistenceMode.RDB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PersistenceConfig_PersistenceMode.UNRECOGNIZED;
  }
}

export function persistenceConfig_PersistenceModeToJSON(object: PersistenceConfig_PersistenceMode): string {
  switch (object) {
    case PersistenceConfig_PersistenceMode.PERSISTENCE_MODE_UNSPECIFIED:
      return "PERSISTENCE_MODE_UNSPECIFIED";
    case PersistenceConfig_PersistenceMode.DISABLED:
      return "DISABLED";
    case PersistenceConfig_PersistenceMode.RDB:
      return "RDB";
    case PersistenceConfig_PersistenceMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available snapshot periods for scheduling. */
export enum PersistenceConfig_SnapshotPeriod {
  /** SNAPSHOT_PERIOD_UNSPECIFIED - Not set. */
  SNAPSHOT_PERIOD_UNSPECIFIED = 0,
  /** ONE_HOUR - Snapshot every 1 hour. */
  ONE_HOUR = 3,
  /** SIX_HOURS - Snapshot every 6 hours. */
  SIX_HOURS = 4,
  /** TWELVE_HOURS - Snapshot every 12 hours. */
  TWELVE_HOURS = 5,
  /** TWENTY_FOUR_HOURS - Snapshot every 24 hours. */
  TWENTY_FOUR_HOURS = 6,
  UNRECOGNIZED = -1,
}

export function persistenceConfig_SnapshotPeriodFromJSON(object: any): PersistenceConfig_SnapshotPeriod {
  switch (object) {
    case 0:
    case "SNAPSHOT_PERIOD_UNSPECIFIED":
      return PersistenceConfig_SnapshotPeriod.SNAPSHOT_PERIOD_UNSPECIFIED;
    case 3:
    case "ONE_HOUR":
      return PersistenceConfig_SnapshotPeriod.ONE_HOUR;
    case 4:
    case "SIX_HOURS":
      return PersistenceConfig_SnapshotPeriod.SIX_HOURS;
    case 5:
    case "TWELVE_HOURS":
      return PersistenceConfig_SnapshotPeriod.TWELVE_HOURS;
    case 6:
    case "TWENTY_FOUR_HOURS":
      return PersistenceConfig_SnapshotPeriod.TWENTY_FOUR_HOURS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PersistenceConfig_SnapshotPeriod.UNRECOGNIZED;
  }
}

export function persistenceConfig_SnapshotPeriodToJSON(object: PersistenceConfig_SnapshotPeriod): string {
  switch (object) {
    case PersistenceConfig_SnapshotPeriod.SNAPSHOT_PERIOD_UNSPECIFIED:
      return "SNAPSHOT_PERIOD_UNSPECIFIED";
    case PersistenceConfig_SnapshotPeriod.ONE_HOUR:
      return "ONE_HOUR";
    case PersistenceConfig_SnapshotPeriod.SIX_HOURS:
      return "SIX_HOURS";
    case PersistenceConfig_SnapshotPeriod.TWELVE_HOURS:
      return "TWELVE_HOURS";
    case PersistenceConfig_SnapshotPeriod.TWENTY_FOUR_HOURS:
      return "TWENTY_FOUR_HOURS";
    case PersistenceConfig_SnapshotPeriod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Maintenance policy for an instance. */
export interface MaintenancePolicy {
  /** Output only. The time when the policy was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time when the policy was last updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. Description of what this policy is for. Create/Update methods
   * return INVALID_ARGUMENT if the length is greater than 512.
   */
  description: string;
  /**
   * Optional. Maintenance window that is applied to resources covered by this
   * policy. Minimum 1. For the current version, the maximum number of
   * weekly_window is expected to be one.
   */
  weeklyMaintenanceWindow: WeeklyMaintenanceWindow[];
}

/**
 * Time window in which disruptive maintenance updates occur. Non-disruptive
 * updates can occur inside or outside this window.
 */
export interface WeeklyMaintenanceWindow {
  /** Required. The day of week that maintenance updates occur. */
  day: DayOfWeek;
  /** Required. Start time of the window in UTC time. */
  startTime?:
    | TimeOfDay
    | undefined;
  /**
   * Output only. Duration of the maintenance window. The current window is
   * fixed at 1 hour.
   */
  duration?: Duration | undefined;
}

/**
 * Upcoming maintenance schedule. If no maintenance is scheduled, fields are not
 * populated.
 */
export interface MaintenanceSchedule {
  /**
   * Output only. The start time of any upcoming scheduled maintenance for this
   * instance.
   */
  startTime?:
    | Date
    | undefined;
  /**
   * Output only. The end time of any upcoming scheduled maintenance for this
   * instance.
   */
  endTime?:
    | Date
    | undefined;
  /** If the scheduled maintenance can be rescheduled, default is true. */
  canReschedule: boolean;
  /**
   * Output only. The deadline that the maintenance schedule start time can not
   * go beyond, including reschedule.
   */
  scheduleDeadlineTime?: Date | undefined;
}

/** TlsCertificate Resource */
export interface TlsCertificate {
  /** Serial number, as extracted from the certificate. */
  serialNumber: string;
  /**
   * Output only. The time when the certificate was created in [RFC
   * 3339](https://tools.ietf.org/html/rfc3339) format, for example
   * `2020-05-18T00:00:00.094Z`.
   */
  createTime?:
    | Date
    | undefined;
  /**
   * Output only. The time when the certificate expires in [RFC
   * 3339](https://tools.ietf.org/html/rfc3339) format, for example
   * `2020-05-18T00:00:00.094Z`.
   */
  expireTime?:
    | Date
    | undefined;
  /** Sha1 Fingerprint of the certificate. */
  sha1Fingerprint: string;
}

/** The data within all Instance events. */
export interface InstanceEventData {
  /** Optional. The Instance event payload. Unset for deletion events. */
  payload?: Instance | undefined;
}

function createBaseNodeInfo(): NodeInfo {
  return { id: "", zone: "" };
}

export const NodeInfo: MessageFns<NodeInfo> = {
  encode(message: NodeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
    };
  },

  toJSON(message: NodeInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfo>, I>>(base?: I): NodeInfo {
    return NodeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfo>, I>>(object: I): NodeInfo {
    const message = createBaseNodeInfo();
    message.id = object.id ?? "";
    message.zone = object.zone ?? "";
    return message;
  },
};

function createBaseInstance(): Instance {
  return {
    name: "",
    displayName: "",
    labels: {},
    locationId: "",
    alternativeLocationId: "",
    redisVersion: "",
    reservedIpRange: "",
    secondaryIpRange: "",
    host: "",
    port: 0,
    currentLocationId: "",
    createTime: undefined,
    state: 0,
    statusMessage: "",
    redisConfigs: {},
    tier: 0,
    memorySizeGb: 0,
    authorizedNetwork: "",
    persistenceIamIdentity: "",
    connectMode: 0,
    authEnabled: false,
    serverCaCerts: [],
    transitEncryptionMode: 0,
    maintenancePolicy: undefined,
    maintenanceSchedule: undefined,
    replicaCount: 0,
    nodes: [],
    readEndpoint: "",
    readEndpointPort: 0,
    readReplicasMode: 0,
    customerManagedKey: "",
    persistenceConfig: undefined,
    suspensionReasons: [],
    maintenanceVersion: "",
    availableMaintenanceVersions: [],
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.locationId !== "") {
      writer.uint32(34).string(message.locationId);
    }
    if (message.alternativeLocationId !== "") {
      writer.uint32(42).string(message.alternativeLocationId);
    }
    if (message.redisVersion !== "") {
      writer.uint32(58).string(message.redisVersion);
    }
    if (message.reservedIpRange !== "") {
      writer.uint32(74).string(message.reservedIpRange);
    }
    if (message.secondaryIpRange !== "") {
      writer.uint32(242).string(message.secondaryIpRange);
    }
    if (message.host !== "") {
      writer.uint32(82).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(88).int32(message.port);
    }
    if (message.currentLocationId !== "") {
      writer.uint32(98).string(message.currentLocationId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(106).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(112).int32(message.state);
    }
    if (message.statusMessage !== "") {
      writer.uint32(122).string(message.statusMessage);
    }
    Object.entries(message.redisConfigs).forEach(([key, value]) => {
      Instance_RedisConfigsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.tier !== 0) {
      writer.uint32(136).int32(message.tier);
    }
    if (message.memorySizeGb !== 0) {
      writer.uint32(144).int32(message.memorySizeGb);
    }
    if (message.authorizedNetwork !== "") {
      writer.uint32(162).string(message.authorizedNetwork);
    }
    if (message.persistenceIamIdentity !== "") {
      writer.uint32(170).string(message.persistenceIamIdentity);
    }
    if (message.connectMode !== 0) {
      writer.uint32(176).int32(message.connectMode);
    }
    if (message.authEnabled !== false) {
      writer.uint32(184).bool(message.authEnabled);
    }
    for (const v of message.serverCaCerts) {
      TlsCertificate.encode(v!, writer.uint32(202).fork()).join();
    }
    if (message.transitEncryptionMode !== 0) {
      writer.uint32(208).int32(message.transitEncryptionMode);
    }
    if (message.maintenancePolicy !== undefined) {
      MaintenancePolicy.encode(message.maintenancePolicy, writer.uint32(218).fork()).join();
    }
    if (message.maintenanceSchedule !== undefined) {
      MaintenanceSchedule.encode(message.maintenanceSchedule, writer.uint32(226).fork()).join();
    }
    if (message.replicaCount !== 0) {
      writer.uint32(248).int32(message.replicaCount);
    }
    for (const v of message.nodes) {
      NodeInfo.encode(v!, writer.uint32(258).fork()).join();
    }
    if (message.readEndpoint !== "") {
      writer.uint32(266).string(message.readEndpoint);
    }
    if (message.readEndpointPort !== 0) {
      writer.uint32(272).int32(message.readEndpointPort);
    }
    if (message.readReplicasMode !== 0) {
      writer.uint32(280).int32(message.readReplicasMode);
    }
    if (message.customerManagedKey !== "") {
      writer.uint32(290).string(message.customerManagedKey);
    }
    if (message.persistenceConfig !== undefined) {
      PersistenceConfig.encode(message.persistenceConfig, writer.uint32(298).fork()).join();
    }
    writer.uint32(306).fork();
    for (const v of message.suspensionReasons) {
      writer.int32(v);
    }
    writer.join();
    if (message.maintenanceVersion !== "") {
      writer.uint32(314).string(message.maintenanceVersion);
    }
    for (const v of message.availableMaintenanceVersions) {
      writer.uint32(322).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.alternativeLocationId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.redisVersion = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.reservedIpRange = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.secondaryIpRange = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.currentLocationId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          const entry16 = Instance_RedisConfigsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.redisConfigs[entry16.key] = entry16.value;
          }
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.memorySizeGb = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.authorizedNetwork = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.persistenceIamIdentity = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.connectMode = reader.int32() as any;
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.authEnabled = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.serverCaCerts.push(TlsCertificate.decode(reader, reader.uint32()));
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.transitEncryptionMode = reader.int32() as any;
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.maintenancePolicy = MaintenancePolicy.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.maintenanceSchedule = MaintenanceSchedule.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.replicaCount = reader.int32();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.nodes.push(NodeInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.readEndpoint = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.readEndpointPort = reader.int32();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.readReplicasMode = reader.int32() as any;
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.customerManagedKey = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.persistenceConfig = PersistenceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag === 304) {
            message.suspensionReasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 306) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.suspensionReasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.maintenanceVersion = reader.string();
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.availableMaintenanceVersions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      locationId: isSet(object.locationId) ? globalThis.String(object.locationId) : "",
      alternativeLocationId: isSet(object.alternativeLocationId) ? globalThis.String(object.alternativeLocationId) : "",
      redisVersion: isSet(object.redisVersion) ? globalThis.String(object.redisVersion) : "",
      reservedIpRange: isSet(object.reservedIpRange) ? globalThis.String(object.reservedIpRange) : "",
      secondaryIpRange: isSet(object.secondaryIpRange) ? globalThis.String(object.secondaryIpRange) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      currentLocationId: isSet(object.currentLocationId) ? globalThis.String(object.currentLocationId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      redisConfigs: isObject(object.redisConfigs)
        ? Object.entries(object.redisConfigs).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tier: isSet(object.tier) ? instance_TierFromJSON(object.tier) : 0,
      memorySizeGb: isSet(object.memorySizeGb) ? globalThis.Number(object.memorySizeGb) : 0,
      authorizedNetwork: isSet(object.authorizedNetwork) ? globalThis.String(object.authorizedNetwork) : "",
      persistenceIamIdentity: isSet(object.persistenceIamIdentity)
        ? globalThis.String(object.persistenceIamIdentity)
        : "",
      connectMode: isSet(object.connectMode) ? instance_ConnectModeFromJSON(object.connectMode) : 0,
      authEnabled: isSet(object.authEnabled) ? globalThis.Boolean(object.authEnabled) : false,
      serverCaCerts: globalThis.Array.isArray(object?.serverCaCerts)
        ? object.serverCaCerts.map((e: any) => TlsCertificate.fromJSON(e))
        : [],
      transitEncryptionMode: isSet(object.transitEncryptionMode)
        ? instance_TransitEncryptionModeFromJSON(object.transitEncryptionMode)
        : 0,
      maintenancePolicy: isSet(object.maintenancePolicy)
        ? MaintenancePolicy.fromJSON(object.maintenancePolicy)
        : undefined,
      maintenanceSchedule: isSet(object.maintenanceSchedule)
        ? MaintenanceSchedule.fromJSON(object.maintenanceSchedule)
        : undefined,
      replicaCount: isSet(object.replicaCount) ? globalThis.Number(object.replicaCount) : 0,
      nodes: globalThis.Array.isArray(object?.nodes)
        ? object.nodes.map((e: any) => NodeInfo.fromJSON(e))
        : [],
      readEndpoint: isSet(object.readEndpoint) ? globalThis.String(object.readEndpoint) : "",
      readEndpointPort: isSet(object.readEndpointPort) ? globalThis.Number(object.readEndpointPort) : 0,
      readReplicasMode: isSet(object.readReplicasMode) ? instance_ReadReplicasModeFromJSON(object.readReplicasMode) : 0,
      customerManagedKey: isSet(object.customerManagedKey) ? globalThis.String(object.customerManagedKey) : "",
      persistenceConfig: isSet(object.persistenceConfig)
        ? PersistenceConfig.fromJSON(object.persistenceConfig)
        : undefined,
      suspensionReasons: globalThis.Array.isArray(object?.suspensionReasons)
        ? object.suspensionReasons.map((e: any) => instance_SuspensionReasonFromJSON(e))
        : [],
      maintenanceVersion: isSet(object.maintenanceVersion) ? globalThis.String(object.maintenanceVersion) : "",
      availableMaintenanceVersions: globalThis.Array.isArray(object?.availableMaintenanceVersions)
        ? object.availableMaintenanceVersions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.locationId !== "") {
      obj.locationId = message.locationId;
    }
    if (message.alternativeLocationId !== "") {
      obj.alternativeLocationId = message.alternativeLocationId;
    }
    if (message.redisVersion !== "") {
      obj.redisVersion = message.redisVersion;
    }
    if (message.reservedIpRange !== "") {
      obj.reservedIpRange = message.reservedIpRange;
    }
    if (message.secondaryIpRange !== "") {
      obj.secondaryIpRange = message.secondaryIpRange;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.currentLocationId !== "") {
      obj.currentLocationId = message.currentLocationId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.redisConfigs) {
      const entries = Object.entries(message.redisConfigs);
      if (entries.length > 0) {
        obj.redisConfigs = {};
        entries.forEach(([k, v]) => {
          obj.redisConfigs[k] = v;
        });
      }
    }
    if (message.tier !== 0) {
      obj.tier = instance_TierToJSON(message.tier);
    }
    if (message.memorySizeGb !== 0) {
      obj.memorySizeGb = Math.round(message.memorySizeGb);
    }
    if (message.authorizedNetwork !== "") {
      obj.authorizedNetwork = message.authorizedNetwork;
    }
    if (message.persistenceIamIdentity !== "") {
      obj.persistenceIamIdentity = message.persistenceIamIdentity;
    }
    if (message.connectMode !== 0) {
      obj.connectMode = instance_ConnectModeToJSON(message.connectMode);
    }
    if (message.authEnabled !== false) {
      obj.authEnabled = message.authEnabled;
    }
    if (message.serverCaCerts?.length) {
      obj.serverCaCerts = message.serverCaCerts.map((e) => TlsCertificate.toJSON(e));
    }
    if (message.transitEncryptionMode !== 0) {
      obj.transitEncryptionMode = instance_TransitEncryptionModeToJSON(message.transitEncryptionMode);
    }
    if (message.maintenancePolicy !== undefined) {
      obj.maintenancePolicy = MaintenancePolicy.toJSON(message.maintenancePolicy);
    }
    if (message.maintenanceSchedule !== undefined) {
      obj.maintenanceSchedule = MaintenanceSchedule.toJSON(message.maintenanceSchedule);
    }
    if (message.replicaCount !== 0) {
      obj.replicaCount = Math.round(message.replicaCount);
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => NodeInfo.toJSON(e));
    }
    if (message.readEndpoint !== "") {
      obj.readEndpoint = message.readEndpoint;
    }
    if (message.readEndpointPort !== 0) {
      obj.readEndpointPort = Math.round(message.readEndpointPort);
    }
    if (message.readReplicasMode !== 0) {
      obj.readReplicasMode = instance_ReadReplicasModeToJSON(message.readReplicasMode);
    }
    if (message.customerManagedKey !== "") {
      obj.customerManagedKey = message.customerManagedKey;
    }
    if (message.persistenceConfig !== undefined) {
      obj.persistenceConfig = PersistenceConfig.toJSON(message.persistenceConfig);
    }
    if (message.suspensionReasons?.length) {
      obj.suspensionReasons = message.suspensionReasons.map((e) => instance_SuspensionReasonToJSON(e));
    }
    if (message.maintenanceVersion !== "") {
      obj.maintenanceVersion = message.maintenanceVersion;
    }
    if (message.availableMaintenanceVersions?.length) {
      obj.availableMaintenanceVersions = message.availableMaintenanceVersions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance>, I>>(base?: I): Instance {
    return Instance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance>, I>>(object: I): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.locationId = object.locationId ?? "";
    message.alternativeLocationId = object.alternativeLocationId ?? "";
    message.redisVersion = object.redisVersion ?? "";
    message.reservedIpRange = object.reservedIpRange ?? "";
    message.secondaryIpRange = object.secondaryIpRange ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.currentLocationId = object.currentLocationId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.state = object.state ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.redisConfigs = Object.entries(object.redisConfigs ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.tier = object.tier ?? 0;
    message.memorySizeGb = object.memorySizeGb ?? 0;
    message.authorizedNetwork = object.authorizedNetwork ?? "";
    message.persistenceIamIdentity = object.persistenceIamIdentity ?? "";
    message.connectMode = object.connectMode ?? 0;
    message.authEnabled = object.authEnabled ?? false;
    message.serverCaCerts = object.serverCaCerts?.map((e) => TlsCertificate.fromPartial(e)) || [];
    message.transitEncryptionMode = object.transitEncryptionMode ?? 0;
    message.maintenancePolicy = (object.maintenancePolicy !== undefined && object.maintenancePolicy !== null)
      ? MaintenancePolicy.fromPartial(object.maintenancePolicy)
      : undefined;
    message.maintenanceSchedule = (object.maintenanceSchedule !== undefined && object.maintenanceSchedule !== null)
      ? MaintenanceSchedule.fromPartial(object.maintenanceSchedule)
      : undefined;
    message.replicaCount = object.replicaCount ?? 0;
    message.nodes = object.nodes?.map((e) => NodeInfo.fromPartial(e)) || [];
    message.readEndpoint = object.readEndpoint ?? "";
    message.readEndpointPort = object.readEndpointPort ?? 0;
    message.readReplicasMode = object.readReplicasMode ?? 0;
    message.customerManagedKey = object.customerManagedKey ?? "";
    message.persistenceConfig = (object.persistenceConfig !== undefined && object.persistenceConfig !== null)
      ? PersistenceConfig.fromPartial(object.persistenceConfig)
      : undefined;
    message.suspensionReasons = object.suspensionReasons?.map((e) => e) || [];
    message.maintenanceVersion = object.maintenanceVersion ?? "";
    message.availableMaintenanceVersions = object.availableMaintenanceVersions?.map((e) => e) || [];
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_LabelsEntry>, I>>(base?: I): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_LabelsEntry>, I>>(object: I): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInstance_RedisConfigsEntry(): Instance_RedisConfigsEntry {
  return { key: "", value: "" };
}

export const Instance_RedisConfigsEntry: MessageFns<Instance_RedisConfigsEntry> = {
  encode(message: Instance_RedisConfigsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_RedisConfigsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_RedisConfigsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_RedisConfigsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_RedisConfigsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance_RedisConfigsEntry>, I>>(base?: I): Instance_RedisConfigsEntry {
    return Instance_RedisConfigsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance_RedisConfigsEntry>, I>>(object: I): Instance_RedisConfigsEntry {
    const message = createBaseInstance_RedisConfigsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePersistenceConfig(): PersistenceConfig {
  return { persistenceMode: 0, rdbSnapshotPeriod: 0, rdbNextSnapshotTime: undefined, rdbSnapshotStartTime: undefined };
}

export const PersistenceConfig: MessageFns<PersistenceConfig> = {
  encode(message: PersistenceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.persistenceMode !== 0) {
      writer.uint32(8).int32(message.persistenceMode);
    }
    if (message.rdbSnapshotPeriod !== 0) {
      writer.uint32(16).int32(message.rdbSnapshotPeriod);
    }
    if (message.rdbNextSnapshotTime !== undefined) {
      Timestamp.encode(toTimestamp(message.rdbNextSnapshotTime), writer.uint32(34).fork()).join();
    }
    if (message.rdbSnapshotStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.rdbSnapshotStartTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersistenceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersistenceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.persistenceMode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rdbSnapshotPeriod = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rdbNextSnapshotTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rdbSnapshotStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersistenceConfig {
    return {
      persistenceMode: isSet(object.persistenceMode)
        ? persistenceConfig_PersistenceModeFromJSON(object.persistenceMode)
        : 0,
      rdbSnapshotPeriod: isSet(object.rdbSnapshotPeriod)
        ? persistenceConfig_SnapshotPeriodFromJSON(object.rdbSnapshotPeriod)
        : 0,
      rdbNextSnapshotTime: isSet(object.rdbNextSnapshotTime)
        ? fromJsonTimestamp(object.rdbNextSnapshotTime)
        : undefined,
      rdbSnapshotStartTime: isSet(object.rdbSnapshotStartTime)
        ? fromJsonTimestamp(object.rdbSnapshotStartTime)
        : undefined,
    };
  },

  toJSON(message: PersistenceConfig): unknown {
    const obj: any = {};
    if (message.persistenceMode !== 0) {
      obj.persistenceMode = persistenceConfig_PersistenceModeToJSON(message.persistenceMode);
    }
    if (message.rdbSnapshotPeriod !== 0) {
      obj.rdbSnapshotPeriod = persistenceConfig_SnapshotPeriodToJSON(message.rdbSnapshotPeriod);
    }
    if (message.rdbNextSnapshotTime !== undefined) {
      obj.rdbNextSnapshotTime = message.rdbNextSnapshotTime.toISOString();
    }
    if (message.rdbSnapshotStartTime !== undefined) {
      obj.rdbSnapshotStartTime = message.rdbSnapshotStartTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersistenceConfig>, I>>(base?: I): PersistenceConfig {
    return PersistenceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersistenceConfig>, I>>(object: I): PersistenceConfig {
    const message = createBasePersistenceConfig();
    message.persistenceMode = object.persistenceMode ?? 0;
    message.rdbSnapshotPeriod = object.rdbSnapshotPeriod ?? 0;
    message.rdbNextSnapshotTime = object.rdbNextSnapshotTime ?? undefined;
    message.rdbSnapshotStartTime = object.rdbSnapshotStartTime ?? undefined;
    return message;
  },
};

function createBaseMaintenancePolicy(): MaintenancePolicy {
  return { createTime: undefined, updateTime: undefined, description: "", weeklyMaintenanceWindow: [] };
}

export const MaintenancePolicy: MessageFns<MaintenancePolicy> = {
  encode(message: MaintenancePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.weeklyMaintenanceWindow) {
      WeeklyMaintenanceWindow.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenancePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenancePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.weeklyMaintenanceWindow.push(WeeklyMaintenanceWindow.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenancePolicy {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      weeklyMaintenanceWindow: globalThis.Array.isArray(object?.weeklyMaintenanceWindow)
        ? object.weeklyMaintenanceWindow.map((e: any) => WeeklyMaintenanceWindow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MaintenancePolicy): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.weeklyMaintenanceWindow?.length) {
      obj.weeklyMaintenanceWindow = message.weeklyMaintenanceWindow.map((e) => WeeklyMaintenanceWindow.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MaintenancePolicy>, I>>(base?: I): MaintenancePolicy {
    return MaintenancePolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MaintenancePolicy>, I>>(object: I): MaintenancePolicy {
    const message = createBaseMaintenancePolicy();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.weeklyMaintenanceWindow =
      object.weeklyMaintenanceWindow?.map((e) => WeeklyMaintenanceWindow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWeeklyMaintenanceWindow(): WeeklyMaintenanceWindow {
  return { day: 0, startTime: undefined, duration: undefined };
}

export const WeeklyMaintenanceWindow: MessageFns<WeeklyMaintenanceWindow> = {
  encode(message: WeeklyMaintenanceWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.day !== 0) {
      writer.uint32(8).int32(message.day);
    }
    if (message.startTime !== undefined) {
      TimeOfDay.encode(message.startTime, writer.uint32(18).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeeklyMaintenanceWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeeklyMaintenanceWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.day = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeeklyMaintenanceWindow {
    return {
      day: isSet(object.day) ? dayOfWeekFromJSON(object.day) : 0,
      startTime: isSet(object.startTime) ? TimeOfDay.fromJSON(object.startTime) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: WeeklyMaintenanceWindow): unknown {
    const obj: any = {};
    if (message.day !== 0) {
      obj.day = dayOfWeekToJSON(message.day);
    }
    if (message.startTime !== undefined) {
      obj.startTime = TimeOfDay.toJSON(message.startTime);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeeklyMaintenanceWindow>, I>>(base?: I): WeeklyMaintenanceWindow {
    return WeeklyMaintenanceWindow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeeklyMaintenanceWindow>, I>>(object: I): WeeklyMaintenanceWindow {
    const message = createBaseWeeklyMaintenanceWindow();
    message.day = object.day ?? 0;
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? TimeOfDay.fromPartial(object.startTime)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseMaintenanceSchedule(): MaintenanceSchedule {
  return { startTime: undefined, endTime: undefined, canReschedule: false, scheduleDeadlineTime: undefined };
}

export const MaintenanceSchedule: MessageFns<MaintenanceSchedule> = {
  encode(message: MaintenanceSchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.canReschedule !== false) {
      writer.uint32(24).bool(message.canReschedule);
    }
    if (message.scheduleDeadlineTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduleDeadlineTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenanceSchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenanceSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.canReschedule = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheduleDeadlineTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenanceSchedule {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      canReschedule: isSet(object.canReschedule) ? globalThis.Boolean(object.canReschedule) : false,
      scheduleDeadlineTime: isSet(object.scheduleDeadlineTime)
        ? fromJsonTimestamp(object.scheduleDeadlineTime)
        : undefined,
    };
  },

  toJSON(message: MaintenanceSchedule): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.canReschedule !== false) {
      obj.canReschedule = message.canReschedule;
    }
    if (message.scheduleDeadlineTime !== undefined) {
      obj.scheduleDeadlineTime = message.scheduleDeadlineTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MaintenanceSchedule>, I>>(base?: I): MaintenanceSchedule {
    return MaintenanceSchedule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MaintenanceSchedule>, I>>(object: I): MaintenanceSchedule {
    const message = createBaseMaintenanceSchedule();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.canReschedule = object.canReschedule ?? false;
    message.scheduleDeadlineTime = object.scheduleDeadlineTime ?? undefined;
    return message;
  },
};

function createBaseTlsCertificate(): TlsCertificate {
  return { serialNumber: "", createTime: undefined, expireTime: undefined, sha1Fingerprint: "" };
}

export const TlsCertificate: MessageFns<TlsCertificate> = {
  encode(message: TlsCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serialNumber !== "") {
      writer.uint32(10).string(message.serialNumber);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(34).fork()).join();
    }
    if (message.sha1Fingerprint !== "") {
      writer.uint32(42).string(message.sha1Fingerprint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serialNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sha1Fingerprint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsCertificate {
    return {
      serialNumber: isSet(object.serialNumber) ? globalThis.String(object.serialNumber) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      sha1Fingerprint: isSet(object.sha1Fingerprint) ? globalThis.String(object.sha1Fingerprint) : "",
    };
  },

  toJSON(message: TlsCertificate): unknown {
    const obj: any = {};
    if (message.serialNumber !== "") {
      obj.serialNumber = message.serialNumber;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.sha1Fingerprint !== "") {
      obj.sha1Fingerprint = message.sha1Fingerprint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsCertificate>, I>>(base?: I): TlsCertificate {
    return TlsCertificate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsCertificate>, I>>(object: I): TlsCertificate {
    const message = createBaseTlsCertificate();
    message.serialNumber = object.serialNumber ?? "";
    message.createTime = object.createTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.sha1Fingerprint = object.sha1Fingerprint ?? "";
    return message;
  },
};

function createBaseInstanceEventData(): InstanceEventData {
  return { payload: undefined };
}

export const InstanceEventData: MessageFns<InstanceEventData> = {
  encode(message: InstanceEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Instance.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Instance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceEventData {
    return { payload: isSet(object.payload) ? Instance.fromJSON(object.payload) : undefined };
  },

  toJSON(message: InstanceEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Instance.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceEventData>, I>>(base?: I): InstanceEventData {
    return InstanceEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceEventData>, I>>(object: I): InstanceEventData {
    const message = createBaseInstanceEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Instance.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
