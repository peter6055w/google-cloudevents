// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/scheduler/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration";
import { Timestamp } from "../../../../protobuf/timestamp";
import { Status } from "../../../../rpc/status";

export const protobufPackage = "google.events.cloud.scheduler.v1";

/** The HTTP method used to execute the job. */
export enum HttpMethod {
  /** HTTP_METHOD_UNSPECIFIED - HTTP method unspecified. Defaults to POST. */
  HTTP_METHOD_UNSPECIFIED = 0,
  /** POST - HTTP POST */
  POST = 1,
  /** GET - HTTP GET */
  GET = 2,
  /** HEAD - HTTP HEAD */
  HEAD = 3,
  /** PUT - HTTP PUT */
  PUT = 4,
  /** DELETE - HTTP DELETE */
  DELETE = 5,
  /** PATCH - HTTP PATCH */
  PATCH = 6,
  /** OPTIONS - HTTP OPTIONS */
  OPTIONS = 7,
  UNRECOGNIZED = -1,
}

export function httpMethodFromJSON(object: any): HttpMethod {
  switch (object) {
    case 0:
    case "HTTP_METHOD_UNSPECIFIED":
      return HttpMethod.HTTP_METHOD_UNSPECIFIED;
    case 1:
    case "POST":
      return HttpMethod.POST;
    case 2:
    case "GET":
      return HttpMethod.GET;
    case 3:
    case "HEAD":
      return HttpMethod.HEAD;
    case 4:
    case "PUT":
      return HttpMethod.PUT;
    case 5:
    case "DELETE":
      return HttpMethod.DELETE;
    case 6:
    case "PATCH":
      return HttpMethod.PATCH;
    case 7:
    case "OPTIONS":
      return HttpMethod.OPTIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpMethod.UNRECOGNIZED;
  }
}

export function httpMethodToJSON(object: HttpMethod): string {
  switch (object) {
    case HttpMethod.HTTP_METHOD_UNSPECIFIED:
      return "HTTP_METHOD_UNSPECIFIED";
    case HttpMethod.POST:
      return "POST";
    case HttpMethod.GET:
      return "GET";
    case HttpMethod.HEAD:
      return "HEAD";
    case HttpMethod.PUT:
      return "PUT";
    case HttpMethod.DELETE:
      return "DELETE";
    case HttpMethod.PATCH:
      return "PATCH";
    case HttpMethod.OPTIONS:
      return "OPTIONS";
    case HttpMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Scheduler job data. */
export interface SchedulerJobData {
  /** The custom data the user specified when creating the scheduler source. */
  customData: Uint8Array;
}

/**
 * Http target. The job will be pushed to the job handler by means of
 * an HTTP request via an
 * [http_method][google.cloud.scheduler.v1.HttpTarget.http_method] such as HTTP
 * POST, HTTP GET, etc. The job is acknowledged by means of an HTTP
 * response code in the range [200 - 299]. A failure to receive a response
 * constitutes a failed execution. For a redirected request, the response
 * returned by the redirected request is considered.
 */
export interface HttpTarget {
  /**
   * Required. The full URI path that the request will be sent to. This string
   * must begin with either "http://" or "https://". Some examples of
   * valid values for [uri][google.cloud.scheduler.v1.HttpTarget.uri] are:
   * `http://acme.com` and `https://acme.com/sales:8080`. Cloud Scheduler will
   * encode some characters for safety and compatibility. The maximum allowed
   * URL length is 2083 characters after encoding.
   */
  uri: string;
  /** Which HTTP method to use for the request. */
  httpMethod: HttpMethod;
  /**
   * HTTP request headers.
   *
   * This map contains the header field names and values.
   *
   * The user can specify HTTP request headers to send with the job's
   * HTTP request. Repeated headers are not supported, but a header value can
   * contain commas.
   *
   * The following headers represent a subset of the headers
   * that accompany the job's HTTP request. Some HTTP request
   * headers are ignored or replaced. A partial list of headers that
   * are ignored or replaced is below:
   *
   * * Host: This will be computed by Cloud Scheduler and derived from
   * [uri][google.cloud.scheduler.v1.HttpTarget.uri].
   * * `Content-Length`: This will be computed by Cloud Scheduler.
   * * `User-Agent`: This will be set to `"Google-Cloud-Scheduler"`.
   * * `X-Google-*`: Google internal use only.
   * * `X-AppEngine-*`: Google internal use only.
   * * `X-CloudScheduler`: This header will be set to true.
   * * `X-CloudScheduler-JobName`: This header will contain the job name.
   * * `X-CloudScheduler-ScheduleTime`: For Cloud Scheduler jobs specified in
   * the unix-cron format, this header will contain the job schedule as an
   * offset of UTC parsed according to RFC3339.
   *
   * If the job has a [body][google.cloud.scheduler.v1.HttpTarget.body] and the
   * following headers are not set by the user, Cloud Scheduler sets default
   * values:
   *
   * * `Content-Type`: This will be set to `"application/octet-stream"`. You
   *   can override this default by explicitly setting `Content-Type` to a
   *   particular media type when creating the job. For example, you can set
   *   `Content-Type` to `"application/json"`.
   *
   * The total size of headers must be less than 80KB.
   */
  headers: { [key: string]: string };
  /**
   * HTTP request body. A request body is allowed only if the HTTP
   * method is POST, PUT, or PATCH. It is an error to set body on a job with an
   * incompatible [HttpMethod][google.cloud.scheduler.v1.HttpMethod].
   */
  body: Uint8Array;
  /**
   * If specified, an
   * [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
   * will be generated and attached as an `Authorization` header in the HTTP
   * request.
   *
   * This type of authorization should generally only be used when calling
   * Google APIs hosted on *.googleapis.com.
   */
  oauthToken?:
    | OAuthToken
    | undefined;
  /**
   * If specified, an
   * [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
   * token will be generated and attached as an `Authorization` header in the
   * HTTP request.
   *
   * This type of authorization can be used for many scenarios, including
   * calling Cloud Run, or endpoints where you intend to validate the token
   * yourself.
   */
  oidcToken?: OidcToken | undefined;
}

export interface HttpTarget_HeadersEntry {
  key: string;
  value: string;
}

/**
 * App Engine target. The job will be pushed to a job handler by means
 * of an HTTP request via an
 * [http_method][google.cloud.scheduler.v1.AppEngineHttpTarget.http_method] such
 * as HTTP POST, HTTP GET, etc. The job is acknowledged by means of an
 * HTTP response code in the range [200 - 299]. Error 503 is
 * considered an App Engine system error instead of an application
 * error. Requests returning error 503 will be retried regardless of
 * retry configuration and not counted against retry counts. Any other
 * response code, or a failure to receive a response before the
 * deadline, constitutes a failed attempt.
 */
export interface AppEngineHttpTarget {
  /**
   * The HTTP method to use for the request. PATCH and OPTIONS are not
   * permitted.
   */
  httpMethod: HttpMethod;
  /** App Engine Routing setting for the job. */
  appEngineRouting?:
    | AppEngineRouting
    | undefined;
  /**
   * The relative URI.
   *
   * The relative URL must begin with "/" and must be a valid HTTP relative URL.
   * It can contain a path, query string arguments, and `#` fragments.
   * If the relative URL is empty, then the root path "/" will be used.
   * No spaces are allowed, and the maximum length allowed is 2083 characters.
   */
  relativeUri: string;
  /**
   * HTTP request headers.
   *
   * This map contains the header field names and values. Headers can be set
   * when the job is created.
   *
   * Cloud Scheduler sets some headers to default values:
   *
   * * `User-Agent`: By default, this header is
   *   `"AppEngine-Google; (+http://code.google.com/appengine)"`.
   *   This header can be modified, but Cloud Scheduler will append
   *   `"AppEngine-Google; (+http://code.google.com/appengine)"` to the
   *   modified `User-Agent`.
   * * `X-CloudScheduler`: This header will be set to true.
   * * `X-CloudScheduler-JobName`: This header will contain the job name.
   * * `X-CloudScheduler-ScheduleTime`: For Cloud Scheduler jobs specified in
   * the unix-cron format, this header will contain the job schedule as an
   * offset of UTC parsed according to RFC3339.
   *
   * If the job has a [body][google.cloud.scheduler.v1.AppEngineHttpTarget.body]
   * and the following headers are not set by the user, Cloud Scheduler sets
   * default values:
   *
   * * `Content-Type`: This will be set to `"application/octet-stream"`. You
   *   can override this default by explicitly setting `Content-Type` to a
   *   particular media type when creating the job. For example, you can set
   *   `Content-Type` to `"application/json"`.
   *
   * The headers below are output only. They cannot be set or overridden:
   *
   * * `Content-Length`: This is computed by Cloud Scheduler.
   * * `X-Google-*`: For Google internal use only.
   * * `X-AppEngine-*`: For Google internal use only.
   *
   * In addition, some App Engine headers, which contain
   * job-specific information, are also be sent to the job handler.
   */
  headers: { [key: string]: string };
  /**
   * Body.
   *
   * HTTP request body. A request body is allowed only if the HTTP method is
   * POST or PUT. It will result in invalid argument error to set a body on a
   * job with an incompatible
   * [HttpMethod][google.cloud.scheduler.v1.HttpMethod].
   */
  body: Uint8Array;
}

export interface AppEngineHttpTarget_HeadersEntry {
  key: string;
  value: string;
}

/**
 * Pub/Sub target. The job will be delivered by publishing a message to
 * the given Pub/Sub topic.
 */
export interface PubsubTarget {
  /**
   * Required. The name of the Cloud Pub/Sub topic to which messages will
   * be published when a job is delivered. The topic name must be in the
   * same format as required by Pub/Sub's
   * [PublishRequest.name](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#publishrequest),
   * for example `projects/PROJECT_ID/topics/TOPIC_ID`.
   *
   * The topic must be in the same project as the Cloud Scheduler job.
   */
  topicName: string;
  /**
   * The message payload for PubsubMessage.
   *
   * Pubsub message must contain either non-empty data, or at least one
   * attribute.
   */
  data: Uint8Array;
  /**
   * Attributes for PubsubMessage.
   *
   * Pubsub message must contain either non-empty data, or at least one
   * attribute.
   */
  attributes: { [key: string]: string };
}

export interface PubsubTarget_AttributesEntry {
  key: string;
  value: string;
}

/**
 * App Engine Routing.
 *
 * For more information about services, versions, and instances see
 * [An Overview of App
 * Engine](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine),
 * [Microservices Architecture on Google App
 * Engine](https://cloud.google.com/appengine/docs/python/microservices-on-app-engine),
 * [App Engine Standard request
 * routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed),
 * and [App Engine Flex request
 * routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
 */
export interface AppEngineRouting {
  /**
   * App service.
   *
   * By default, the job is sent to the service which is the default
   * service when the job is attempted.
   */
  service: string;
  /**
   * App version.
   *
   * By default, the job is sent to the version which is the default
   * version when the job is attempted.
   */
  version: string;
  /**
   * App instance.
   *
   * By default, the job is sent to an instance which is available when
   * the job is attempted.
   *
   * Requests can only be sent to a specific instance if
   * [manual scaling is used in App Engine
   * Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?#scaling_types_and_instance_classes).
   * App Engine Flex does not support instances. For more information, see
   * [App Engine Standard request
   * routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
   * and [App Engine Flex request
   * routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
   */
  instance: string;
  /**
   * Output only. The host that the job is sent to.
   *
   * For more information about how App Engine requests are routed, see
   * [here](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
   *
   * The host is constructed as:
   *
   * * `host = [application_domain_name]`</br>
   *   `| [service] + '.' + [application_domain_name]`</br>
   *   `| [version] + '.' + [application_domain_name]`</br>
   *   `| [version_dot_service]+ '.' + [application_domain_name]`</br>
   *   `| [instance] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_service] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_version] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_version_dot_service] + '.' + [application_domain_name]`
   *
   * * `application_domain_name` = The domain name of the app, for
   *   example <app-id>.appspot.com, which is associated with the
   *   job's project ID.
   *
   * * `service =` [service][google.cloud.scheduler.v1.AppEngineRouting.service]
   *
   * * `version =` [version][google.cloud.scheduler.v1.AppEngineRouting.version]
   *
   * * `version_dot_service =`
   *   [version][google.cloud.scheduler.v1.AppEngineRouting.version] `+ '.' +`
   *   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
   *
   * * `instance =`
   * [instance][google.cloud.scheduler.v1.AppEngineRouting.instance]
   *
   * * `instance_dot_service =`
   *   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
   *   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
   *
   * * `instance_dot_version =`
   *   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
   *   [version][google.cloud.scheduler.v1.AppEngineRouting.version]
   *
   * * `instance_dot_version_dot_service =`
   *   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
   *   [version][google.cloud.scheduler.v1.AppEngineRouting.version] `+ '.' +`
   *   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
   *
   * If [service][google.cloud.scheduler.v1.AppEngineRouting.service] is empty,
   * then the job will be sent to the service which is the default service when
   * the job is attempted.
   *
   * If [version][google.cloud.scheduler.v1.AppEngineRouting.version] is empty,
   * then the job will be sent to the version which is the default version when
   * the job is attempted.
   *
   * If [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] is
   * empty, then the job will be sent to an instance which is available when the
   * job is attempted.
   *
   * If [service][google.cloud.scheduler.v1.AppEngineRouting.service],
   * [version][google.cloud.scheduler.v1.AppEngineRouting.version], or
   * [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] is invalid,
   * then the job will be sent to the default version of the default service
   * when the job is attempted.
   */
  host: string;
}

/**
 * Contains information needed for generating an
 * [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
 * This type of authorization should generally only be used when calling Google
 * APIs hosted on *.googleapis.com.
 */
export interface OAuthToken {
  /**
   * [Service account email](https://cloud.google.com/iam/docs/service-accounts)
   * to be used for generating OAuth token.
   * The service account must be within the same project as the job. The caller
   * must have iam.serviceAccounts.actAs permission for the service account.
   */
  serviceAccountEmail: string;
  /**
   * OAuth scope to be used for generating OAuth access token.
   * If not specified, "https://www.googleapis.com/auth/cloud-platform"
   * will be used.
   */
  scope: string;
}

/**
 * Contains information needed for generating an
 * [OpenID Connect
 * token](https://developers.google.com/identity/protocols/OpenIDConnect).
 * This type of authorization can be used for many scenarios, including
 * calling Cloud Run, or endpoints where you intend to validate the token
 * yourself.
 */
export interface OidcToken {
  /**
   * [Service account email](https://cloud.google.com/iam/docs/service-accounts)
   * to be used for generating OIDC token.
   * The service account must be within the same project as the job. The caller
   * must have iam.serviceAccounts.actAs permission for the service account.
   */
  serviceAccountEmail: string;
  /**
   * Audience to be used when generating OIDC token. If not specified, the URI
   * specified in target will be used.
   */
  audience: string;
}

/**
 * Configuration for a job.
 * The maximum allowed size for a job is 1MB.
 */
export interface Job {
  /**
   * Optionally caller-specified in
   * [CreateJob][google.cloud.scheduler.v1.CloudScheduler.CreateJob], after
   * which it becomes output only.
   *
   * The job name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
   *
   * * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
   *    hyphens (-), colons (:), or periods (.).
   *    For more information, see
   *    [Identifying
   *    projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
   * * `LOCATION_ID` is the canonical ID for the job's location.
   *    The list of available locations can be obtained by calling
   *    [ListLocations][google.cloud.location.Locations.ListLocations].
   *    For more information, see https://cloud.google.com/about/locations/.
   * * `JOB_ID` can contain only letters ([A-Za-z]), numbers ([0-9]),
   *    hyphens (-), or underscores (_). The maximum length is 500 characters.
   */
  name: string;
  /**
   * Optionally caller-specified in
   * [CreateJob][google.cloud.scheduler.v1.CloudScheduler.CreateJob] or
   * [UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob].
   *
   * A human-readable description for the job. This string must not contain
   * more than 500 characters.
   */
  description: string;
  /** Pub/Sub target. */
  pubsubTarget?:
    | PubsubTarget
    | undefined;
  /** App Engine HTTP target. */
  appEngineHttpTarget?:
    | AppEngineHttpTarget
    | undefined;
  /** HTTP target. */
  httpTarget?:
    | HttpTarget
    | undefined;
  /**
   * Required, except when used with
   * [UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob].
   *
   * Describes the schedule on which the job will be executed.
   *
   * The schedule can be either of the following types:
   *
   * * [Crontab](https://en.wikipedia.org/wiki/Cron#Overview)
   * * English-like
   * [schedule](https://cloud.google.com/scheduler/docs/configuring/cron-job-schedules)
   *
   * As a general rule, execution `n + 1` of a job will not begin
   * until execution `n` has finished. Cloud Scheduler will never
   * allow two simultaneously outstanding executions. For example,
   * this implies that if the `n+1`th execution is scheduled to run at
   * 16:00 but the `n`th execution takes until 16:15, the `n+1`th
   * execution will not start until `16:15`.
   * A scheduled start time will be delayed if the previous
   * execution has not ended when its scheduled time occurs.
   *
   * If [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] > 0 and
   * a job attempt fails, the job will be tried a total of
   * [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] times,
   * with exponential backoff, until the next scheduled start time. If
   * retry_count is 0, a job attempt will not be retried if it fails. Instead
   * the Cloud Scheduler system will wait for the next scheduled execution time.
   * Setting retry_count to 0 does not prevent failed jobs from running
   * according to schedule after the failure.
   */
  schedule: string;
  /**
   * Specifies the time zone to be used in interpreting
   * [schedule][google.cloud.scheduler.v1.Job.schedule]. The value of this field
   * must be a time zone name from the [tz
   * database](http://en.wikipedia.org/wiki/Tz_database).
   *
   * Note that some time zones include a provision for
   * daylight savings time. The rules for daylight saving time are
   * determined by the chosen tz. For UTC use the string "utc". If a
   * time zone is not specified, the default will be in UTC (also known
   * as GMT).
   */
  timeZone: string;
  /** Output only. The creation time of the job. */
  userUpdateTime?:
    | Date
    | undefined;
  /** Output only. State of the job. */
  state: Job_State;
  /** Output only. The response from the target for the last attempted execution. */
  status?:
    | Status
    | undefined;
  /**
   * Output only. The next time the job is scheduled. Note that this may be a
   * retry of a previously failed attempt or the next execution time
   * according to the schedule.
   */
  scheduleTime?:
    | Date
    | undefined;
  /** Output only. The time the last job attempt started. */
  lastAttemptTime?:
    | Date
    | undefined;
  /** Settings that determine the retry behavior. */
  retryConfig?:
    | RetryConfig
    | undefined;
  /**
   * The deadline for job attempts. If the request handler does not respond by
   * this deadline then the request is cancelled and the attempt is marked as a
   * `DEADLINE_EXCEEDED` failure. The failed attempt can be viewed in
   * execution logs. Cloud Scheduler will retry the job according
   * to the [RetryConfig][google.cloud.scheduler.v1.RetryConfig].
   *
   * The default and the allowed values depend on the type of target:
   *
   * * For [HTTP targets][google.cloud.scheduler.v1.Job.http_target], the
   * default is 3 minutes. The deadline must be in the interval [15 seconds, 30
   * minutes].
   *
   * * For [App Engine HTTP
   * targets][google.cloud.scheduler.v1.Job.app_engine_http_target], 0 indicates
   * that the request has the default deadline. The default deadline depends on
   * the scaling type of the service: 10 minutes for standard apps with
   * automatic scaling, 24 hours for standard apps with manual and basic
   * scaling, and 60 minutes for flex apps. If the request deadline is set, it
   * must be in the interval [15 seconds, 24 hours 15 seconds].
   *
   * * For [Pub/Sub targets][google.cloud.scheduler.v1.Job.pubsub_target], this
   * field is ignored.
   */
  attemptDeadline?: Duration | undefined;
}

/** State of the job. */
export enum Job_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** ENABLED - The job is executing normally. */
  ENABLED = 1,
  /**
   * PAUSED - The job is paused by the user. It will not execute. A user can
   * intentionally pause the job using
   * [PauseJobRequest][google.cloud.scheduler.v1.PauseJobRequest].
   */
  PAUSED = 2,
  /**
   * DISABLED - The job is disabled by the system due to error. The user
   * cannot directly set a job to be disabled.
   */
  DISABLED = 3,
  /**
   * UPDATE_FAILED - The job state resulting from a failed
   * [CloudScheduler.UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob]
   * operation. To recover a job from this state, retry
   * [CloudScheduler.UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob]
   * until a successful response is received.
   */
  UPDATE_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function job_StateFromJSON(object: any): Job_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Job_State.STATE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return Job_State.ENABLED;
    case 2:
    case "PAUSED":
      return Job_State.PAUSED;
    case 3:
    case "DISABLED":
      return Job_State.DISABLED;
    case 4:
    case "UPDATE_FAILED":
      return Job_State.UPDATE_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Job_State.UNRECOGNIZED;
  }
}

export function job_StateToJSON(object: Job_State): string {
  switch (object) {
    case Job_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Job_State.ENABLED:
      return "ENABLED";
    case Job_State.PAUSED:
      return "PAUSED";
    case Job_State.DISABLED:
      return "DISABLED";
    case Job_State.UPDATE_FAILED:
      return "UPDATE_FAILED";
    case Job_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Settings that determine the retry behavior.
 *
 * By default, if a job does not complete successfully (meaning that
 * an acknowledgement is not received from the handler, then it will be retried
 * with exponential backoff according to the settings in
 * [RetryConfig][google.cloud.scheduler.v1.RetryConfig].
 */
export interface RetryConfig {
  /**
   * The number of attempts that the system will make to run a job using the
   * exponential backoff procedure described by
   * [max_doublings][google.cloud.scheduler.v1.RetryConfig.max_doublings].
   *
   * The default value of retry_count is zero.
   *
   * If retry_count is 0, a job attempt will not be retried if
   * it fails. Instead the Cloud Scheduler system will wait for the
   * next scheduled execution time. Setting retry_count to 0 does not prevent
   * failed jobs from running according to schedule after the failure.
   *
   * If retry_count is set to a non-zero number then Cloud Scheduler
   * will retry failed attempts, using exponential backoff,
   * retry_count times, or until the next scheduled execution time,
   * whichever comes first.
   *
   * Values greater than 5 and negative values are not allowed.
   */
  retryCount: number;
  /**
   * The time limit for retrying a failed job, measured from time when an
   * execution was first attempted. If specified with
   * [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count], the job
   * will be retried until both limits are reached.
   *
   * The default value for max_retry_duration is zero, which means retry
   * duration is unlimited.
   */
  maxRetryDuration?:
    | Duration
    | undefined;
  /**
   * The minimum amount of time to wait before retrying a job after
   * it fails.
   *
   * The default value of this field is 5 seconds.
   */
  minBackoffDuration?:
    | Duration
    | undefined;
  /**
   * The maximum amount of time to wait before retrying a job after
   * it fails.
   *
   * The default value of this field is 1 hour.
   */
  maxBackoffDuration?:
    | Duration
    | undefined;
  /**
   * The time between retries will double `max_doublings` times.
   *
   * A job's retry interval starts at
   * [min_backoff_duration][google.cloud.scheduler.v1.RetryConfig.min_backoff_duration],
   * then doubles `max_doublings` times, then increases linearly, and finally
   * retries at intervals of
   * [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
   * up to [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count]
   * times.
   *
   * For example, if
   * [min_backoff_duration][google.cloud.scheduler.v1.RetryConfig.min_backoff_duration]
   * is 10s,
   * [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
   * is 300s, and `max_doublings` is 3, then the job will first be retried in
   * 10s. The retry interval will double three times, and then increase linearly
   * by 2^3 * 10s.  Finally, the job will retry at intervals of
   * [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
   * until the job has been attempted
   * [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] times.
   * Thus, the requests will retry at 10s, 20s, 40s, 80s, 160s, 240s, 300s,
   * 300s, ....
   *
   * The default value of this field is 5.
   */
  maxDoublings: number;
}

/** The data within all Job events. */
export interface JobEventData {
  /** Optional. The Job event payload. Unset for deletion events. */
  payload?: Job | undefined;
}

function createBaseSchedulerJobData(): SchedulerJobData {
  return { customData: new Uint8Array(0) };
}

export const SchedulerJobData: MessageFns<SchedulerJobData> = {
  encode(message: SchedulerJobData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customData.length !== 0) {
      writer.uint32(10).bytes(message.customData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchedulerJobData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedulerJobData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchedulerJobData {
    return { customData: isSet(object.customData) ? bytesFromBase64(object.customData) : new Uint8Array(0) };
  },

  toJSON(message: SchedulerJobData): unknown {
    const obj: any = {};
    if (message.customData.length !== 0) {
      obj.customData = base64FromBytes(message.customData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchedulerJobData>, I>>(base?: I): SchedulerJobData {
    return SchedulerJobData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchedulerJobData>, I>>(object: I): SchedulerJobData {
    const message = createBaseSchedulerJobData();
    message.customData = object.customData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHttpTarget(): HttpTarget {
  return { uri: "", httpMethod: 0, headers: {}, body: new Uint8Array(0), oauthToken: undefined, oidcToken: undefined };
}

export const HttpTarget: MessageFns<HttpTarget> = {
  encode(message: HttpTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.httpMethod !== 0) {
      writer.uint32(16).int32(message.httpMethod);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      HttpTarget_HeadersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.body.length !== 0) {
      writer.uint32(34).bytes(message.body);
    }
    if (message.oauthToken !== undefined) {
      OAuthToken.encode(message.oauthToken, writer.uint32(42).fork()).join();
    }
    if (message.oidcToken !== undefined) {
      OidcToken.encode(message.oidcToken, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = HttpTarget_HeadersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.headers[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.oauthToken = OAuthToken.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.oidcToken = OidcToken.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTarget {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      oauthToken: isSet(object.oauthToken) ? OAuthToken.fromJSON(object.oauthToken) : undefined,
      oidcToken: isSet(object.oidcToken) ? OidcToken.fromJSON(object.oidcToken) : undefined,
    };
  },

  toJSON(message: HttpTarget): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.oauthToken !== undefined) {
      obj.oauthToken = OAuthToken.toJSON(message.oauthToken);
    }
    if (message.oidcToken !== undefined) {
      obj.oidcToken = OidcToken.toJSON(message.oidcToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpTarget>, I>>(base?: I): HttpTarget {
    return HttpTarget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpTarget>, I>>(object: I): HttpTarget {
    const message = createBaseHttpTarget();
    message.uri = object.uri ?? "";
    message.httpMethod = object.httpMethod ?? 0;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? new Uint8Array(0);
    message.oauthToken = (object.oauthToken !== undefined && object.oauthToken !== null)
      ? OAuthToken.fromPartial(object.oauthToken)
      : undefined;
    message.oidcToken = (object.oidcToken !== undefined && object.oidcToken !== null)
      ? OidcToken.fromPartial(object.oidcToken)
      : undefined;
    return message;
  },
};

function createBaseHttpTarget_HeadersEntry(): HttpTarget_HeadersEntry {
  return { key: "", value: "" };
}

export const HttpTarget_HeadersEntry: MessageFns<HttpTarget_HeadersEntry> = {
  encode(message: HttpTarget_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTarget_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTarget_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTarget_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpTarget_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpTarget_HeadersEntry>, I>>(base?: I): HttpTarget_HeadersEntry {
    return HttpTarget_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpTarget_HeadersEntry>, I>>(object: I): HttpTarget_HeadersEntry {
    const message = createBaseHttpTarget_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAppEngineHttpTarget(): AppEngineHttpTarget {
  return { httpMethod: 0, appEngineRouting: undefined, relativeUri: "", headers: {}, body: new Uint8Array(0) };
}

export const AppEngineHttpTarget: MessageFns<AppEngineHttpTarget> = {
  encode(message: AppEngineHttpTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpMethod !== 0) {
      writer.uint32(8).int32(message.httpMethod);
    }
    if (message.appEngineRouting !== undefined) {
      AppEngineRouting.encode(message.appEngineRouting, writer.uint32(18).fork()).join();
    }
    if (message.relativeUri !== "") {
      writer.uint32(26).string(message.relativeUri);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      AppEngineHttpTarget_HeadersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.body.length !== 0) {
      writer.uint32(42).bytes(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appEngineRouting = AppEngineRouting.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relativeUri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = AppEngineHttpTarget_HeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.headers[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpTarget {
    return {
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      appEngineRouting: isSet(object.appEngineRouting) ? AppEngineRouting.fromJSON(object.appEngineRouting) : undefined,
      relativeUri: isSet(object.relativeUri) ? globalThis.String(object.relativeUri) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
    };
  },

  toJSON(message: AppEngineHttpTarget): unknown {
    const obj: any = {};
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.appEngineRouting !== undefined) {
      obj.appEngineRouting = AppEngineRouting.toJSON(message.appEngineRouting);
    }
    if (message.relativeUri !== "") {
      obj.relativeUri = message.relativeUri;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppEngineHttpTarget>, I>>(base?: I): AppEngineHttpTarget {
    return AppEngineHttpTarget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppEngineHttpTarget>, I>>(object: I): AppEngineHttpTarget {
    const message = createBaseAppEngineHttpTarget();
    message.httpMethod = object.httpMethod ?? 0;
    message.appEngineRouting = (object.appEngineRouting !== undefined && object.appEngineRouting !== null)
      ? AppEngineRouting.fromPartial(object.appEngineRouting)
      : undefined;
    message.relativeUri = object.relativeUri ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppEngineHttpTarget_HeadersEntry(): AppEngineHttpTarget_HeadersEntry {
  return { key: "", value: "" };
}

export const AppEngineHttpTarget_HeadersEntry: MessageFns<AppEngineHttpTarget_HeadersEntry> = {
  encode(message: AppEngineHttpTarget_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpTarget_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpTarget_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpTarget_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AppEngineHttpTarget_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppEngineHttpTarget_HeadersEntry>, I>>(
    base?: I,
  ): AppEngineHttpTarget_HeadersEntry {
    return AppEngineHttpTarget_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppEngineHttpTarget_HeadersEntry>, I>>(
    object: I,
  ): AppEngineHttpTarget_HeadersEntry {
    const message = createBaseAppEngineHttpTarget_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePubsubTarget(): PubsubTarget {
  return { topicName: "", data: new Uint8Array(0), attributes: {} };
}

export const PubsubTarget: MessageFns<PubsubTarget> = {
  encode(message: PubsubTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicName !== "") {
      writer.uint32(10).string(message.topicName);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      PubsubTarget_AttributesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubsubTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topicName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = PubsubTarget_AttributesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.attributes[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubTarget {
    return {
      topicName: isSet(object.topicName) ? globalThis.String(object.topicName) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PubsubTarget): unknown {
    const obj: any = {};
    if (message.topicName !== "") {
      obj.topicName = message.topicName;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubsubTarget>, I>>(base?: I): PubsubTarget {
    return PubsubTarget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubsubTarget>, I>>(object: I): PubsubTarget {
    const message = createBasePubsubTarget();
    message.topicName = object.topicName ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePubsubTarget_AttributesEntry(): PubsubTarget_AttributesEntry {
  return { key: "", value: "" };
}

export const PubsubTarget_AttributesEntry: MessageFns<PubsubTarget_AttributesEntry> = {
  encode(message: PubsubTarget_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubsubTarget_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubTarget_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubTarget_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PubsubTarget_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubsubTarget_AttributesEntry>, I>>(base?: I): PubsubTarget_AttributesEntry {
    return PubsubTarget_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubsubTarget_AttributesEntry>, I>>(object: I): PubsubTarget_AttributesEntry {
    const message = createBasePubsubTarget_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAppEngineRouting(): AppEngineRouting {
  return { service: "", version: "", instance: "", host: "" };
}

export const AppEngineRouting: MessageFns<AppEngineRouting> = {
  encode(message: AppEngineRouting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.instance !== "") {
      writer.uint32(26).string(message.instance);
    }
    if (message.host !== "") {
      writer.uint32(34).string(message.host);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineRouting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineRouting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instance = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.host = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineRouting {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
    };
  },

  toJSON(message: AppEngineRouting): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppEngineRouting>, I>>(base?: I): AppEngineRouting {
    return AppEngineRouting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppEngineRouting>, I>>(object: I): AppEngineRouting {
    const message = createBaseAppEngineRouting();
    message.service = object.service ?? "";
    message.version = object.version ?? "";
    message.instance = object.instance ?? "";
    message.host = object.host ?? "";
    return message;
  },
};

function createBaseOAuthToken(): OAuthToken {
  return { serviceAccountEmail: "", scope: "" };
}

export const OAuthToken: MessageFns<OAuthToken> = {
  encode(message: OAuthToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountEmail !== "") {
      writer.uint32(10).string(message.serviceAccountEmail);
    }
    if (message.scope !== "") {
      writer.uint32(18).string(message.scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthToken {
    return {
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
    };
  },

  toJSON(message: OAuthToken): unknown {
    const obj: any = {};
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthToken>, I>>(base?: I): OAuthToken {
    return OAuthToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthToken>, I>>(object: I): OAuthToken {
    const message = createBaseOAuthToken();
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.scope = object.scope ?? "";
    return message;
  },
};

function createBaseOidcToken(): OidcToken {
  return { serviceAccountEmail: "", audience: "" };
}

export const OidcToken: MessageFns<OidcToken> = {
  encode(message: OidcToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountEmail !== "") {
      writer.uint32(10).string(message.serviceAccountEmail);
    }
    if (message.audience !== "") {
      writer.uint32(18).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OidcToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOidcToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.audience = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OidcToken {
    return {
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
    };
  },

  toJSON(message: OidcToken): unknown {
    const obj: any = {};
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OidcToken>, I>>(base?: I): OidcToken {
    return OidcToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OidcToken>, I>>(object: I): OidcToken {
    const message = createBaseOidcToken();
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.audience = object.audience ?? "";
    return message;
  },
};

function createBaseJob(): Job {
  return {
    name: "",
    description: "",
    pubsubTarget: undefined,
    appEngineHttpTarget: undefined,
    httpTarget: undefined,
    schedule: "",
    timeZone: "",
    userUpdateTime: undefined,
    state: 0,
    status: undefined,
    scheduleTime: undefined,
    lastAttemptTime: undefined,
    retryConfig: undefined,
    attemptDeadline: undefined,
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.pubsubTarget !== undefined) {
      PubsubTarget.encode(message.pubsubTarget, writer.uint32(34).fork()).join();
    }
    if (message.appEngineHttpTarget !== undefined) {
      AppEngineHttpTarget.encode(message.appEngineHttpTarget, writer.uint32(42).fork()).join();
    }
    if (message.httpTarget !== undefined) {
      HttpTarget.encode(message.httpTarget, writer.uint32(50).fork()).join();
    }
    if (message.schedule !== "") {
      writer.uint32(162).string(message.schedule);
    }
    if (message.timeZone !== "") {
      writer.uint32(170).string(message.timeZone);
    }
    if (message.userUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.userUpdateTime), writer.uint32(74).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(90).fork()).join();
    }
    if (message.scheduleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduleTime), writer.uint32(138).fork()).join();
    }
    if (message.lastAttemptTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastAttemptTime), writer.uint32(146).fork()).join();
    }
    if (message.retryConfig !== undefined) {
      RetryConfig.encode(message.retryConfig, writer.uint32(154).fork()).join();
    }
    if (message.attemptDeadline !== undefined) {
      Duration.encode(message.attemptDeadline, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pubsubTarget = PubsubTarget.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appEngineHttpTarget = AppEngineHttpTarget.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.httpTarget = HttpTarget.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.scheduleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.lastAttemptTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.retryConfig = RetryConfig.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.attemptDeadline = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      pubsubTarget: isSet(object.pubsubTarget) ? PubsubTarget.fromJSON(object.pubsubTarget) : undefined,
      appEngineHttpTarget: isSet(object.appEngineHttpTarget)
        ? AppEngineHttpTarget.fromJSON(object.appEngineHttpTarget)
        : undefined,
      httpTarget: isSet(object.httpTarget) ? HttpTarget.fromJSON(object.httpTarget) : undefined,
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      userUpdateTime: isSet(object.userUpdateTime) ? fromJsonTimestamp(object.userUpdateTime) : undefined,
      state: isSet(object.state) ? job_StateFromJSON(object.state) : 0,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      scheduleTime: isSet(object.scheduleTime) ? fromJsonTimestamp(object.scheduleTime) : undefined,
      lastAttemptTime: isSet(object.lastAttemptTime) ? fromJsonTimestamp(object.lastAttemptTime) : undefined,
      retryConfig: isSet(object.retryConfig) ? RetryConfig.fromJSON(object.retryConfig) : undefined,
      attemptDeadline: isSet(object.attemptDeadline) ? Duration.fromJSON(object.attemptDeadline) : undefined,
    };
  },

  toJSON(message: Job): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.pubsubTarget !== undefined) {
      obj.pubsubTarget = PubsubTarget.toJSON(message.pubsubTarget);
    }
    if (message.appEngineHttpTarget !== undefined) {
      obj.appEngineHttpTarget = AppEngineHttpTarget.toJSON(message.appEngineHttpTarget);
    }
    if (message.httpTarget !== undefined) {
      obj.httpTarget = HttpTarget.toJSON(message.httpTarget);
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.userUpdateTime !== undefined) {
      obj.userUpdateTime = message.userUpdateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = job_StateToJSON(message.state);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.scheduleTime !== undefined) {
      obj.scheduleTime = message.scheduleTime.toISOString();
    }
    if (message.lastAttemptTime !== undefined) {
      obj.lastAttemptTime = message.lastAttemptTime.toISOString();
    }
    if (message.retryConfig !== undefined) {
      obj.retryConfig = RetryConfig.toJSON(message.retryConfig);
    }
    if (message.attemptDeadline !== undefined) {
      obj.attemptDeadline = Duration.toJSON(message.attemptDeadline);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Job>, I>>(base?: I): Job {
    return Job.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Job>, I>>(object: I): Job {
    const message = createBaseJob();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.pubsubTarget = (object.pubsubTarget !== undefined && object.pubsubTarget !== null)
      ? PubsubTarget.fromPartial(object.pubsubTarget)
      : undefined;
    message.appEngineHttpTarget = (object.appEngineHttpTarget !== undefined && object.appEngineHttpTarget !== null)
      ? AppEngineHttpTarget.fromPartial(object.appEngineHttpTarget)
      : undefined;
    message.httpTarget = (object.httpTarget !== undefined && object.httpTarget !== null)
      ? HttpTarget.fromPartial(object.httpTarget)
      : undefined;
    message.schedule = object.schedule ?? "";
    message.timeZone = object.timeZone ?? "";
    message.userUpdateTime = object.userUpdateTime ?? undefined;
    message.state = object.state ?? 0;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.scheduleTime = object.scheduleTime ?? undefined;
    message.lastAttemptTime = object.lastAttemptTime ?? undefined;
    message.retryConfig = (object.retryConfig !== undefined && object.retryConfig !== null)
      ? RetryConfig.fromPartial(object.retryConfig)
      : undefined;
    message.attemptDeadline = (object.attemptDeadline !== undefined && object.attemptDeadline !== null)
      ? Duration.fromPartial(object.attemptDeadline)
      : undefined;
    return message;
  },
};

function createBaseRetryConfig(): RetryConfig {
  return {
    retryCount: 0,
    maxRetryDuration: undefined,
    minBackoffDuration: undefined,
    maxBackoffDuration: undefined,
    maxDoublings: 0,
  };
}

export const RetryConfig: MessageFns<RetryConfig> = {
  encode(message: RetryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryCount !== 0) {
      writer.uint32(8).int32(message.retryCount);
    }
    if (message.maxRetryDuration !== undefined) {
      Duration.encode(message.maxRetryDuration, writer.uint32(18).fork()).join();
    }
    if (message.minBackoffDuration !== undefined) {
      Duration.encode(message.minBackoffDuration, writer.uint32(26).fork()).join();
    }
    if (message.maxBackoffDuration !== undefined) {
      Duration.encode(message.maxBackoffDuration, writer.uint32(34).fork()).join();
    }
    if (message.maxDoublings !== 0) {
      writer.uint32(40).int32(message.maxDoublings);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.maxRetryDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minBackoffDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxBackoffDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxDoublings = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryConfig {
    return {
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      maxRetryDuration: isSet(object.maxRetryDuration) ? Duration.fromJSON(object.maxRetryDuration) : undefined,
      minBackoffDuration: isSet(object.minBackoffDuration) ? Duration.fromJSON(object.minBackoffDuration) : undefined,
      maxBackoffDuration: isSet(object.maxBackoffDuration) ? Duration.fromJSON(object.maxBackoffDuration) : undefined,
      maxDoublings: isSet(object.maxDoublings) ? globalThis.Number(object.maxDoublings) : 0,
    };
  },

  toJSON(message: RetryConfig): unknown {
    const obj: any = {};
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.maxRetryDuration !== undefined) {
      obj.maxRetryDuration = Duration.toJSON(message.maxRetryDuration);
    }
    if (message.minBackoffDuration !== undefined) {
      obj.minBackoffDuration = Duration.toJSON(message.minBackoffDuration);
    }
    if (message.maxBackoffDuration !== undefined) {
      obj.maxBackoffDuration = Duration.toJSON(message.maxBackoffDuration);
    }
    if (message.maxDoublings !== 0) {
      obj.maxDoublings = Math.round(message.maxDoublings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryConfig>, I>>(base?: I): RetryConfig {
    return RetryConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryConfig>, I>>(object: I): RetryConfig {
    const message = createBaseRetryConfig();
    message.retryCount = object.retryCount ?? 0;
    message.maxRetryDuration = (object.maxRetryDuration !== undefined && object.maxRetryDuration !== null)
      ? Duration.fromPartial(object.maxRetryDuration)
      : undefined;
    message.minBackoffDuration = (object.minBackoffDuration !== undefined && object.minBackoffDuration !== null)
      ? Duration.fromPartial(object.minBackoffDuration)
      : undefined;
    message.maxBackoffDuration = (object.maxBackoffDuration !== undefined && object.maxBackoffDuration !== null)
      ? Duration.fromPartial(object.maxBackoffDuration)
      : undefined;
    message.maxDoublings = object.maxDoublings ?? 0;
    return message;
  },
};

function createBaseJobEventData(): JobEventData {
  return { payload: undefined };
}

export const JobEventData: MessageFns<JobEventData> = {
  encode(message: JobEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Job.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Job.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobEventData {
    return { payload: isSet(object.payload) ? Job.fromJSON(object.payload) : undefined };
  },

  toJSON(message: JobEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Job.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JobEventData>, I>>(base?: I): JobEventData {
    return JobEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JobEventData>, I>>(object: I): JobEventData {
    const message = createBaseJobEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Job.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
