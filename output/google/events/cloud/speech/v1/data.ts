// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/speech/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";

export const protobufPackage = "google.events.cloud.speech.v1";

/**
 * A set of words or phrases that represents a common concept likely to appear
 * in your audio, for example a list of passenger ship names. CustomClass items
 * can be substituted into placeholders that you set in PhraseSet phrases.
 */
export interface CustomClass {
  /** The resource name of the custom class. */
  name: string;
  /**
   * If this custom class is a resource, the custom_class_id is the resource id
   * of the CustomClass. Case sensitive.
   */
  customClassId: string;
  /** A collection of class items. */
  items: CustomClass_ClassItem[];
  /**
   * Output only. The [KMS key
   * name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
   * the content of the ClassItem is encrypted. The expected format is
   * `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
   */
  kmsKeyName: string;
  /**
   * Output only. The [KMS key version
   * name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
   * with which content of the ClassItem is encrypted. The expected format is
   * `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
   */
  kmsKeyVersionName: string;
  /**
   * Output only. System-assigned unique identifier for the CustomClass.
   * This field is not used.
   */
  uid: string;
  /**
   * Output only. User-settable, human-readable name for the CustomClass. Must
   * be 63 characters or less. This field is not used.
   */
  displayName: string;
  /**
   * Output only. The CustomClass lifecycle state.
   * This field is not used.
   */
  state: CustomClass_State;
  /**
   * Output only. The time at which this resource was requested for deletion.
   * This field is not used.
   */
  deleteTime?:
    | Date
    | undefined;
  /**
   * Output only. The time at which this resource will be purged.
   * This field is not used.
   */
  expireTime?:
    | Date
    | undefined;
  /**
   * Output only. Allows users to store small amounts of arbitrary data.
   * Both the key and the value must be 63 characters or less each.
   * At most 100 annotations.
   * This field is not used.
   */
  annotations: { [key: string]: string };
  /**
   * Output only. This checksum is computed by the server based on the value of
   * other fields. This may be sent on update, undelete, and delete requests to
   * ensure the client has an up-to-date value before proceeding. This field is
   * not used.
   */
  etag: string;
  /**
   * Output only. Whether or not this CustomClass is in the process of being
   * updated. This field is not used.
   */
  reconciling: boolean;
}

/** Set of states that define the lifecycle of a CustomClass. */
export enum CustomClass_State {
  /**
   * STATE_UNSPECIFIED - Unspecified state.  This is only used/useful for distinguishing
   * unset values.
   */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The normal and active state. */
  ACTIVE = 2,
  /** DELETED - This CustomClass has been deleted. */
  DELETED = 4,
  UNRECOGNIZED = -1,
}

export function customClass_StateFromJSON(object: any): CustomClass_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CustomClass_State.STATE_UNSPECIFIED;
    case 2:
    case "ACTIVE":
      return CustomClass_State.ACTIVE;
    case 4:
    case "DELETED":
      return CustomClass_State.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomClass_State.UNRECOGNIZED;
  }
}

export function customClass_StateToJSON(object: CustomClass_State): string {
  switch (object) {
    case CustomClass_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CustomClass_State.ACTIVE:
      return "ACTIVE";
    case CustomClass_State.DELETED:
      return "DELETED";
    case CustomClass_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An item of the class. */
export interface CustomClass_ClassItem {
  /** The class item's value. */
  value: string;
}

export interface CustomClass_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Provides "hints" to the speech recognizer to favor specific words and phrases
 * in the results.
 */
export interface PhraseSet {
  /** The resource name of the phrase set. */
  name: string;
  /** A list of word and phrases. */
  phrases: PhraseSet_Phrase[];
  /**
   * Hint Boost. Positive value will increase the probability that a specific
   * phrase will be recognized over other similar sounding phrases. The higher
   * the boost, the higher the chance of false positive recognition as well.
   * Negative boost values would correspond to anti-biasing. Anti-biasing is not
   * enabled, so negative boost will simply be ignored. Though `boost` can
   * accept a wide range of positive values, most use cases are best served with
   * values between 0 (exclusive) and 20. We recommend using a binary search
   * approach to finding the optimal value for your use case as well as adding
   * phrases both with and without boost to your requests.
   */
  boost: number;
  /**
   * Output only. The [KMS key
   * name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
   * the content of the PhraseSet is encrypted. The expected format is
   * `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
   */
  kmsKeyName: string;
  /**
   * Output only. The [KMS key version
   * name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
   * with which content of the PhraseSet is encrypted. The expected format is
   * `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
   */
  kmsKeyVersionName: string;
  /**
   * Output only. System-assigned unique identifier for the PhraseSet.
   * This field is not used.
   */
  uid: string;
  /**
   * Output only. User-settable, human-readable name for the PhraseSet. Must be
   * 63 characters or less. This field is not used.
   */
  displayName: string;
  /**
   * Output only. The CustomClass lifecycle state.
   * This field is not used.
   */
  state: PhraseSet_State;
  /**
   * Output only. The time at which this resource was requested for deletion.
   * This field is not used.
   */
  deleteTime?:
    | Date
    | undefined;
  /**
   * Output only. The time at which this resource will be purged.
   * This field is not used.
   */
  expireTime?:
    | Date
    | undefined;
  /**
   * Output only. Allows users to store small amounts of arbitrary data.
   * Both the key and the value must be 63 characters or less each.
   * At most 100 annotations.
   * This field is not used.
   */
  annotations: { [key: string]: string };
  /**
   * Output only. This checksum is computed by the server based on the value of
   * other fields. This may be sent on update, undelete, and delete requests to
   * ensure the client has an up-to-date value before proceeding. This field is
   * not used.
   */
  etag: string;
  /**
   * Output only. Whether or not this PhraseSet is in the process of being
   * updated. This field is not used.
   */
  reconciling: boolean;
}

/** Set of states that define the lifecycle of a CustomClass. */
export enum PhraseSet_State {
  /**
   * STATE_UNSPECIFIED - Unspecified state.  This is only used/useful for distinguishing
   * unset values.
   */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The normal and active state. */
  ACTIVE = 2,
  /** DELETED - This CustomClass has been deleted. */
  DELETED = 4,
  UNRECOGNIZED = -1,
}

export function phraseSet_StateFromJSON(object: any): PhraseSet_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return PhraseSet_State.STATE_UNSPECIFIED;
    case 2:
    case "ACTIVE":
      return PhraseSet_State.ACTIVE;
    case 4:
    case "DELETED":
      return PhraseSet_State.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhraseSet_State.UNRECOGNIZED;
  }
}

export function phraseSet_StateToJSON(object: PhraseSet_State): string {
  switch (object) {
    case PhraseSet_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case PhraseSet_State.ACTIVE:
      return "ACTIVE";
    case PhraseSet_State.DELETED:
      return "DELETED";
    case PhraseSet_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A phrases containing words and phrase "hints" so that
 * the speech recognition is more likely to recognize them. This can be used
 * to improve the accuracy for specific words and phrases, for example, if
 * specific commands are typically spoken by the user. This can also be used
 * to add additional words to the vocabulary of the recognizer. See
 * [usage limits](https://cloud.google.com/speech-to-text/quotas#content).
 *
 * List items can also include pre-built or custom classes containing groups
 * of words that represent common concepts that occur in natural language. For
 * example, rather than providing a phrase hint for every month of the
 * year (e.g. "i was born in january", "i was born in febuary", ...), use the
 * pre-built `$MONTH` class improves the likelihood of correctly transcribing
 * audio that includes months (e.g. "i was born in $month").
 * To refer to pre-built classes, use the class' symbol prepended with `$`
 * e.g. `$MONTH`. To refer to custom classes that were defined inline in the
 * request, set the class's `custom_class_id` to a string unique to all class
 * resources and inline classes. Then use the class' id wrapped in $`{...}`
 * e.g. "${my-months}". To refer to custom classes resources, use the class'
 * id wrapped in `${}` (e.g. `${my-months}`).
 *
 * Speech-to-Text supports three locations: `global`, `us` (US North America),
 * and `eu` (Europe). If you are calling the `speech.googleapis.com`
 * endpoint, use the `global` location. To specify a region, use a
 * [regional endpoint](https://cloud.google.com/speech-to-text/docs/endpoints)
 * with matching `us` or `eu` location value.
 */
export interface PhraseSet_Phrase {
  /** The phrase itself. */
  value: string;
  /**
   * Hint Boost. Overrides the boost set at the phrase set level.
   * Positive value will increase the probability that a specific phrase will
   * be recognized over other similar sounding phrases. The higher the boost,
   * the higher the chance of false positive recognition as well. Negative
   * boost will simply be ignored. Though `boost` can accept a wide range of
   * positive values, most use cases are best served
   * with values between 0 and 20. We recommend using a binary search approach
   * to finding the optimal value for your use case as well as adding
   * phrases both with and without boost to your requests.
   */
  boost: number;
}

export interface PhraseSet_AnnotationsEntry {
  key: string;
  value: string;
}

/** The data within all PhraseSet events. */
export interface PhraseSetEventData {
  /** Optional. The PhraseSet event payload. Unset for deletion events. */
  payload?: PhraseSet | undefined;
}

/** The data within all CustomClass events. */
export interface CustomClassEventData {
  /** Optional. The CustomClass event payload. Unset for deletion events. */
  payload?: CustomClass | undefined;
}

function createBaseCustomClass(): CustomClass {
  return {
    name: "",
    customClassId: "",
    items: [],
    kmsKeyName: "",
    kmsKeyVersionName: "",
    uid: "",
    displayName: "",
    state: 0,
    deleteTime: undefined,
    expireTime: undefined,
    annotations: {},
    etag: "",
    reconciling: false,
  };
}

export const CustomClass: MessageFns<CustomClass> = {
  encode(message: CustomClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.customClassId !== "") {
      writer.uint32(18).string(message.customClassId);
    }
    for (const v of message.items) {
      CustomClass_ClassItem.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.kmsKeyName !== "") {
      writer.uint32(50).string(message.kmsKeyName);
    }
    if (message.kmsKeyVersionName !== "") {
      writer.uint32(58).string(message.kmsKeyVersionName);
    }
    if (message.uid !== "") {
      writer.uint32(66).string(message.uid);
    }
    if (message.displayName !== "") {
      writer.uint32(74).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(90).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(98).fork()).join();
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      CustomClass_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(114).string(message.etag);
    }
    if (message.reconciling !== false) {
      writer.uint32(120).bool(message.reconciling);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customClassId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items.push(CustomClass_ClassItem.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.kmsKeyVersionName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = CustomClass_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.annotations[entry13.key] = entry13.value;
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomClass {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      customClassId: isSet(object.customClassId) ? globalThis.String(object.customClassId) : "",
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CustomClass_ClassItem.fromJSON(e))
        : [],
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "",
      kmsKeyVersionName: isSet(object.kmsKeyVersionName) ? globalThis.String(object.kmsKeyVersionName) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? customClass_StateFromJSON(object.state) : 0,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
    };
  },

  toJSON(message: CustomClass): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.customClassId !== "") {
      obj.customClassId = message.customClassId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CustomClass_ClassItem.toJSON(e));
    }
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.kmsKeyVersionName !== "") {
      obj.kmsKeyVersionName = message.kmsKeyVersionName;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = customClass_StateToJSON(message.state);
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomClass>, I>>(base?: I): CustomClass {
    return CustomClass.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomClass>, I>>(object: I): CustomClass {
    const message = createBaseCustomClass();
    message.name = object.name ?? "";
    message.customClassId = object.customClassId ?? "";
    message.items = object.items?.map((e) => CustomClass_ClassItem.fromPartial(e)) || [];
    message.kmsKeyName = object.kmsKeyName ?? "";
    message.kmsKeyVersionName = object.kmsKeyVersionName ?? "";
    message.uid = object.uid ?? "";
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.deleteTime = object.deleteTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.etag = object.etag ?? "";
    message.reconciling = object.reconciling ?? false;
    return message;
  },
};

function createBaseCustomClass_ClassItem(): CustomClass_ClassItem {
  return { value: "" };
}

export const CustomClass_ClassItem: MessageFns<CustomClass_ClassItem> = {
  encode(message: CustomClass_ClassItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomClass_ClassItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomClass_ClassItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomClass_ClassItem {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: CustomClass_ClassItem): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomClass_ClassItem>, I>>(base?: I): CustomClass_ClassItem {
    return CustomClass_ClassItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomClass_ClassItem>, I>>(object: I): CustomClass_ClassItem {
    const message = createBaseCustomClass_ClassItem();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCustomClass_AnnotationsEntry(): CustomClass_AnnotationsEntry {
  return { key: "", value: "" };
}

export const CustomClass_AnnotationsEntry: MessageFns<CustomClass_AnnotationsEntry> = {
  encode(message: CustomClass_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomClass_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomClass_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomClass_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CustomClass_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomClass_AnnotationsEntry>, I>>(base?: I): CustomClass_AnnotationsEntry {
    return CustomClass_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomClass_AnnotationsEntry>, I>>(object: I): CustomClass_AnnotationsEntry {
    const message = createBaseCustomClass_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePhraseSet(): PhraseSet {
  return {
    name: "",
    phrases: [],
    boost: 0,
    kmsKeyName: "",
    kmsKeyVersionName: "",
    uid: "",
    displayName: "",
    state: 0,
    deleteTime: undefined,
    expireTime: undefined,
    annotations: {},
    etag: "",
    reconciling: false,
  };
}

export const PhraseSet: MessageFns<PhraseSet> = {
  encode(message: PhraseSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.phrases) {
      PhraseSet_Phrase.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.boost !== 0) {
      writer.uint32(37).float(message.boost);
    }
    if (message.kmsKeyName !== "") {
      writer.uint32(58).string(message.kmsKeyName);
    }
    if (message.kmsKeyVersionName !== "") {
      writer.uint32(66).string(message.kmsKeyVersionName);
    }
    if (message.uid !== "") {
      writer.uint32(74).string(message.uid);
    }
    if (message.displayName !== "") {
      writer.uint32(82).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(88).int32(message.state);
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(98).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(106).fork()).join();
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      PhraseSet_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(122).string(message.etag);
    }
    if (message.reconciling !== false) {
      writer.uint32(128).bool(message.reconciling);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.phrases.push(PhraseSet_Phrase.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.boost = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.kmsKeyVersionName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = PhraseSet_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.annotations[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseSet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      phrases: globalThis.Array.isArray(object?.phrases)
        ? object.phrases.map((e: any) => PhraseSet_Phrase.fromJSON(e))
        : [],
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "",
      kmsKeyVersionName: isSet(object.kmsKeyVersionName) ? globalThis.String(object.kmsKeyVersionName) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? phraseSet_StateFromJSON(object.state) : 0,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
    };
  },

  toJSON(message: PhraseSet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.phrases?.length) {
      obj.phrases = message.phrases.map((e) => PhraseSet_Phrase.toJSON(e));
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.kmsKeyVersionName !== "") {
      obj.kmsKeyVersionName = message.kmsKeyVersionName;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = phraseSet_StateToJSON(message.state);
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhraseSet>, I>>(base?: I): PhraseSet {
    return PhraseSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhraseSet>, I>>(object: I): PhraseSet {
    const message = createBasePhraseSet();
    message.name = object.name ?? "";
    message.phrases = object.phrases?.map((e) => PhraseSet_Phrase.fromPartial(e)) || [];
    message.boost = object.boost ?? 0;
    message.kmsKeyName = object.kmsKeyName ?? "";
    message.kmsKeyVersionName = object.kmsKeyVersionName ?? "";
    message.uid = object.uid ?? "";
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.deleteTime = object.deleteTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.etag = object.etag ?? "";
    message.reconciling = object.reconciling ?? false;
    return message;
  },
};

function createBasePhraseSet_Phrase(): PhraseSet_Phrase {
  return { value: "", boost: 0 };
}

export const PhraseSet_Phrase: MessageFns<PhraseSet_Phrase> = {
  encode(message: PhraseSet_Phrase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.boost !== 0) {
      writer.uint32(21).float(message.boost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseSet_Phrase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseSet_Phrase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.boost = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseSet_Phrase {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
    };
  },

  toJSON(message: PhraseSet_Phrase): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhraseSet_Phrase>, I>>(base?: I): PhraseSet_Phrase {
    return PhraseSet_Phrase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhraseSet_Phrase>, I>>(object: I): PhraseSet_Phrase {
    const message = createBasePhraseSet_Phrase();
    message.value = object.value ?? "";
    message.boost = object.boost ?? 0;
    return message;
  },
};

function createBasePhraseSet_AnnotationsEntry(): PhraseSet_AnnotationsEntry {
  return { key: "", value: "" };
}

export const PhraseSet_AnnotationsEntry: MessageFns<PhraseSet_AnnotationsEntry> = {
  encode(message: PhraseSet_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseSet_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseSet_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseSet_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PhraseSet_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhraseSet_AnnotationsEntry>, I>>(base?: I): PhraseSet_AnnotationsEntry {
    return PhraseSet_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhraseSet_AnnotationsEntry>, I>>(object: I): PhraseSet_AnnotationsEntry {
    const message = createBasePhraseSet_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePhraseSetEventData(): PhraseSetEventData {
  return { payload: undefined };
}

export const PhraseSetEventData: MessageFns<PhraseSetEventData> = {
  encode(message: PhraseSetEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      PhraseSet.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseSetEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseSetEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = PhraseSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseSetEventData {
    return { payload: isSet(object.payload) ? PhraseSet.fromJSON(object.payload) : undefined };
  },

  toJSON(message: PhraseSetEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = PhraseSet.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhraseSetEventData>, I>>(base?: I): PhraseSetEventData {
    return PhraseSetEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhraseSetEventData>, I>>(object: I): PhraseSetEventData {
    const message = createBasePhraseSetEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? PhraseSet.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseCustomClassEventData(): CustomClassEventData {
  return { payload: undefined };
}

export const CustomClassEventData: MessageFns<CustomClassEventData> = {
  encode(message: CustomClassEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      CustomClass.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomClassEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomClassEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = CustomClass.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomClassEventData {
    return { payload: isSet(object.payload) ? CustomClass.fromJSON(object.payload) : undefined };
  },

  toJSON(message: CustomClassEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = CustomClass.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomClassEventData>, I>>(base?: I): CustomClassEventData {
    return CustomClassEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomClassEventData>, I>>(object: I): CustomClassEventData {
    const message = createBaseCustomClassEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? CustomClass.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
