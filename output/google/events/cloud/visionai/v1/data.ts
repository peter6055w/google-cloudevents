// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/cloud/visionai/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration";
import { Timestamp } from "../../../../protobuf/timestamp";

export const protobufPackage = "google.events.cloud.visionai.v1";

/** Enum describing all possible types of a stream annotation. */
export enum StreamAnnotationType {
  /** STREAM_ANNOTATION_TYPE_UNSPECIFIED - Type UNSPECIFIED. */
  STREAM_ANNOTATION_TYPE_UNSPECIFIED = 0,
  /**
   * STREAM_ANNOTATION_TYPE_ACTIVE_ZONE - active_zone annotation defines a polygon on top of the content from an
   * image/video based stream, following processing will only focus on the
   * content inside the active zone.
   */
  STREAM_ANNOTATION_TYPE_ACTIVE_ZONE = 1,
  /**
   * STREAM_ANNOTATION_TYPE_CROSSING_LINE - crossing_line annotation defines a polyline on top of the content from an
   * image/video based Vision AI stream, events happening across the line will
   * be captured. For example, the counts of people who goes acroos the line
   * in Occupancy Analytic Processor.
   */
  STREAM_ANNOTATION_TYPE_CROSSING_LINE = 2,
  UNRECOGNIZED = -1,
}

export function streamAnnotationTypeFromJSON(object: any): StreamAnnotationType {
  switch (object) {
    case 0:
    case "STREAM_ANNOTATION_TYPE_UNSPECIFIED":
      return StreamAnnotationType.STREAM_ANNOTATION_TYPE_UNSPECIFIED;
    case 1:
    case "STREAM_ANNOTATION_TYPE_ACTIVE_ZONE":
      return StreamAnnotationType.STREAM_ANNOTATION_TYPE_ACTIVE_ZONE;
    case 2:
    case "STREAM_ANNOTATION_TYPE_CROSSING_LINE":
      return StreamAnnotationType.STREAM_ANNOTATION_TYPE_CROSSING_LINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamAnnotationType.UNRECOGNIZED;
  }
}

export function streamAnnotationTypeToJSON(object: StreamAnnotationType): string {
  switch (object) {
    case StreamAnnotationType.STREAM_ANNOTATION_TYPE_UNSPECIFIED:
      return "STREAM_ANNOTATION_TYPE_UNSPECIFIED";
    case StreamAnnotationType.STREAM_ANNOTATION_TYPE_ACTIVE_ZONE:
      return "STREAM_ANNOTATION_TYPE_ACTIVE_ZONE";
    case StreamAnnotationType.STREAM_ANNOTATION_TYPE_CROSSING_LINE:
      return "STREAM_ANNOTATION_TYPE_CROSSING_LINE";
    case StreamAnnotationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RunMode represents the mode to launch the Process on. */
export enum RunMode {
  /** RUN_MODE_UNSPECIFIED - Mode is unspecified. */
  RUN_MODE_UNSPECIFIED = 0,
  /**
   * LIVE - Live mode. Meaning the Process is launched to handle live video
   * source, and possible packet drops are expected.
   */
  LIVE = 1,
  /**
   * SUBMISSION - Submission mode. Meaning the Process is launched to handle bounded video
   * files, with no packet drop. Completion status is tracked.
   */
  SUBMISSION = 2,
  UNRECOGNIZED = -1,
}

export function runModeFromJSON(object: any): RunMode {
  switch (object) {
    case 0:
    case "RUN_MODE_UNSPECIFIED":
      return RunMode.RUN_MODE_UNSPECIFIED;
    case 1:
    case "LIVE":
      return RunMode.LIVE;
    case 2:
    case "SUBMISSION":
      return RunMode.SUBMISSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunMode.UNRECOGNIZED;
  }
}

export function runModeToJSON(object: RunMode): string {
  switch (object) {
    case RunMode.RUN_MODE_UNSPECIFIED:
      return "RUN_MODE_UNSPECIFIED";
    case RunMode.LIVE:
      return "LIVE";
    case RunMode.SUBMISSION:
      return "SUBMISSION";
    case RunMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** All the supported model types in Vision AI App Platform. */
export enum ModelType {
  /** MODEL_TYPE_UNSPECIFIED - Processor Type UNSPECIFIED. */
  MODEL_TYPE_UNSPECIFIED = 0,
  /** IMAGE_CLASSIFICATION - Model Type Image Classification. */
  IMAGE_CLASSIFICATION = 1,
  /** OBJECT_DETECTION - Model Type Object Detection. */
  OBJECT_DETECTION = 2,
  /** VIDEO_CLASSIFICATION - Model Type Video Classification. */
  VIDEO_CLASSIFICATION = 3,
  /** VIDEO_OBJECT_TRACKING - Model Type Object Tracking. */
  VIDEO_OBJECT_TRACKING = 4,
  /** VIDEO_ACTION_RECOGNITION - Model Type Action Recognition. */
  VIDEO_ACTION_RECOGNITION = 5,
  /** OCCUPANCY_COUNTING - Model Type Occupancy Counting. */
  OCCUPANCY_COUNTING = 6,
  /** PERSON_BLUR - Model Type Person Blur. */
  PERSON_BLUR = 7,
  /** VERTEX_CUSTOM - Model Type Vertex Custom. */
  VERTEX_CUSTOM = 8,
  UNRECOGNIZED = -1,
}

export function modelTypeFromJSON(object: any): ModelType {
  switch (object) {
    case 0:
    case "MODEL_TYPE_UNSPECIFIED":
      return ModelType.MODEL_TYPE_UNSPECIFIED;
    case 1:
    case "IMAGE_CLASSIFICATION":
      return ModelType.IMAGE_CLASSIFICATION;
    case 2:
    case "OBJECT_DETECTION":
      return ModelType.OBJECT_DETECTION;
    case 3:
    case "VIDEO_CLASSIFICATION":
      return ModelType.VIDEO_CLASSIFICATION;
    case 4:
    case "VIDEO_OBJECT_TRACKING":
      return ModelType.VIDEO_OBJECT_TRACKING;
    case 5:
    case "VIDEO_ACTION_RECOGNITION":
      return ModelType.VIDEO_ACTION_RECOGNITION;
    case 6:
    case "OCCUPANCY_COUNTING":
      return ModelType.OCCUPANCY_COUNTING;
    case 7:
    case "PERSON_BLUR":
      return ModelType.PERSON_BLUR;
    case 8:
    case "VERTEX_CUSTOM":
      return ModelType.VERTEX_CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelType.UNRECOGNIZED;
  }
}

export function modelTypeToJSON(object: ModelType): string {
  switch (object) {
    case ModelType.MODEL_TYPE_UNSPECIFIED:
      return "MODEL_TYPE_UNSPECIFIED";
    case ModelType.IMAGE_CLASSIFICATION:
      return "IMAGE_CLASSIFICATION";
    case ModelType.OBJECT_DETECTION:
      return "OBJECT_DETECTION";
    case ModelType.VIDEO_CLASSIFICATION:
      return "VIDEO_CLASSIFICATION";
    case ModelType.VIDEO_OBJECT_TRACKING:
      return "VIDEO_OBJECT_TRACKING";
    case ModelType.VIDEO_ACTION_RECOGNITION:
      return "VIDEO_ACTION_RECOGNITION";
    case ModelType.OCCUPANCY_COUNTING:
      return "OCCUPANCY_COUNTING";
    case ModelType.PERSON_BLUR:
      return "PERSON_BLUR";
    case ModelType.VERTEX_CUSTOM:
      return "VERTEX_CUSTOM";
    case ModelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a hardware accelerator type. */
export enum AcceleratorType {
  /** ACCELERATOR_TYPE_UNSPECIFIED - Unspecified accelerator type, which means no accelerator. */
  ACCELERATOR_TYPE_UNSPECIFIED = 0,
  /** NVIDIA_TESLA_K80 - Nvidia Tesla K80 GPU. */
  NVIDIA_TESLA_K80 = 1,
  /** NVIDIA_TESLA_P100 - Nvidia Tesla P100 GPU. */
  NVIDIA_TESLA_P100 = 2,
  /** NVIDIA_TESLA_V100 - Nvidia Tesla V100 GPU. */
  NVIDIA_TESLA_V100 = 3,
  /** NVIDIA_TESLA_P4 - Nvidia Tesla P4 GPU. */
  NVIDIA_TESLA_P4 = 4,
  /** NVIDIA_TESLA_T4 - Nvidia Tesla T4 GPU. */
  NVIDIA_TESLA_T4 = 5,
  /** NVIDIA_TESLA_A100 - Nvidia Tesla A100 GPU. */
  NVIDIA_TESLA_A100 = 8,
  /** TPU_V2 - TPU v2. */
  TPU_V2 = 6,
  /** TPU_V3 - TPU v3. */
  TPU_V3 = 7,
  UNRECOGNIZED = -1,
}

export function acceleratorTypeFromJSON(object: any): AcceleratorType {
  switch (object) {
    case 0:
    case "ACCELERATOR_TYPE_UNSPECIFIED":
      return AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED;
    case 1:
    case "NVIDIA_TESLA_K80":
      return AcceleratorType.NVIDIA_TESLA_K80;
    case 2:
    case "NVIDIA_TESLA_P100":
      return AcceleratorType.NVIDIA_TESLA_P100;
    case 3:
    case "NVIDIA_TESLA_V100":
      return AcceleratorType.NVIDIA_TESLA_V100;
    case 4:
    case "NVIDIA_TESLA_P4":
      return AcceleratorType.NVIDIA_TESLA_P4;
    case 5:
    case "NVIDIA_TESLA_T4":
      return AcceleratorType.NVIDIA_TESLA_T4;
    case 8:
    case "NVIDIA_TESLA_A100":
      return AcceleratorType.NVIDIA_TESLA_A100;
    case 6:
    case "TPU_V2":
      return AcceleratorType.TPU_V2;
    case 7:
    case "TPU_V3":
      return AcceleratorType.TPU_V3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AcceleratorType.UNRECOGNIZED;
  }
}

export function acceleratorTypeToJSON(object: AcceleratorType): string {
  switch (object) {
    case AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED:
      return "ACCELERATOR_TYPE_UNSPECIFIED";
    case AcceleratorType.NVIDIA_TESLA_K80:
      return "NVIDIA_TESLA_K80";
    case AcceleratorType.NVIDIA_TESLA_P100:
      return "NVIDIA_TESLA_P100";
    case AcceleratorType.NVIDIA_TESLA_V100:
      return "NVIDIA_TESLA_V100";
    case AcceleratorType.NVIDIA_TESLA_P4:
      return "NVIDIA_TESLA_P4";
    case AcceleratorType.NVIDIA_TESLA_T4:
      return "NVIDIA_TESLA_T4";
    case AcceleratorType.NVIDIA_TESLA_A100:
      return "NVIDIA_TESLA_A100";
    case AcceleratorType.TPU_V2:
      return "TPU_V2";
    case AcceleratorType.TPU_V3:
      return "TPU_V3";
    case AcceleratorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** All supported data types. */
export enum DataType {
  /** DATA_TYPE_UNSPECIFIED - The default value of DataType. */
  DATA_TYPE_UNSPECIFIED = 0,
  /** VIDEO - Video data type like H264. */
  VIDEO = 1,
  /** IMAGE - Image data type. */
  IMAGE = 3,
  /** PROTO - Protobuf data type, usually used for general data blob. */
  PROTO = 2,
  UNRECOGNIZED = -1,
}

export function dataTypeFromJSON(object: any): DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "VIDEO":
      return DataType.VIDEO;
    case 3:
    case "IMAGE":
      return DataType.IMAGE;
    case 2:
    case "PROTO":
      return DataType.PROTO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataType.UNRECOGNIZED;
  }
}

export function dataTypeToJSON(object: DataType): string {
  switch (object) {
    case DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case DataType.VIDEO:
      return "VIDEO";
    case DataType.IMAGE:
      return "IMAGE";
    case DataType.PROTO:
      return "PROTO";
    case DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** message about annotations about Vision AI stream resource. */
export interface StreamAnnotation {
  /** Annotation for type ACTIVE_ZONE */
  activeZone?:
    | NormalizedPolygon
    | undefined;
  /** Annotation for type CROSSING_LINE */
  crossingLine?:
    | NormalizedPolyline
    | undefined;
  /**
   * ID of the annotation. It must be unique when used in the certain context.
   * For example, all the annotations to one input streams of a Vision AI
   * application.
   */
  id: string;
  /** User-friendly name for the annotation. */
  displayName: string;
  /** The Vision AI stream resource name. */
  sourceStream: string;
  /** The actual type of Annotation. */
  type: StreamAnnotationType;
}

/** Normalized Polygon. */
export interface NormalizedPolygon {
  /**
   * The bounding polygon normalized vertices. Top left corner of the image
   * will be [0, 0].
   */
  normalizedVertices: NormalizedVertex[];
}

/**
 * Normalized Pplyline, which represents a curve consisting of connected
 * straight-line segments.
 */
export interface NormalizedPolyline {
  /** A sequence of vertices connected by straight lines. */
  normalizedVertices: NormalizedVertex[];
}

/**
 * A vertex represents a 2D point in the image.
 * NOTE: the normalized vertex coordinates are relative to the original image
 * and range from 0 to 1.
 */
export interface NormalizedVertex {
  /** X coordinate. */
  x: number;
  /** Y coordinate. */
  y: number;
}

/** Message describing the Cluster object. */
export interface Cluster {
  /** Output only. Name of the resource. */
  name: string;
  /** Output only. The create timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Labels as key value pairs */
  labels: { [key: string]: string };
  /** Annotations to allow clients to store small amounts of arbitrary data. */
  annotations: { [key: string]: string };
  /** Output only. The DNS name of the data plane service */
  dataplaneServiceEndpoint: string;
  /** Output only. The current state of the cluster. */
  state: Cluster_State;
  /** Output only. The private service connection service target name. */
  pscTarget: string;
}

/** The current state of the cluster. */
export enum Cluster_State {
  /** STATE_UNSPECIFIED - Not set. */
  STATE_UNSPECIFIED = 0,
  /** PROVISIONING - The PROVISIONING state indicates the cluster is being created. */
  PROVISIONING = 1,
  /**
   * RUNNING - The RUNNING state indicates the cluster has been created and is fully
   * usable.
   */
  RUNNING = 2,
  /** STOPPING - The STOPPING state indicates the cluster is being deleted. */
  STOPPING = 3,
  /**
   * ERROR - The ERROR state indicates the cluster is unusable. It will be
   * automatically deleted.
   */
  ERROR = 4,
  UNRECOGNIZED = -1,
}

export function cluster_StateFromJSON(object: any): Cluster_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Cluster_State.STATE_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return Cluster_State.PROVISIONING;
    case 2:
    case "RUNNING":
      return Cluster_State.RUNNING;
    case 3:
    case "STOPPING":
      return Cluster_State.STOPPING;
    case 4:
    case "ERROR":
      return Cluster_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_State.UNRECOGNIZED;
  }
}

export function cluster_StateToJSON(object: Cluster_State): string {
  switch (object) {
    case Cluster_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Cluster_State.PROVISIONING:
      return "PROVISIONING";
    case Cluster_State.RUNNING:
      return "RUNNING";
    case Cluster_State.STOPPING:
      return "STOPPING";
    case Cluster_State.ERROR:
      return "ERROR";
    case Cluster_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Cluster_LabelsEntry {
  key: string;
  value: string;
}

export interface Cluster_AnnotationsEntry {
  key: string;
  value: string;
}

/** The Google Cloud Storage location for the input content. */
export interface GcsSource {
  /** Required. References to a Google Cloud Storage paths. */
  uris: string[];
}

/** Represents an actual value of an operator attribute. */
export interface AttributeValue {
  /** int. */
  i?:
    | Long
    | undefined;
  /** float. */
  f?:
    | number
    | undefined;
  /** bool. */
  b?:
    | boolean
    | undefined;
  /** string. */
  s?: Uint8Array | undefined;
}

/**
 * Defines an Analyzer.
 *
 * An analyzer processes data from its input streams using the logic defined in
 * the Operator that it represents. Of course, it produces data for the output
 * streams declared in the Operator.
 */
export interface AnalyzerDefinition {
  /**
   * The name of this analyzer.
   *
   * Tentatively [a-z][a-z0-9]*(_[a-z0-9]+)*.
   */
  analyzer: string;
  /**
   * The name of the operator that this analyzer runs.
   *
   * Must match the name of a supported operator.
   */
  operator: string;
  /** Input streams. */
  inputs: AnalyzerDefinition_StreamInput[];
  /**
   * The attribute values that this analyzer applies to the operator.
   *
   * Supply a mapping between the attribute names and the actual value you wish
   * to apply. If an attribute name is omitted, then it will take a
   * preconfigured default value.
   */
  attrs: { [key: string]: AttributeValue };
  /** Debug options. */
  debugOptions?: AnalyzerDefinition_DebugOptions | undefined;
}

/**
 * The inputs to this analyzer.
 *
 * We accept input name references of the following form:
 * <analyzer-name>:<output-argument-name>
 *
 * Example:
 *
 * Suppose you had an operator named "SomeOp" that has 2 output
 * arguments, the first of which is named "foo" and the second of which is
 * named "bar", and an operator named "MyOp" that accepts 2 inputs.
 *
 * Also suppose that there is an analyzer named "some-analyzer" that is
 * running "SomeOp" and another analyzer named "my-analyzer" running "MyOp".
 *
 * To indicate that "my-analyzer" is to consume "some-analyzer"'s "foo"
 * output as its first input and "some-analyzer"'s "bar" output as its
 * second input, you can set this field to the following:
 * input = ["some-analyzer:foo", "some-analyzer:bar"]
 */
export interface AnalyzerDefinition_StreamInput {
  /** The name of the stream input (as discussed above). */
  input: string;
}

/** Options available for debugging purposes only. */
export interface AnalyzerDefinition_DebugOptions {
  /** Environment variables. */
  environmentVariables: { [key: string]: string };
}

export interface AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
  key: string;
  value: string;
}

export interface AnalyzerDefinition_AttrsEntry {
  key: string;
  value?: AttributeValue | undefined;
}

/**
 * Defines a full analysis.
 *
 * This is a description of the overall live analytics pipeline.
 * You may think of this as an edge list representation of a multigraph.
 *
 * This may be directly authored by a human in protobuf textformat, or it may be
 * generated by a programming API (perhaps Python or JavaScript depending on
 * context).
 */
export interface AnalysisDefinition {
  /** Analyzer definitions. */
  analyzers: AnalyzerDefinition[];
}

/** Message describing the status of the Process. */
export interface RunStatus {
  /** The state of the Process. */
  state: RunStatus_State;
  /** The reason of becoming the state. */
  reason: string;
}

/** State represents the running status of the Process. */
export enum RunStatus_State {
  /** STATE_UNSPECIFIED - State is unspecified. */
  STATE_UNSPECIFIED = 0,
  /**
   * INITIALIZING - INITIALIZING means the Process is scheduled but yet ready to handle
   * real traffic.
   */
  INITIALIZING = 1,
  /** RUNNING - RUNNING means the Process is up running and handling traffic. */
  RUNNING = 2,
  /**
   * COMPLETED - COMPLETED means the Process has completed the processing, especially
   * for non-streaming use case.
   */
  COMPLETED = 3,
  /** FAILED - FAILED means the Process failed to complete the processing. */
  FAILED = 4,
  /** PENDING - PENDING means the Process is created but yet to be scheduled. */
  PENDING = 5,
  UNRECOGNIZED = -1,
}

export function runStatus_StateFromJSON(object: any): RunStatus_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return RunStatus_State.STATE_UNSPECIFIED;
    case 1:
    case "INITIALIZING":
      return RunStatus_State.INITIALIZING;
    case 2:
    case "RUNNING":
      return RunStatus_State.RUNNING;
    case 3:
    case "COMPLETED":
      return RunStatus_State.COMPLETED;
    case 4:
    case "FAILED":
      return RunStatus_State.FAILED;
    case 5:
    case "PENDING":
      return RunStatus_State.PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunStatus_State.UNRECOGNIZED;
  }
}

export function runStatus_StateToJSON(object: RunStatus_State): string {
  switch (object) {
    case RunStatus_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case RunStatus_State.INITIALIZING:
      return "INITIALIZING";
    case RunStatus_State.RUNNING:
      return "RUNNING";
    case RunStatus_State.COMPLETED:
      return "COMPLETED";
    case RunStatus_State.FAILED:
      return "FAILED";
    case RunStatus_State.PENDING:
      return "PENDING";
    case RunStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message describing the Analysis object. */
export interface Analysis {
  /** The name of resource. */
  name: string;
  /** Output only. The create timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** The definition of the analysis. */
  analysisDefinition?:
    | AnalysisDefinition
    | undefined;
  /**
   * Map from the input parameter in the definition to the real stream.
   * E.g., suppose you had a stream source operator named "input-0" and you try
   * to receive from the real stream "stream-0". You can add the following
   * mapping: [input-0: stream-0].
   */
  inputStreamsMapping: { [key: string]: string };
  /**
   * Map from the output parameter in the definition to the real stream.
   * E.g., suppose you had a stream sink operator named "output-0" and you try
   * to send to the real stream "stream-0". You can add the following
   * mapping: [output-0: stream-0].
   */
  outputStreamsMapping: { [key: string]: string };
  /**
   * Boolean flag to indicate whether you would like to disable the ability
   * to automatically start a Process when new event happening in the input
   * Stream. If you would like to start a Process manually, the field needs
   * to be set to true.
   */
  disableEventWatch: boolean;
}

export interface Analysis_LabelsEntry {
  key: string;
  value: string;
}

export interface Analysis_InputStreamsMappingEntry {
  key: string;
  value: string;
}

export interface Analysis_OutputStreamsMappingEntry {
  key: string;
  value: string;
}

/** Message describing the Process object. */
export interface Process {
  /** The name of resource. */
  name: string;
  /** Output only. The create timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Required. Reference to an existing Analysis resource. */
  analysis: string;
  /**
   * Optional. Attribute overrides of the Analyzers.
   * Format for each single override item:
   * "{analyzer_name}:{attribute_key}={value}"
   */
  attributeOverrides: string[];
  /** Optional. Status of the Process. */
  runStatus?:
    | RunStatus
    | undefined;
  /** Optional. Run mode of the Process. */
  runMode: RunMode;
  /**
   * Optional. Event ID of the input/output streams.
   * This is useful when you have a StreamSource/StreamSink operator in the
   * Analysis, and you want to manually specify the Event to read from/write to.
   */
  eventId: string;
  /** Optional. Optional: Batch ID of the Process. */
  batchId: string;
  /**
   * Optional. Optional: The number of retries for a process in submission mode
   * the system should try before declaring failure. By default, no retry will
   * be performed.
   */
  retryCount: number;
}

/** Message describing Application object */
export interface Application {
  /** name of resource */
  name: string;
  /** Output only. [Output only] Create timestamp */
  createTime?:
    | Date
    | undefined;
  /** Output only. [Output only] Update timestamp */
  updateTime?:
    | Date
    | undefined;
  /** Labels as key value pairs */
  labels: { [key: string]: string };
  /** Required. A user friendly display name for the solution. */
  displayName: string;
  /** A description for this application. */
  description: string;
  /** Application graph configuration. */
  applicationConfigs?:
    | ApplicationConfigs
    | undefined;
  /**
   * Output only. Application graph runtime info. Only exists when application
   * state equals to DEPLOYED.
   */
  runtimeInfo?:
    | Application_ApplicationRuntimeInfo
    | undefined;
  /** Output only. State of the application. */
  state: Application_State;
  /** Billing mode of the application. */
  billingMode: Application_BillingMode;
}

/** State of the Application */
export enum Application_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** CREATED - State CREATED. */
  CREATED = 1,
  /** DEPLOYING - State DEPLOYING. */
  DEPLOYING = 2,
  /** DEPLOYED - State DEPLOYED. */
  DEPLOYED = 3,
  /** UNDEPLOYING - State UNDEPLOYING. */
  UNDEPLOYING = 4,
  /** DELETED - State DELETED. */
  DELETED = 5,
  /** ERROR - State ERROR. */
  ERROR = 6,
  /** CREATING - State CREATING. */
  CREATING = 7,
  /** UPDATING - State Updating. */
  UPDATING = 8,
  /** DELETING - State Deleting. */
  DELETING = 9,
  /** FIXING - State Fixing. */
  FIXING = 10,
  UNRECOGNIZED = -1,
}

export function application_StateFromJSON(object: any): Application_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Application_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATED":
      return Application_State.CREATED;
    case 2:
    case "DEPLOYING":
      return Application_State.DEPLOYING;
    case 3:
    case "DEPLOYED":
      return Application_State.DEPLOYED;
    case 4:
    case "UNDEPLOYING":
      return Application_State.UNDEPLOYING;
    case 5:
    case "DELETED":
      return Application_State.DELETED;
    case 6:
    case "ERROR":
      return Application_State.ERROR;
    case 7:
    case "CREATING":
      return Application_State.CREATING;
    case 8:
    case "UPDATING":
      return Application_State.UPDATING;
    case 9:
    case "DELETING":
      return Application_State.DELETING;
    case 10:
    case "FIXING":
      return Application_State.FIXING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Application_State.UNRECOGNIZED;
  }
}

export function application_StateToJSON(object: Application_State): string {
  switch (object) {
    case Application_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Application_State.CREATED:
      return "CREATED";
    case Application_State.DEPLOYING:
      return "DEPLOYING";
    case Application_State.DEPLOYED:
      return "DEPLOYED";
    case Application_State.UNDEPLOYING:
      return "UNDEPLOYING";
    case Application_State.DELETED:
      return "DELETED";
    case Application_State.ERROR:
      return "ERROR";
    case Application_State.CREATING:
      return "CREATING";
    case Application_State.UPDATING:
      return "UPDATING";
    case Application_State.DELETING:
      return "DELETING";
    case Application_State.FIXING:
      return "FIXING";
    case Application_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Billing mode of the Application */
export enum Application_BillingMode {
  /** BILLING_MODE_UNSPECIFIED - The default value. */
  BILLING_MODE_UNSPECIFIED = 0,
  /** PAYG - Pay as you go billing mode. */
  PAYG = 1,
  /** MONTHLY - Monthly billing mode. */
  MONTHLY = 2,
  UNRECOGNIZED = -1,
}

export function application_BillingModeFromJSON(object: any): Application_BillingMode {
  switch (object) {
    case 0:
    case "BILLING_MODE_UNSPECIFIED":
      return Application_BillingMode.BILLING_MODE_UNSPECIFIED;
    case 1:
    case "PAYG":
      return Application_BillingMode.PAYG;
    case 2:
    case "MONTHLY":
      return Application_BillingMode.MONTHLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Application_BillingMode.UNRECOGNIZED;
  }
}

export function application_BillingModeToJSON(object: Application_BillingMode): string {
  switch (object) {
    case Application_BillingMode.BILLING_MODE_UNSPECIFIED:
      return "BILLING_MODE_UNSPECIFIED";
    case Application_BillingMode.PAYG:
      return "PAYG";
    case Application_BillingMode.MONTHLY:
      return "MONTHLY";
    case Application_BillingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message storing the runtime information of the application. */
export interface Application_ApplicationRuntimeInfo {
  /** Timestamp when the engine be deployed */
  deployTime?:
    | Date
    | undefined;
  /** Globally created resources like warehouse dataschemas. */
  globalOutputResources: Application_ApplicationRuntimeInfo_GlobalOutputResource[];
  /** Monitoring-related configuration for this application. */
  monitoringConfig?: Application_ApplicationRuntimeInfo_MonitoringConfig | undefined;
}

/** Message about output resources from application. */
export interface Application_ApplicationRuntimeInfo_GlobalOutputResource {
  /** The full resource name of the outputted resources. */
  outputResource: string;
  /**
   * The name of graph node who produces the output resource name.
   * For example:
   * output_resource:
   * /projects/123/locations/us-central1/corpora/my-corpus/dataSchemas/my-schema
   * producer_node: occupancy-count
   */
  producerNode: string;
  /**
   * The key of the output resource, it has to be unique within the same
   * producer node. One producer node can output several output resources,
   * the key can be used to match corresponding output resources.
   */
  key: string;
}

/** Monitoring-related configuration for an application. */
export interface Application_ApplicationRuntimeInfo_MonitoringConfig {
  /** Whether this application has monitoring enabled. */
  enabled: boolean;
}

export interface Application_LabelsEntry {
  key: string;
  value: string;
}

/** Message storing the graph of the application. */
export interface ApplicationConfigs {
  /** A list of nodes  in the application graph. */
  nodes: Node[];
}

/** Message describing node object. */
export interface Node {
  /**
   * By default, the output of the node will only be available to downstream
   * nodes. To consume the direct output from the application node, the output
   * must be sent to Vision AI Streams at first.
   *
   * By setting output_all_output_channels_to_stream to true, App Platform
   * will automatically send all the outputs of the current node to Vision AI
   * Stream resources (one stream per output channel). The output stream
   * resource will be created by App Platform automatically during deployment
   * and deleted after application un-deployment.
   * Note that this config applies to all the Application Instances.
   *
   * The output stream can be override at instance level by
   * configuring the `output_resources` section of Instance resource.
   * `producer_node` should be current node, `output_resource_binding` should
   * be the output channel name (or leave it blank if there is only 1 output
   * channel of the processor) and `output_resource` should be the target
   * output stream.
   */
  outputAllOutputChannelsToStream?:
    | boolean
    | undefined;
  /** Required. A unique name for the node. */
  name: string;
  /** A user friendly display name for the node. */
  displayName: string;
  /** Node config. */
  nodeConfig?:
    | ProcessorConfig
    | undefined;
  /** Processor name refer to the chosen processor resource. */
  processor: string;
  /**
   * Parent node. Input node should not have parent node. For V1 Alpha1/Beta
   * only media warehouse node can have multiple parents, other types of nodes
   * will only have one parent.
   */
  parents: Node_InputEdge[];
}

/** Message describing one edge pointing into a node. */
export interface Node_InputEdge {
  /** The name of the parent node. */
  parentNode: string;
  /**
   * The connected output artifact of the parent node.
   * It can be omitted if target processor only has 1 output artifact.
   */
  parentOutputChannel: string;
  /**
   * The connected input channel of the current node's processor.
   * It can be omitted if target processor only has 1 input channel.
   */
  connectedInputChannel: string;
}

/** Message describing Draft object */
export interface Draft {
  /** name of resource */
  name: string;
  /** Output only. [Output only] Create timestamp */
  createTime?:
    | Date
    | undefined;
  /** Output only. [Output only] Create timestamp */
  updateTime?:
    | Date
    | undefined;
  /** Labels as key value pairs */
  labels: { [key: string]: string };
  /** Required. A user friendly display name for the solution. */
  displayName: string;
  /** A description for this application. */
  description: string;
  /** The draft application configs which haven't been updated to an application. */
  draftApplicationConfigs?: ApplicationConfigs | undefined;
}

export interface Draft_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Message describing Processor object.
 * Next ID: 19
 */
export interface Processor {
  /** name of resource. */
  name: string;
  /** Output only. [Output only] Create timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. [Output only] Update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Required. A user friendly display name for the processor. */
  displayName: string;
  /** Illustrative sentences for describing the functionality of the processor. */
  description: string;
  /** Output only. Processor Type. */
  processorType: Processor_ProcessorType;
  /** Model Type. */
  modelType: ModelType;
  /** Source info for customer created processor. */
  customProcessorSourceInfo?:
    | CustomProcessorSourceInfo
    | undefined;
  /** Output only. State of the Processor. */
  state: Processor_ProcessorState;
  /**
   * Output only. [Output only] The input / output specifications of a
   * processor, each type of processor has fixed input / output specs which
   * cannot be altered by customer.
   */
  processorIoSpec?:
    | ProcessorIOSpec
    | undefined;
  /**
   * Output only. The corresponding configuration can be used in the Application
   * to customize the behavior of the processor.
   */
  configurationTypeurl: string;
  supportedAnnotationTypes: StreamAnnotationType[];
  /** Indicates if the processor supports post processing. */
  supportsPostProcessing: boolean;
}

/** Type */
export enum Processor_ProcessorType {
  /** PROCESSOR_TYPE_UNSPECIFIED - Processor Type UNSPECIFIED. */
  PROCESSOR_TYPE_UNSPECIFIED = 0,
  /**
   * PRETRAINED - Processor Type PRETRAINED.
   * Pretrained processor is developed by Vision AI App Platform with
   * state-of-the-art vision data processing functionality, like occupancy
   * counting or person blur. Pretrained processor is usually publicly
   * available.
   */
  PRETRAINED = 1,
  /**
   * CUSTOM - Processor Type CUSTOM.
   * Custom processors are specialized processors which are either uploaded by
   * customers or imported from other GCP platform (for example Vertex AI).
   * Custom processor is only visible to the creator.
   */
  CUSTOM = 2,
  /**
   * CONNECTOR - Processor Type CONNECTOR.
   * Connector processors are special processors which perform I/O for the
   * application, they do not processing the data but either deliver the data
   * to other processors or receive data from other processors.
   */
  CONNECTOR = 3,
  UNRECOGNIZED = -1,
}

export function processor_ProcessorTypeFromJSON(object: any): Processor_ProcessorType {
  switch (object) {
    case 0:
    case "PROCESSOR_TYPE_UNSPECIFIED":
      return Processor_ProcessorType.PROCESSOR_TYPE_UNSPECIFIED;
    case 1:
    case "PRETRAINED":
      return Processor_ProcessorType.PRETRAINED;
    case 2:
    case "CUSTOM":
      return Processor_ProcessorType.CUSTOM;
    case 3:
    case "CONNECTOR":
      return Processor_ProcessorType.CONNECTOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Processor_ProcessorType.UNRECOGNIZED;
  }
}

export function processor_ProcessorTypeToJSON(object: Processor_ProcessorType): string {
  switch (object) {
    case Processor_ProcessorType.PROCESSOR_TYPE_UNSPECIFIED:
      return "PROCESSOR_TYPE_UNSPECIFIED";
    case Processor_ProcessorType.PRETRAINED:
      return "PRETRAINED";
    case Processor_ProcessorType.CUSTOM:
      return "CUSTOM";
    case Processor_ProcessorType.CONNECTOR:
      return "CONNECTOR";
    case Processor_ProcessorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Processor_ProcessorState {
  /** PROCESSOR_STATE_UNSPECIFIED - Unspecified Processor state. */
  PROCESSOR_STATE_UNSPECIFIED = 0,
  /** CREATING - Processor is being created (not ready for use). */
  CREATING = 1,
  /** ACTIVE - Processor is and ready for use. */
  ACTIVE = 2,
  /** DELETING - Processor is being deleted (not ready for use). */
  DELETING = 3,
  /** FAILED - Processor deleted or creation failed . */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function processor_ProcessorStateFromJSON(object: any): Processor_ProcessorState {
  switch (object) {
    case 0:
    case "PROCESSOR_STATE_UNSPECIFIED":
      return Processor_ProcessorState.PROCESSOR_STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Processor_ProcessorState.CREATING;
    case 2:
    case "ACTIVE":
      return Processor_ProcessorState.ACTIVE;
    case 3:
    case "DELETING":
      return Processor_ProcessorState.DELETING;
    case 4:
    case "FAILED":
      return Processor_ProcessorState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Processor_ProcessorState.UNRECOGNIZED;
  }
}

export function processor_ProcessorStateToJSON(object: Processor_ProcessorState): string {
  switch (object) {
    case Processor_ProcessorState.PROCESSOR_STATE_UNSPECIFIED:
      return "PROCESSOR_STATE_UNSPECIFIED";
    case Processor_ProcessorState.CREATING:
      return "CREATING";
    case Processor_ProcessorState.ACTIVE:
      return "ACTIVE";
    case Processor_ProcessorState.DELETING:
      return "DELETING";
    case Processor_ProcessorState.FAILED:
      return "FAILED";
    case Processor_ProcessorState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Processor_LabelsEntry {
  key: string;
  value: string;
}

/** Message describing the input / output specifications of a processor. */
export interface ProcessorIOSpec {
  /**
   * For processors with input_channel_specs, the processor must be explicitly
   * connected to another processor.
   */
  graphInputChannelSpecs: ProcessorIOSpec_GraphInputChannelSpec[];
  /** The output artifact specifications for the current processor. */
  graphOutputChannelSpecs: ProcessorIOSpec_GraphOutputChannelSpec[];
  /** The input resource that needs to be fed from the application instance. */
  instanceResourceInputBindingSpecs: ProcessorIOSpec_InstanceResourceInputBindingSpec[];
  /**
   * The output resource that the processor will generate per instance.
   * Other than the explicitly listed output bindings here, all the processors'
   * GraphOutputChannels can be binded to stream resource. The bind name then is
   * the same as the GraphOutputChannel's name.
   */
  instanceResourceOutputBindingSpecs: ProcessorIOSpec_InstanceResourceOutputBindingSpec[];
}

/** Message for input channel specification. */
export interface ProcessorIOSpec_GraphInputChannelSpec {
  /** The name of the current input channel. */
  name: string;
  /**
   * The data types of the current input channel.
   * When this field has more than 1 value, it means this input channel can be
   * connected to either of these different data types.
   */
  dataType: DataType;
  /**
   * If specified, only those detailed data types can be connected to the
   * processor. For example, jpeg stream for MEDIA, or PredictionResult proto
   * for PROTO type. If unspecified, then any proto is accepted.
   */
  acceptedDataTypeUris: string[];
  /**
   * Whether the current input channel is required by the processor.
   * For example, for a processor with required video input and optional audio
   * input, if video input is missing, the application will be rejected while
   * the audio input can be missing as long as the video input exists.
   */
  required: boolean;
  /**
   * How many input edges can be connected to this input channel. 0 means
   * unlimited.
   */
  maxConnectionAllowed: Long;
}

/** Message for output channel specification. */
export interface ProcessorIOSpec_GraphOutputChannelSpec {
  /** The name of the current output channel. */
  name: string;
  /** The data type of the current output channel. */
  dataType: DataType;
  dataTypeUri: string;
}

/**
 * Message for instance resource channel specification.
 * External resources are virtual nodes which are not expressed in the
 * application graph. Each processor expresses its out-graph spec, so customer
 * is able to override the external source or destinations to the
 */
export interface ProcessorIOSpec_InstanceResourceInputBindingSpec {
  /**
   * The configuration proto that includes the Googleapis resources. I.e.
   * type.googleapis.com/google.cloud.vision.v1.StreamWithAnnotation
   */
  configTypeUri?:
    | string
    | undefined;
  /**
   * The direct type url of Googleapis resource. i.e.
   * type.googleapis.com/google.cloud.vision.v1.Asset
   */
  resourceTypeUri?:
    | string
    | undefined;
  /** Name of the input binding, unique within the processor. */
  name: string;
}

export interface ProcessorIOSpec_InstanceResourceOutputBindingSpec {
  /** Name of the output binding, unique within the processor. */
  name: string;
  /** The resource type uri of the acceptable output resource. */
  resourceTypeUri: string;
  /**
   * Whether the output resource needs to be explicitly set in the instance.
   * If it is false, the processor will automatically generate it if required.
   */
  explicit: boolean;
}

/** Describes the source info for a custom processor. */
export interface CustomProcessorSourceInfo {
  /** The resource name original model hosted in the vertex AI platform. */
  vertexModel?:
    | string
    | undefined;
  /** The original product which holds the custom processor's functionality. */
  sourceType: CustomProcessorSourceInfo_SourceType;
  /**
   * Output only. Additional info related to the imported custom processor.
   * Data is filled in by app platform during the processor creation.
   */
  additionalInfo: { [key: string]: string };
  /**
   * Model schema files which specifies the signature of the model.
   * For VERTEX_CUSTOM models, instances schema is required.
   * If instances schema is not specified during the processor creation,
   * VisionAI Platform will try to get it from Vertex, if it doesn't exist, the
   * creation will fail.
   */
  modelSchema?: CustomProcessorSourceInfo_ModelSchema | undefined;
}

/** Source type of the imported custom processor. */
export enum CustomProcessorSourceInfo_SourceType {
  /** SOURCE_TYPE_UNSPECIFIED - Source type unspecified. */
  SOURCE_TYPE_UNSPECIFIED = 0,
  /** VERTEX_AUTOML - Custom processors coming from Vertex AutoML product. */
  VERTEX_AUTOML = 1,
  /** VERTEX_CUSTOM - Custom processors coming from general custom models from Vertex. */
  VERTEX_CUSTOM = 2,
  /** PRODUCT_RECOGNIZER - Source for Product Recognizer. */
  PRODUCT_RECOGNIZER = 3,
  UNRECOGNIZED = -1,
}

export function customProcessorSourceInfo_SourceTypeFromJSON(object: any): CustomProcessorSourceInfo_SourceType {
  switch (object) {
    case 0:
    case "SOURCE_TYPE_UNSPECIFIED":
      return CustomProcessorSourceInfo_SourceType.SOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "VERTEX_AUTOML":
      return CustomProcessorSourceInfo_SourceType.VERTEX_AUTOML;
    case 2:
    case "VERTEX_CUSTOM":
      return CustomProcessorSourceInfo_SourceType.VERTEX_CUSTOM;
    case 3:
    case "PRODUCT_RECOGNIZER":
      return CustomProcessorSourceInfo_SourceType.PRODUCT_RECOGNIZER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomProcessorSourceInfo_SourceType.UNRECOGNIZED;
  }
}

export function customProcessorSourceInfo_SourceTypeToJSON(object: CustomProcessorSourceInfo_SourceType): string {
  switch (object) {
    case CustomProcessorSourceInfo_SourceType.SOURCE_TYPE_UNSPECIFIED:
      return "SOURCE_TYPE_UNSPECIFIED";
    case CustomProcessorSourceInfo_SourceType.VERTEX_AUTOML:
      return "VERTEX_AUTOML";
    case CustomProcessorSourceInfo_SourceType.VERTEX_CUSTOM:
      return "VERTEX_CUSTOM";
    case CustomProcessorSourceInfo_SourceType.PRODUCT_RECOGNIZER:
      return "PRODUCT_RECOGNIZER";
    case CustomProcessorSourceInfo_SourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The schema is defined as an OpenAPI 3.0.2 [Schema
 * Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
 */
export interface CustomProcessorSourceInfo_ModelSchema {
  /**
   * Cloud Storage location to a YAML file that defines the format of a single
   * instance used in prediction and explanation requests.
   */
  instancesSchema?:
    | GcsSource
    | undefined;
  /**
   * Cloud Storage location to a YAML file that defines the prediction and
   * explanation parameters.
   */
  parametersSchema?:
    | GcsSource
    | undefined;
  /**
   * Cloud Storage location to a YAML file that defines the format of a single
   * prediction or explanation.
   */
  predictionsSchema?: GcsSource | undefined;
}

export interface CustomProcessorSourceInfo_AdditionalInfoEntry {
  key: string;
  value: string;
}

/** Next ID: 29 */
export interface ProcessorConfig {
  /** Configs of stream input processor. */
  videoStreamInputConfig?:
    | VideoStreamInputConfig
    | undefined;
  /** Config of AI-enabled input devices. */
  aiEnabledDevicesInputConfig?:
    | AIEnabledDevicesInputConfig
    | undefined;
  /** Configs of media warehouse processor. */
  mediaWarehouseConfig?:
    | MediaWarehouseConfig
    | undefined;
  /** Configs of person blur processor. */
  personBlurConfig?:
    | PersonBlurConfig
    | undefined;
  /** Configs of occupancy count processor. */
  occupancyCountConfig?:
    | OccupancyCountConfig
    | undefined;
  /** Configs of Person Vehicle Detection processor. */
  personVehicleDetectionConfig?:
    | PersonVehicleDetectionConfig
    | undefined;
  /** Configs of Vertex AutoML vision processor. */
  vertexAutomlVisionConfig?:
    | VertexAutoMLVisionConfig
    | undefined;
  /** Configs of Vertex AutoML video processor. */
  vertexAutomlVideoConfig?:
    | VertexAutoMLVideoConfig
    | undefined;
  /** Configs of Vertex Custom processor. */
  vertexCustomConfig?:
    | VertexCustomConfig
    | undefined;
  /** Configs of General Object Detection processor. */
  generalObjectDetectionConfig?:
    | GeneralObjectDetectionConfig
    | undefined;
  /** Configs of BigQuery processor. */
  bigQueryConfig?:
    | BigQueryConfig
    | undefined;
  /** Configs of personal_protective_equipment_detection_config */
  personalProtectiveEquipmentDetectionConfig?: PersonalProtectiveEquipmentDetectionConfig | undefined;
}

/**
 * Message describing Vision AI stream with application specific annotations.
 * All the StreamAnnotation object inside this message MUST have unique id.
 */
export interface StreamWithAnnotation {
  /** Vision AI Stream resource name. */
  stream: string;
  /** Annotations that will be applied to the whole application. */
  applicationAnnotations: StreamAnnotation[];
  /**
   * Annotations that will be applied to the specific node of the application.
   * If the same type of the annotations is applied to both application and
   * node, the node annotation will be added in addition to the global
   * application one.
   * For example, if there is one active zone annotation for the whole
   * application and one active zone annotation for the Occupancy Analytic
   * processor, then the Occupancy Analytic processor will have two active zones
   * defined.
   */
  nodeAnnotations: StreamWithAnnotation_NodeAnnotation[];
}

/** Message describing annotations specific to application node. */
export interface StreamWithAnnotation_NodeAnnotation {
  /** The node name of the application graph. */
  node: string;
  /** The node specific stream annotations. */
  annotations: StreamAnnotation[];
}

/**
 * Message describing Video Stream Input Config.
 * This message should only be used as a placeholder for builtin:stream-input
 * processor, actual stream binding should be specified using corresponding
 * API.
 */
export interface VideoStreamInputConfig {
  streams: string[];
  streamsWithAnnotation: StreamWithAnnotation[];
}

/** Message describing AI-enabled Devices Input Config. */
export interface AIEnabledDevicesInputConfig {
}

/** Message describing MediaWarehouseConfig. */
export interface MediaWarehouseConfig {
  /**
   * Resource name of the Media Warehouse corpus.
   * Format:
   * projects/${project_id}/locations/${location_id}/corpora/${corpus_id}
   */
  corpus: string;
  /** Deprecated. */
  region: string;
  /**
   * The duration for which all media assets, associated metadata, and search
   * documents can exist.
   */
  ttl?: Duration | undefined;
}

/** Message describing FaceBlurConfig. */
export interface PersonBlurConfig {
  /** Person blur type. */
  personBlurType: PersonBlurConfig_PersonBlurType;
  /** Whether only blur faces other than the whole object in the processor. */
  facesOnly: boolean;
}

/** Type of Person Blur */
export enum PersonBlurConfig_PersonBlurType {
  /** PERSON_BLUR_TYPE_UNSPECIFIED - PersonBlur Type UNSPECIFIED. */
  PERSON_BLUR_TYPE_UNSPECIFIED = 0,
  /** FULL_OCCULUSION - FaceBlur Type full occlusion. */
  FULL_OCCULUSION = 1,
  /** BLUR_FILTER - FaceBlur Type blur filter. */
  BLUR_FILTER = 2,
  UNRECOGNIZED = -1,
}

export function personBlurConfig_PersonBlurTypeFromJSON(object: any): PersonBlurConfig_PersonBlurType {
  switch (object) {
    case 0:
    case "PERSON_BLUR_TYPE_UNSPECIFIED":
      return PersonBlurConfig_PersonBlurType.PERSON_BLUR_TYPE_UNSPECIFIED;
    case 1:
    case "FULL_OCCULUSION":
      return PersonBlurConfig_PersonBlurType.FULL_OCCULUSION;
    case 2:
    case "BLUR_FILTER":
      return PersonBlurConfig_PersonBlurType.BLUR_FILTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PersonBlurConfig_PersonBlurType.UNRECOGNIZED;
  }
}

export function personBlurConfig_PersonBlurTypeToJSON(object: PersonBlurConfig_PersonBlurType): string {
  switch (object) {
    case PersonBlurConfig_PersonBlurType.PERSON_BLUR_TYPE_UNSPECIFIED:
      return "PERSON_BLUR_TYPE_UNSPECIFIED";
    case PersonBlurConfig_PersonBlurType.FULL_OCCULUSION:
      return "FULL_OCCULUSION";
    case PersonBlurConfig_PersonBlurType.BLUR_FILTER:
      return "BLUR_FILTER";
    case PersonBlurConfig_PersonBlurType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message describing OccupancyCountConfig. */
export interface OccupancyCountConfig {
  /**
   * Whether to count the appearances of people, output counts have 'people' as
   * the key.
   */
  enablePeopleCounting: boolean;
  /**
   * Whether to count the appearances of vehicles, output counts will have
   * 'vehicle' as the key.
   */
  enableVehicleCounting: boolean;
  /**
   * Whether to track each invidual object's loitering time inside the scene or
   * specific zone.
   */
  enableDwellingTimeTracking: boolean;
}

/** Message describing PersonVehicleDetectionConfig. */
export interface PersonVehicleDetectionConfig {
  /**
   * At least one of enable_people_counting and enable_vehicle_counting fields
   * must be set to true.
   * Whether to count the appearances of people, output counts have 'people' as
   * the key.
   */
  enablePeopleCounting: boolean;
  /**
   * Whether to count the appearances of vehicles, output counts will have
   * 'vehicle' as the key.
   */
  enableVehicleCounting: boolean;
}

/** Message describing PersonalProtectiveEquipmentDetectionConfig. */
export interface PersonalProtectiveEquipmentDetectionConfig {
  /** Whether to enable face coverage detection. */
  enableFaceCoverageDetection: boolean;
  /** Whether to enable head coverage detection. */
  enableHeadCoverageDetection: boolean;
  /** Whether to enable hands coverage detection. */
  enableHandsCoverageDetection: boolean;
}

/** Message of configurations for General Object Detection processor. */
export interface GeneralObjectDetectionConfig {
}

/** Message of configurations for BigQuery processor. */
export interface BigQueryConfig {
  /** BigQuery table resource for Vision AI Platform to ingest annotations to. */
  table: string;
  /**
   * Data Schema
   * By default, Vision AI Application will try to write annotations to the
   * target BigQuery table using the following schema:
   *
   * ingestion_time: TIMESTAMP, the ingestion time of the original data.
   *
   * application: STRING, name of the application which produces the annotation.
   *
   * instance: STRING, Id of the instance which produces the annotation.
   *
   * node: STRING, name of the application graph node which produces the
   * annotation.
   *
   * annotation: STRING or JSON, the actual annotation protobuf will be
   * converted to json string with bytes field as 64 encoded string. It can be
   * written to both String or Json type column.
   *
   * To forward annotation data to an existing BigQuery table, customer needs to
   * make sure the compatibility of the schema.
   * The map maps application node name to its corresponding cloud function
   * endpoint to transform the annotations directly to the
   * google.cloud.bigquery.storage.v1.AppendRowsRequest (only avro_rows or
   * proto_rows should be set). If configured, annotations produced by
   * corresponding application node will sent to the Cloud Function at first
   * before be forwarded to BigQuery.
   *
   * If the default table schema doesn't fit, customer is able to transform the
   * annotation output from Vision AI Application to arbitrary BigQuery table
   * schema with CloudFunction.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of Vision AI annotation.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * AppendRowsRequest stored in the annotations field.
   * * To drop the annotation, simply clear the annotations field in the
   * returned AppPlatformCloudFunctionResponse.
   */
  cloudFunctionMapping: { [key: string]: string };
  /**
   * If true, App Platform will create the BigQuery DataSet and the
   * BigQuery Table with default schema if the specified table doesn't exist.
   * This doesn't work if any cloud function customized schema is specified
   * since the system doesn't know your desired schema.
   * JSON column will be used in the default table created by App Platform.
   */
  createDefaultTableIfNotExists: boolean;
}

export interface BigQueryConfig_CloudFunctionMappingEntry {
  key: string;
  value: string;
}

/** Message of configurations of Vertex AutoML Vision Processors. */
export interface VertexAutoMLVisionConfig {
  /**
   * Only entities with higher score than the threshold will be returned.
   * Value 0.0 means to return all the detected entities.
   */
  confidenceThreshold: number;
  /**
   * At most this many predictions will be returned per output frame.
   * Value 0 means to return all the detected entities.
   */
  maxPredictions: number;
}

/** Message describing VertexAutoMLVideoConfig. */
export interface VertexAutoMLVideoConfig {
  /**
   * Only entities with higher score than the threshold will be returned.
   * Value 0.0 means returns all the detected entities.
   */
  confidenceThreshold: number;
  /** Labels specified in this field won't be returned. */
  blockedLabels: string[];
  /**
   * At most this many predictions will be returned per output frame.
   * Value 0 means to return all the detected entities.
   */
  maxPredictions: number;
  /**
   * Only Bounding Box whose size is larger than this limit will be returned.
   * Object Tracking only.
   * Value 0.0 means to return all the detected entities.
   */
  boundingBoxSizeLimit: number;
}

/** Message describing VertexCustomConfig. */
export interface VertexCustomConfig {
  /**
   * The max prediction frame per second. This attribute sets how fast the
   * operator sends prediction requests to Vertex AI endpoint. Default value is
   * 0, which means there is no max prediction fps limit. The operator sends
   * prediction requests at input fps.
   */
  maxPredictionFps: number;
  /**
   * A description of resources that are dedicated to the DeployedModel, and
   * that need a higher degree of manual configuration.
   */
  dedicatedResources?:
    | DedicatedResources
    | undefined;
  /**
   * If not empty, the prediction result will be sent to the specified cloud
   * function for post processing.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of proto PredictResponse.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * PredictResponse stored in the annotations field.
   * * To drop the prediction output, simply clear the payload field in the
   * returned AppPlatformCloudFunctionResponse.
   */
  postProcessingCloudFunction: string;
  /**
   * If true, the prediction request received by custom model will also contain
   * metadata with the following schema:
   * 'appPlatformMetadata': {
   *       'ingestionTime': DOUBLE; (UNIX timestamp)
   *       'application': STRING;
   *       'instanceId': STRING;
   *       'node': STRING;
   *       'processor': STRING;
   *  }
   */
  attachApplicationMetadata: boolean;
}

/** Specification of a single machine. */
export interface MachineSpec {
  /**
   * Immutable. The type of the machine.
   *
   * See the [list of machine types supported for
   * prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
   *
   * See the [list of machine types supported for custom
   * training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
   *
   * For [DeployedModel][] this field is optional, and the default
   * value is `n1-standard-2`. For [BatchPredictionJob][] or as part of
   * [WorkerPoolSpec][] this field is required.
   */
  machineType: string;
  /**
   * Immutable. The type of accelerator(s) that may be attached to the machine
   * as per
   * [accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count].
   */
  acceleratorType: AcceleratorType;
  /** The number of accelerators to attach to the machine. */
  acceleratorCount: number;
}

/**
 * The metric specification that defines the target resource utilization
 * (CPU utilization, accelerator's duty cycle, and so on) for calculating the
 * desired replica count.
 */
export interface AutoscalingMetricSpec {
  /**
   * Required. The resource metric name.
   * Supported metrics:
   *
   * * For Online Prediction:
   * * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle`
   * * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
   */
  metricName: string;
  /**
   * The target resource utilization in percentage (1% - 100%) for the given
   * metric; once the real usage deviates from the target by a certain
   * percentage, the machine replicas change. The default value is 60
   * (representing 60%) if not provided.
   */
  target: number;
}

/**
 * A description of resources that are dedicated to a DeployedModel, and
 * that need a higher degree of manual configuration.
 */
export interface DedicatedResources {
  /**
   * Required. Immutable. The specification of a single machine used by the
   * prediction.
   */
  machineSpec?:
    | MachineSpec
    | undefined;
  /**
   * Required. Immutable. The minimum number of machine replicas this
   * DeployedModel will be always deployed on. This value must be greater than
   * or equal to 1.
   *
   * If traffic against the DeployedModel increases, it may dynamically be
   * deployed onto more replicas, and as traffic decreases, some of these extra
   * replicas may be freed.
   */
  minReplicaCount: number;
  /**
   * Immutable. The maximum number of replicas this DeployedModel may be
   * deployed on when the traffic against it increases. If the requested value
   * is too large, the deployment will error, but if deployment succeeds then
   * the ability to scale the model to that many replicas is guaranteed (barring
   * service outages). If traffic against the DeployedModel increases beyond
   * what its replicas at maximum may handle, a portion of the traffic will be
   * dropped. If this value is not provided, will use
   * [min_replica_count][google.cloud.visionai.v1.DedicatedResources.min_replica_count]
   * as the default value.
   *
   * The value of this field impacts the charge against Vertex CPU and GPU
   * quotas. Specifically, you will be charged for max_replica_count *
   * number of cores in the selected machine type) and (max_replica_count *
   * number of GPUs per replica in the selected machine type).
   */
  maxReplicaCount: number;
  /**
   * Immutable. The metric specifications that overrides a resource
   * utilization metric (CPU utilization, accelerator's duty cycle, and so on)
   * target value (default to 60 if not set). At most one entry is allowed per
   * metric.
   *
   * If
   * [machine_spec.accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count]
   * is above 0, the autoscaling will be based on both CPU utilization and
   * accelerator's duty cycle metrics and scale up when either metrics exceeds
   * its target value while scale down if both metrics are under their target
   * value. The default target value is 60 for both metrics.
   *
   * If
   * [machine_spec.accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count]
   * is 0, the autoscaling will be based on CPU utilization metric only with
   * default target value 60 if not explicitly set.
   *
   * For example, in the case of Online Prediction, if you want to override
   * target CPU utilization to 80, you should set
   * [autoscaling_metric_specs.metric_name][google.cloud.visionai.v1.AutoscalingMetricSpec.metric_name]
   * to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
   * [autoscaling_metric_specs.target][google.cloud.visionai.v1.AutoscalingMetricSpec.target]
   * to `80`.
   */
  autoscalingMetricSpecs: AutoscalingMetricSpec[];
}

/**
 * Message describing the Stream object. The Stream and the Event resources are
 * many to many; i.e., each Stream resource can associate to many Event
 * resources and each Event resource can associate to many Stream resources.
 */
export interface Stream {
  /** Name of the resource. */
  name: string;
  /** Output only. The create timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Annotations to allow clients to store small amounts of arbitrary data. */
  annotations: { [key: string]: string };
  /** The display name for the stream resource. */
  displayName: string;
  /** Whether to enable the HLS playback service on this stream. */
  enableHlsPlayback: boolean;
  /**
   * The name of the media warehouse asset for long term storage of stream data.
   * Format: projects/${p_id}/locations/${l_id}/corpora/${c_id}/assets/${a_id}
   * Remain empty if the media warehouse storage is not needed for the stream.
   */
  mediaWarehouseAsset: string;
}

export interface Stream_LabelsEntry {
  key: string;
  value: string;
}

export interface Stream_AnnotationsEntry {
  key: string;
  value: string;
}

/** Message describing the Event object. */
export interface Event {
  /** Name of the resource. */
  name: string;
  /** Output only. The create timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Annotations to allow clients to store small amounts of arbitrary data. */
  annotations: { [key: string]: string };
  /** The clock used for joining streams. */
  alignmentClock: Event_Clock;
  /**
   * Grace period for cleaning up the event. This is the time the controller
   * waits for before deleting the event. During this period, if there is any
   * active channel on the event. The deletion of the event after grace_period
   * will be ignored.
   */
  gracePeriod?: Duration | undefined;
}

/** Clock that will be used for joining streams. */
export enum Event_Clock {
  /** CLOCK_UNSPECIFIED - Clock is not specified. */
  CLOCK_UNSPECIFIED = 0,
  /**
   * CAPTURE - Use the timestamp when the data is captured. Clients need to sync the
   * clock.
   */
  CAPTURE = 1,
  /** INGEST - Use the timestamp when the data is received. */
  INGEST = 2,
  UNRECOGNIZED = -1,
}

export function event_ClockFromJSON(object: any): Event_Clock {
  switch (object) {
    case 0:
    case "CLOCK_UNSPECIFIED":
      return Event_Clock.CLOCK_UNSPECIFIED;
    case 1:
    case "CAPTURE":
      return Event_Clock.CAPTURE;
    case 2:
    case "INGEST":
      return Event_Clock.INGEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_Clock.UNRECOGNIZED;
  }
}

export function event_ClockToJSON(object: Event_Clock): string {
  switch (object) {
    case Event_Clock.CLOCK_UNSPECIFIED:
      return "CLOCK_UNSPECIFIED";
    case Event_Clock.CAPTURE:
      return "CAPTURE";
    case Event_Clock.INGEST:
      return "INGEST";
    case Event_Clock.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Event_LabelsEntry {
  key: string;
  value: string;
}

export interface Event_AnnotationsEntry {
  key: string;
  value: string;
}

/** Message describing the Series object. */
export interface Series {
  /** Name of the resource. */
  name: string;
  /** Output only. The create timestamp. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The update timestamp. */
  updateTime?:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Annotations to allow clients to store small amounts of arbitrary data. */
  annotations: { [key: string]: string };
  /** Required. Stream that is associated with this series. */
  stream: string;
  /** Required. Event that is associated with this series. */
  event: string;
}

export interface Series_LabelsEntry {
  key: string;
  value: string;
}

export interface Series_AnnotationsEntry {
  key: string;
  value: string;
}

/** The data within all Series events. */
export interface SeriesEventData {
  /** Optional. The Series event payload. Unset for deletion events. */
  payload?: Series | undefined;
}

/** The data within all Draft events. */
export interface DraftEventData {
  /** Optional. The Draft event payload. Unset for deletion events. */
  payload?: Draft | undefined;
}

/** The data within all Processor events. */
export interface ProcessorEventData {
  /** Optional. The Processor event payload. Unset for deletion events. */
  payload?: Processor | undefined;
}

/** The data within all Analysis events. */
export interface AnalysisEventData {
  /** Optional. The Analysis event payload. Unset for deletion events. */
  payload?: Analysis | undefined;
}

/** The data within all Cluster events. */
export interface ClusterEventData {
  /** Optional. The Cluster event payload. Unset for deletion events. */
  payload?: Cluster | undefined;
}

/** The data within all Event events. */
export interface EventEventData {
  /** Optional. The Event event payload. Unset for deletion events. */
  payload?: Event | undefined;
}

/** The data within all Process events. */
export interface ProcessEventData {
  /** Optional. The Process event payload. Unset for deletion events. */
  payload?: Process | undefined;
}

/** The data within all Stream events. */
export interface StreamEventData {
  /** Optional. The Stream event payload. Unset for deletion events. */
  payload?: Stream | undefined;
}

/** The data within all Application events. */
export interface ApplicationEventData {
  /** Optional. The Application event payload. Unset for deletion events. */
  payload?: Application | undefined;
}

function createBaseStreamAnnotation(): StreamAnnotation {
  return { activeZone: undefined, crossingLine: undefined, id: "", displayName: "", sourceStream: "", type: 0 };
}

export const StreamAnnotation: MessageFns<StreamAnnotation> = {
  encode(message: StreamAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeZone !== undefined) {
      NormalizedPolygon.encode(message.activeZone, writer.uint32(42).fork()).join();
    }
    if (message.crossingLine !== undefined) {
      NormalizedPolyline.encode(message.crossingLine, writer.uint32(50).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.sourceStream !== "") {
      writer.uint32(26).string(message.sourceStream);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.activeZone = NormalizedPolygon.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.crossingLine = NormalizedPolyline.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceStream = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamAnnotation {
    return {
      activeZone: isSet(object.activeZone) ? NormalizedPolygon.fromJSON(object.activeZone) : undefined,
      crossingLine: isSet(object.crossingLine) ? NormalizedPolyline.fromJSON(object.crossingLine) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      sourceStream: isSet(object.sourceStream) ? globalThis.String(object.sourceStream) : "",
      type: isSet(object.type) ? streamAnnotationTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: StreamAnnotation): unknown {
    const obj: any = {};
    if (message.activeZone !== undefined) {
      obj.activeZone = NormalizedPolygon.toJSON(message.activeZone);
    }
    if (message.crossingLine !== undefined) {
      obj.crossingLine = NormalizedPolyline.toJSON(message.crossingLine);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.sourceStream !== "") {
      obj.sourceStream = message.sourceStream;
    }
    if (message.type !== 0) {
      obj.type = streamAnnotationTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamAnnotation>, I>>(base?: I): StreamAnnotation {
    return StreamAnnotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamAnnotation>, I>>(object: I): StreamAnnotation {
    const message = createBaseStreamAnnotation();
    message.activeZone = (object.activeZone !== undefined && object.activeZone !== null)
      ? NormalizedPolygon.fromPartial(object.activeZone)
      : undefined;
    message.crossingLine = (object.crossingLine !== undefined && object.crossingLine !== null)
      ? NormalizedPolyline.fromPartial(object.crossingLine)
      : undefined;
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.sourceStream = object.sourceStream ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseNormalizedPolygon(): NormalizedPolygon {
  return { normalizedVertices: [] };
}

export const NormalizedPolygon: MessageFns<NormalizedPolygon> = {
  encode(message: NormalizedPolygon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.normalizedVertices) {
      NormalizedVertex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedPolygon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedPolygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.normalizedVertices.push(NormalizedVertex.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedPolygon {
    return {
      normalizedVertices: globalThis.Array.isArray(object?.normalizedVertices)
        ? object.normalizedVertices.map((e: any) => NormalizedVertex.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NormalizedPolygon): unknown {
    const obj: any = {};
    if (message.normalizedVertices?.length) {
      obj.normalizedVertices = message.normalizedVertices.map((e) => NormalizedVertex.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NormalizedPolygon>, I>>(base?: I): NormalizedPolygon {
    return NormalizedPolygon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NormalizedPolygon>, I>>(object: I): NormalizedPolygon {
    const message = createBaseNormalizedPolygon();
    message.normalizedVertices = object.normalizedVertices?.map((e) => NormalizedVertex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNormalizedPolyline(): NormalizedPolyline {
  return { normalizedVertices: [] };
}

export const NormalizedPolyline: MessageFns<NormalizedPolyline> = {
  encode(message: NormalizedPolyline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.normalizedVertices) {
      NormalizedVertex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedPolyline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedPolyline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.normalizedVertices.push(NormalizedVertex.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedPolyline {
    return {
      normalizedVertices: globalThis.Array.isArray(object?.normalizedVertices)
        ? object.normalizedVertices.map((e: any) => NormalizedVertex.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NormalizedPolyline): unknown {
    const obj: any = {};
    if (message.normalizedVertices?.length) {
      obj.normalizedVertices = message.normalizedVertices.map((e) => NormalizedVertex.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NormalizedPolyline>, I>>(base?: I): NormalizedPolyline {
    return NormalizedPolyline.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NormalizedPolyline>, I>>(object: I): NormalizedPolyline {
    const message = createBaseNormalizedPolyline();
    message.normalizedVertices = object.normalizedVertices?.map((e) => NormalizedVertex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNormalizedVertex(): NormalizedVertex {
  return { x: 0, y: 0 };
}

export const NormalizedVertex: MessageFns<NormalizedVertex> = {
  encode(message: NormalizedVertex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedVertex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedVertex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedVertex {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: NormalizedVertex): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NormalizedVertex>, I>>(base?: I): NormalizedVertex {
    return NormalizedVertex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NormalizedVertex>, I>>(object: I): NormalizedVertex {
    const message = createBaseNormalizedVertex();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseCluster(): Cluster {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    annotations: {},
    dataplaneServiceEndpoint: "",
    state: 0,
    pscTarget: "",
  };
}

export const Cluster: MessageFns<Cluster> = {
  encode(message: Cluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Cluster_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      Cluster_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.dataplaneServiceEndpoint !== "") {
      writer.uint32(50).string(message.dataplaneServiceEndpoint);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.pscTarget !== "") {
      writer.uint32(66).string(message.pscTarget);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Cluster_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = Cluster_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dataplaneServiceEndpoint = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pscTarget = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      dataplaneServiceEndpoint: isSet(object.dataplaneServiceEndpoint)
        ? globalThis.String(object.dataplaneServiceEndpoint)
        : "",
      state: isSet(object.state) ? cluster_StateFromJSON(object.state) : 0,
      pscTarget: isSet(object.pscTarget) ? globalThis.String(object.pscTarget) : "",
    };
  },

  toJSON(message: Cluster): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.dataplaneServiceEndpoint !== "") {
      obj.dataplaneServiceEndpoint = message.dataplaneServiceEndpoint;
    }
    if (message.state !== 0) {
      obj.state = cluster_StateToJSON(message.state);
    }
    if (message.pscTarget !== "") {
      obj.pscTarget = message.pscTarget;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster>, I>>(base?: I): Cluster {
    return Cluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster>, I>>(object: I): Cluster {
    const message = createBaseCluster();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.dataplaneServiceEndpoint = object.dataplaneServiceEndpoint ?? "";
    message.state = object.state ?? 0;
    message.pscTarget = object.pscTarget ?? "";
    return message;
  },
};

function createBaseCluster_LabelsEntry(): Cluster_LabelsEntry {
  return { key: "", value: "" };
}

export const Cluster_LabelsEntry: MessageFns<Cluster_LabelsEntry> = {
  encode(message: Cluster_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Cluster_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_LabelsEntry>, I>>(base?: I): Cluster_LabelsEntry {
    return Cluster_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_LabelsEntry>, I>>(object: I): Cluster_LabelsEntry {
    const message = createBaseCluster_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCluster_AnnotationsEntry(): Cluster_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Cluster_AnnotationsEntry: MessageFns<Cluster_AnnotationsEntry> = {
  encode(message: Cluster_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Cluster_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_AnnotationsEntry>, I>>(base?: I): Cluster_AnnotationsEntry {
    return Cluster_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_AnnotationsEntry>, I>>(object: I): Cluster_AnnotationsEntry {
    const message = createBaseCluster_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGcsSource(): GcsSource {
  return { uris: [] };
}

export const GcsSource: MessageFns<GcsSource> = {
  encode(message: GcsSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.uris) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uris.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsSource {
    return { uris: globalThis.Array.isArray(object?.uris) ? object.uris.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: GcsSource): unknown {
    const obj: any = {};
    if (message.uris?.length) {
      obj.uris = message.uris;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GcsSource>, I>>(base?: I): GcsSource {
    return GcsSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GcsSource>, I>>(object: I): GcsSource {
    const message = createBaseGcsSource();
    message.uris = object.uris?.map((e) => e) || [];
    return message;
  },
};

function createBaseAttributeValue(): AttributeValue {
  return { i: undefined, f: undefined, b: undefined, s: undefined };
}

export const AttributeValue: MessageFns<AttributeValue> = {
  encode(message: AttributeValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.i !== undefined) {
      writer.uint32(8).int64(message.i.toString());
    }
    if (message.f !== undefined) {
      writer.uint32(21).float(message.f);
    }
    if (message.b !== undefined) {
      writer.uint32(24).bool(message.b);
    }
    if (message.s !== undefined) {
      writer.uint32(34).bytes(message.s);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.i = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.f = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.b = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.s = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValue {
    return {
      i: isSet(object.i) ? Long.fromValue(object.i) : undefined,
      f: isSet(object.f) ? globalThis.Number(object.f) : undefined,
      b: isSet(object.b) ? globalThis.Boolean(object.b) : undefined,
      s: isSet(object.s) ? bytesFromBase64(object.s) : undefined,
    };
  },

  toJSON(message: AttributeValue): unknown {
    const obj: any = {};
    if (message.i !== undefined) {
      obj.i = (message.i || Long.ZERO).toString();
    }
    if (message.f !== undefined) {
      obj.f = message.f;
    }
    if (message.b !== undefined) {
      obj.b = message.b;
    }
    if (message.s !== undefined) {
      obj.s = base64FromBytes(message.s);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeValue>, I>>(base?: I): AttributeValue {
    return AttributeValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeValue>, I>>(object: I): AttributeValue {
    const message = createBaseAttributeValue();
    message.i = (object.i !== undefined && object.i !== null) ? Long.fromValue(object.i) : undefined;
    message.f = object.f ?? undefined;
    message.b = object.b ?? undefined;
    message.s = object.s ?? undefined;
    return message;
  },
};

function createBaseAnalyzerDefinition(): AnalyzerDefinition {
  return { analyzer: "", operator: "", inputs: [], attrs: {}, debugOptions: undefined };
}

export const AnalyzerDefinition: MessageFns<AnalyzerDefinition> = {
  encode(message: AnalyzerDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.analyzer !== "") {
      writer.uint32(10).string(message.analyzer);
    }
    if (message.operator !== "") {
      writer.uint32(18).string(message.operator);
    }
    for (const v of message.inputs) {
      AnalyzerDefinition_StreamInput.encode(v!, writer.uint32(26).fork()).join();
    }
    Object.entries(message.attrs).forEach(([key, value]) => {
      AnalyzerDefinition_AttrsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.debugOptions !== undefined) {
      AnalyzerDefinition_DebugOptions.encode(message.debugOptions, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.analyzer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputs.push(AnalyzerDefinition_StreamInput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = AnalyzerDefinition_AttrsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.attrs[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.debugOptions = AnalyzerDefinition_DebugOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition {
    return {
      analyzer: isSet(object.analyzer) ? globalThis.String(object.analyzer) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => AnalyzerDefinition_StreamInput.fromJSON(e))
        : [],
      attrs: isObject(object.attrs)
        ? Object.entries(object.attrs).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      debugOptions: isSet(object.debugOptions)
        ? AnalyzerDefinition_DebugOptions.fromJSON(object.debugOptions)
        : undefined,
    };
  },

  toJSON(message: AnalyzerDefinition): unknown {
    const obj: any = {};
    if (message.analyzer !== "") {
      obj.analyzer = message.analyzer;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => AnalyzerDefinition_StreamInput.toJSON(e));
    }
    if (message.attrs) {
      const entries = Object.entries(message.attrs);
      if (entries.length > 0) {
        obj.attrs = {};
        entries.forEach(([k, v]) => {
          obj.attrs[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.debugOptions !== undefined) {
      obj.debugOptions = AnalyzerDefinition_DebugOptions.toJSON(message.debugOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzerDefinition>, I>>(base?: I): AnalyzerDefinition {
    return AnalyzerDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzerDefinition>, I>>(object: I): AnalyzerDefinition {
    const message = createBaseAnalyzerDefinition();
    message.analyzer = object.analyzer ?? "";
    message.operator = object.operator ?? "";
    message.inputs = object.inputs?.map((e) => AnalyzerDefinition_StreamInput.fromPartial(e)) || [];
    message.attrs = Object.entries(object.attrs ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.debugOptions = (object.debugOptions !== undefined && object.debugOptions !== null)
      ? AnalyzerDefinition_DebugOptions.fromPartial(object.debugOptions)
      : undefined;
    return message;
  },
};

function createBaseAnalyzerDefinition_StreamInput(): AnalyzerDefinition_StreamInput {
  return { input: "" };
}

export const AnalyzerDefinition_StreamInput: MessageFns<AnalyzerDefinition_StreamInput> = {
  encode(message: AnalyzerDefinition_StreamInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== "") {
      writer.uint32(10).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_StreamInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_StreamInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_StreamInput {
    return { input: isSet(object.input) ? globalThis.String(object.input) : "" };
  },

  toJSON(message: AnalyzerDefinition_StreamInput): unknown {
    const obj: any = {};
    if (message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzerDefinition_StreamInput>, I>>(base?: I): AnalyzerDefinition_StreamInput {
    return AnalyzerDefinition_StreamInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzerDefinition_StreamInput>, I>>(
    object: I,
  ): AnalyzerDefinition_StreamInput {
    const message = createBaseAnalyzerDefinition_StreamInput();
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseAnalyzerDefinition_DebugOptions(): AnalyzerDefinition_DebugOptions {
  return { environmentVariables: {} };
}

export const AnalyzerDefinition_DebugOptions: MessageFns<AnalyzerDefinition_DebugOptions> = {
  encode(message: AnalyzerDefinition_DebugOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.environmentVariables).forEach(([key, value]) => {
      AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_DebugOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_DebugOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.environmentVariables[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_DebugOptions {
    return {
      environmentVariables: isObject(object.environmentVariables)
        ? Object.entries(object.environmentVariables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AnalyzerDefinition_DebugOptions): unknown {
    const obj: any = {};
    if (message.environmentVariables) {
      const entries = Object.entries(message.environmentVariables);
      if (entries.length > 0) {
        obj.environmentVariables = {};
        entries.forEach(([k, v]) => {
          obj.environmentVariables[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzerDefinition_DebugOptions>, I>>(base?: I): AnalyzerDefinition_DebugOptions {
    return AnalyzerDefinition_DebugOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzerDefinition_DebugOptions>, I>>(
    object: I,
  ): AnalyzerDefinition_DebugOptions {
    const message = createBaseAnalyzerDefinition_DebugOptions();
    message.environmentVariables = Object.entries(object.environmentVariables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry(): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
  return { key: "", value: "" };
}

export const AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry: MessageFns<
  AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry
> = {
  encode(
    message: AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry>, I>>(
    base?: I,
  ): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    return AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry>, I>>(
    object: I,
  ): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    const message = createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnalyzerDefinition_AttrsEntry(): AnalyzerDefinition_AttrsEntry {
  return { key: "", value: undefined };
}

export const AnalyzerDefinition_AttrsEntry: MessageFns<AnalyzerDefinition_AttrsEntry> = {
  encode(message: AnalyzerDefinition_AttrsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_AttrsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_AttrsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_AttrsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AnalyzerDefinition_AttrsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzerDefinition_AttrsEntry>, I>>(base?: I): AnalyzerDefinition_AttrsEntry {
    return AnalyzerDefinition_AttrsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzerDefinition_AttrsEntry>, I>>(
    object: I,
  ): AnalyzerDefinition_AttrsEntry {
    const message = createBaseAnalyzerDefinition_AttrsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAnalysisDefinition(): AnalysisDefinition {
  return { analyzers: [] };
}

export const AnalysisDefinition: MessageFns<AnalysisDefinition> = {
  encode(message: AnalysisDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.analyzers) {
      AnalyzerDefinition.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.analyzers.push(AnalyzerDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisDefinition {
    return {
      analyzers: globalThis.Array.isArray(object?.analyzers)
        ? object.analyzers.map((e: any) => AnalyzerDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnalysisDefinition): unknown {
    const obj: any = {};
    if (message.analyzers?.length) {
      obj.analyzers = message.analyzers.map((e) => AnalyzerDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalysisDefinition>, I>>(base?: I): AnalysisDefinition {
    return AnalysisDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalysisDefinition>, I>>(object: I): AnalysisDefinition {
    const message = createBaseAnalysisDefinition();
    message.analyzers = object.analyzers?.map((e) => AnalyzerDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunStatus(): RunStatus {
  return { state: 0, reason: "" };
}

export const RunStatus: MessageFns<RunStatus> = {
  encode(message: RunStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunStatus {
    return {
      state: isSet(object.state) ? runStatus_StateFromJSON(object.state) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: RunStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = runStatus_StateToJSON(message.state);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunStatus>, I>>(base?: I): RunStatus {
    return RunStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunStatus>, I>>(object: I): RunStatus {
    const message = createBaseRunStatus();
    message.state = object.state ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseAnalysis(): Analysis {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    analysisDefinition: undefined,
    inputStreamsMapping: {},
    outputStreamsMapping: {},
    disableEventWatch: false,
  };
}

export const Analysis: MessageFns<Analysis> = {
  encode(message: Analysis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Analysis_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.analysisDefinition !== undefined) {
      AnalysisDefinition.encode(message.analysisDefinition, writer.uint32(42).fork()).join();
    }
    Object.entries(message.inputStreamsMapping).forEach(([key, value]) => {
      Analysis_InputStreamsMappingEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.outputStreamsMapping).forEach(([key, value]) => {
      Analysis_OutputStreamsMappingEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.disableEventWatch !== false) {
      writer.uint32(64).bool(message.disableEventWatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Analysis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Analysis_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.analysisDefinition = AnalysisDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = Analysis_InputStreamsMappingEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.inputStreamsMapping[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Analysis_OutputStreamsMappingEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.outputStreamsMapping[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.disableEventWatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Analysis {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      analysisDefinition: isSet(object.analysisDefinition)
        ? AnalysisDefinition.fromJSON(object.analysisDefinition)
        : undefined,
      inputStreamsMapping: isObject(object.inputStreamsMapping)
        ? Object.entries(object.inputStreamsMapping).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      outputStreamsMapping: isObject(object.outputStreamsMapping)
        ? Object.entries(object.outputStreamsMapping).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      disableEventWatch: isSet(object.disableEventWatch) ? globalThis.Boolean(object.disableEventWatch) : false,
    };
  },

  toJSON(message: Analysis): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.analysisDefinition !== undefined) {
      obj.analysisDefinition = AnalysisDefinition.toJSON(message.analysisDefinition);
    }
    if (message.inputStreamsMapping) {
      const entries = Object.entries(message.inputStreamsMapping);
      if (entries.length > 0) {
        obj.inputStreamsMapping = {};
        entries.forEach(([k, v]) => {
          obj.inputStreamsMapping[k] = v;
        });
      }
    }
    if (message.outputStreamsMapping) {
      const entries = Object.entries(message.outputStreamsMapping);
      if (entries.length > 0) {
        obj.outputStreamsMapping = {};
        entries.forEach(([k, v]) => {
          obj.outputStreamsMapping[k] = v;
        });
      }
    }
    if (message.disableEventWatch !== false) {
      obj.disableEventWatch = message.disableEventWatch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Analysis>, I>>(base?: I): Analysis {
    return Analysis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Analysis>, I>>(object: I): Analysis {
    const message = createBaseAnalysis();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.analysisDefinition = (object.analysisDefinition !== undefined && object.analysisDefinition !== null)
      ? AnalysisDefinition.fromPartial(object.analysisDefinition)
      : undefined;
    message.inputStreamsMapping = Object.entries(object.inputStreamsMapping ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.outputStreamsMapping = Object.entries(object.outputStreamsMapping ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.disableEventWatch = object.disableEventWatch ?? false;
    return message;
  },
};

function createBaseAnalysis_LabelsEntry(): Analysis_LabelsEntry {
  return { key: "", value: "" };
}

export const Analysis_LabelsEntry: MessageFns<Analysis_LabelsEntry> = {
  encode(message: Analysis_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Analysis_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysis_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Analysis_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Analysis_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Analysis_LabelsEntry>, I>>(base?: I): Analysis_LabelsEntry {
    return Analysis_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Analysis_LabelsEntry>, I>>(object: I): Analysis_LabelsEntry {
    const message = createBaseAnalysis_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnalysis_InputStreamsMappingEntry(): Analysis_InputStreamsMappingEntry {
  return { key: "", value: "" };
}

export const Analysis_InputStreamsMappingEntry: MessageFns<Analysis_InputStreamsMappingEntry> = {
  encode(message: Analysis_InputStreamsMappingEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Analysis_InputStreamsMappingEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysis_InputStreamsMappingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Analysis_InputStreamsMappingEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Analysis_InputStreamsMappingEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Analysis_InputStreamsMappingEntry>, I>>(
    base?: I,
  ): Analysis_InputStreamsMappingEntry {
    return Analysis_InputStreamsMappingEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Analysis_InputStreamsMappingEntry>, I>>(
    object: I,
  ): Analysis_InputStreamsMappingEntry {
    const message = createBaseAnalysis_InputStreamsMappingEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnalysis_OutputStreamsMappingEntry(): Analysis_OutputStreamsMappingEntry {
  return { key: "", value: "" };
}

export const Analysis_OutputStreamsMappingEntry: MessageFns<Analysis_OutputStreamsMappingEntry> = {
  encode(message: Analysis_OutputStreamsMappingEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Analysis_OutputStreamsMappingEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysis_OutputStreamsMappingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Analysis_OutputStreamsMappingEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Analysis_OutputStreamsMappingEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Analysis_OutputStreamsMappingEntry>, I>>(
    base?: I,
  ): Analysis_OutputStreamsMappingEntry {
    return Analysis_OutputStreamsMappingEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Analysis_OutputStreamsMappingEntry>, I>>(
    object: I,
  ): Analysis_OutputStreamsMappingEntry {
    const message = createBaseAnalysis_OutputStreamsMappingEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProcess(): Process {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    analysis: "",
    attributeOverrides: [],
    runStatus: undefined,
    runMode: 0,
    eventId: "",
    batchId: "",
    retryCount: 0,
  };
}

export const Process: MessageFns<Process> = {
  encode(message: Process, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.analysis !== "") {
      writer.uint32(34).string(message.analysis);
    }
    for (const v of message.attributeOverrides) {
      writer.uint32(42).string(v!);
    }
    if (message.runStatus !== undefined) {
      RunStatus.encode(message.runStatus, writer.uint32(50).fork()).join();
    }
    if (message.runMode !== 0) {
      writer.uint32(56).int32(message.runMode);
    }
    if (message.eventId !== "") {
      writer.uint32(66).string(message.eventId);
    }
    if (message.batchId !== "") {
      writer.uint32(74).string(message.batchId);
    }
    if (message.retryCount !== 0) {
      writer.uint32(80).int32(message.retryCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Process {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.analysis = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.attributeOverrides.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.runStatus = RunStatus.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.runMode = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.batchId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Process {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      analysis: isSet(object.analysis) ? globalThis.String(object.analysis) : "",
      attributeOverrides: globalThis.Array.isArray(object?.attributeOverrides)
        ? object.attributeOverrides.map((e: any) => globalThis.String(e))
        : [],
      runStatus: isSet(object.runStatus) ? RunStatus.fromJSON(object.runStatus) : undefined,
      runMode: isSet(object.runMode) ? runModeFromJSON(object.runMode) : 0,
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      batchId: isSet(object.batchId) ? globalThis.String(object.batchId) : "",
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
    };
  },

  toJSON(message: Process): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.analysis !== "") {
      obj.analysis = message.analysis;
    }
    if (message.attributeOverrides?.length) {
      obj.attributeOverrides = message.attributeOverrides;
    }
    if (message.runStatus !== undefined) {
      obj.runStatus = RunStatus.toJSON(message.runStatus);
    }
    if (message.runMode !== 0) {
      obj.runMode = runModeToJSON(message.runMode);
    }
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.batchId !== "") {
      obj.batchId = message.batchId;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Process>, I>>(base?: I): Process {
    return Process.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Process>, I>>(object: I): Process {
    const message = createBaseProcess();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.analysis = object.analysis ?? "";
    message.attributeOverrides = object.attributeOverrides?.map((e) => e) || [];
    message.runStatus = (object.runStatus !== undefined && object.runStatus !== null)
      ? RunStatus.fromPartial(object.runStatus)
      : undefined;
    message.runMode = object.runMode ?? 0;
    message.eventId = object.eventId ?? "";
    message.batchId = object.batchId ?? "";
    message.retryCount = object.retryCount ?? 0;
    return message;
  },
};

function createBaseApplication(): Application {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    description: "",
    applicationConfigs: undefined,
    runtimeInfo: undefined,
    state: 0,
    billingMode: 0,
  };
}

export const Application: MessageFns<Application> = {
  encode(message: Application, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Application_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.applicationConfigs !== undefined) {
      ApplicationConfigs.encode(message.applicationConfigs, writer.uint32(58).fork()).join();
    }
    if (message.runtimeInfo !== undefined) {
      Application_ApplicationRuntimeInfo.encode(message.runtimeInfo, writer.uint32(66).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    if (message.billingMode !== 0) {
      writer.uint32(96).int32(message.billingMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Application_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.applicationConfigs = ApplicationConfigs.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.runtimeInfo = Application_ApplicationRuntimeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.billingMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      applicationConfigs: isSet(object.applicationConfigs)
        ? ApplicationConfigs.fromJSON(object.applicationConfigs)
        : undefined,
      runtimeInfo: isSet(object.runtimeInfo)
        ? Application_ApplicationRuntimeInfo.fromJSON(object.runtimeInfo)
        : undefined,
      state: isSet(object.state) ? application_StateFromJSON(object.state) : 0,
      billingMode: isSet(object.billingMode) ? application_BillingModeFromJSON(object.billingMode) : 0,
    };
  },

  toJSON(message: Application): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.applicationConfigs !== undefined) {
      obj.applicationConfigs = ApplicationConfigs.toJSON(message.applicationConfigs);
    }
    if (message.runtimeInfo !== undefined) {
      obj.runtimeInfo = Application_ApplicationRuntimeInfo.toJSON(message.runtimeInfo);
    }
    if (message.state !== 0) {
      obj.state = application_StateToJSON(message.state);
    }
    if (message.billingMode !== 0) {
      obj.billingMode = application_BillingModeToJSON(message.billingMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Application>, I>>(base?: I): Application {
    return Application.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Application>, I>>(object: I): Application {
    const message = createBaseApplication();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.applicationConfigs = (object.applicationConfigs !== undefined && object.applicationConfigs !== null)
      ? ApplicationConfigs.fromPartial(object.applicationConfigs)
      : undefined;
    message.runtimeInfo = (object.runtimeInfo !== undefined && object.runtimeInfo !== null)
      ? Application_ApplicationRuntimeInfo.fromPartial(object.runtimeInfo)
      : undefined;
    message.state = object.state ?? 0;
    message.billingMode = object.billingMode ?? 0;
    return message;
  },
};

function createBaseApplication_ApplicationRuntimeInfo(): Application_ApplicationRuntimeInfo {
  return { deployTime: undefined, globalOutputResources: [], monitoringConfig: undefined };
}

export const Application_ApplicationRuntimeInfo: MessageFns<Application_ApplicationRuntimeInfo> = {
  encode(message: Application_ApplicationRuntimeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deployTime), writer.uint32(10).fork()).join();
    }
    for (const v of message.globalOutputResources) {
      Application_ApplicationRuntimeInfo_GlobalOutputResource.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.monitoringConfig !== undefined) {
      Application_ApplicationRuntimeInfo_MonitoringConfig.encode(message.monitoringConfig, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application_ApplicationRuntimeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication_ApplicationRuntimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deployTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.globalOutputResources.push(
            Application_ApplicationRuntimeInfo_GlobalOutputResource.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.monitoringConfig = Application_ApplicationRuntimeInfo_MonitoringConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application_ApplicationRuntimeInfo {
    return {
      deployTime: isSet(object.deployTime) ? fromJsonTimestamp(object.deployTime) : undefined,
      globalOutputResources: globalThis.Array.isArray(object?.globalOutputResources)
        ? object.globalOutputResources.map((e: any) =>
          Application_ApplicationRuntimeInfo_GlobalOutputResource.fromJSON(e)
        )
        : [],
      monitoringConfig: isSet(object.monitoringConfig)
        ? Application_ApplicationRuntimeInfo_MonitoringConfig.fromJSON(object.monitoringConfig)
        : undefined,
    };
  },

  toJSON(message: Application_ApplicationRuntimeInfo): unknown {
    const obj: any = {};
    if (message.deployTime !== undefined) {
      obj.deployTime = message.deployTime.toISOString();
    }
    if (message.globalOutputResources?.length) {
      obj.globalOutputResources = message.globalOutputResources.map((e) =>
        Application_ApplicationRuntimeInfo_GlobalOutputResource.toJSON(e)
      );
    }
    if (message.monitoringConfig !== undefined) {
      obj.monitoringConfig = Application_ApplicationRuntimeInfo_MonitoringConfig.toJSON(message.monitoringConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Application_ApplicationRuntimeInfo>, I>>(
    base?: I,
  ): Application_ApplicationRuntimeInfo {
    return Application_ApplicationRuntimeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Application_ApplicationRuntimeInfo>, I>>(
    object: I,
  ): Application_ApplicationRuntimeInfo {
    const message = createBaseApplication_ApplicationRuntimeInfo();
    message.deployTime = object.deployTime ?? undefined;
    message.globalOutputResources =
      object.globalOutputResources?.map((e) =>
        Application_ApplicationRuntimeInfo_GlobalOutputResource.fromPartial(e)
      ) || [];
    message.monitoringConfig = (object.monitoringConfig !== undefined && object.monitoringConfig !== null)
      ? Application_ApplicationRuntimeInfo_MonitoringConfig.fromPartial(object.monitoringConfig)
      : undefined;
    return message;
  },
};

function createBaseApplication_ApplicationRuntimeInfo_GlobalOutputResource(): Application_ApplicationRuntimeInfo_GlobalOutputResource {
  return { outputResource: "", producerNode: "", key: "" };
}

export const Application_ApplicationRuntimeInfo_GlobalOutputResource: MessageFns<
  Application_ApplicationRuntimeInfo_GlobalOutputResource
> = {
  encode(
    message: Application_ApplicationRuntimeInfo_GlobalOutputResource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.outputResource !== "") {
      writer.uint32(10).string(message.outputResource);
    }
    if (message.producerNode !== "") {
      writer.uint32(18).string(message.producerNode);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application_ApplicationRuntimeInfo_GlobalOutputResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication_ApplicationRuntimeInfo_GlobalOutputResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputResource = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.producerNode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application_ApplicationRuntimeInfo_GlobalOutputResource {
    return {
      outputResource: isSet(object.outputResource) ? globalThis.String(object.outputResource) : "",
      producerNode: isSet(object.producerNode) ? globalThis.String(object.producerNode) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: Application_ApplicationRuntimeInfo_GlobalOutputResource): unknown {
    const obj: any = {};
    if (message.outputResource !== "") {
      obj.outputResource = message.outputResource;
    }
    if (message.producerNode !== "") {
      obj.producerNode = message.producerNode;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Application_ApplicationRuntimeInfo_GlobalOutputResource>, I>>(
    base?: I,
  ): Application_ApplicationRuntimeInfo_GlobalOutputResource {
    return Application_ApplicationRuntimeInfo_GlobalOutputResource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Application_ApplicationRuntimeInfo_GlobalOutputResource>, I>>(
    object: I,
  ): Application_ApplicationRuntimeInfo_GlobalOutputResource {
    const message = createBaseApplication_ApplicationRuntimeInfo_GlobalOutputResource();
    message.outputResource = object.outputResource ?? "";
    message.producerNode = object.producerNode ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseApplication_ApplicationRuntimeInfo_MonitoringConfig(): Application_ApplicationRuntimeInfo_MonitoringConfig {
  return { enabled: false };
}

export const Application_ApplicationRuntimeInfo_MonitoringConfig: MessageFns<
  Application_ApplicationRuntimeInfo_MonitoringConfig
> = {
  encode(
    message: Application_ApplicationRuntimeInfo_MonitoringConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application_ApplicationRuntimeInfo_MonitoringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication_ApplicationRuntimeInfo_MonitoringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application_ApplicationRuntimeInfo_MonitoringConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: Application_ApplicationRuntimeInfo_MonitoringConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Application_ApplicationRuntimeInfo_MonitoringConfig>, I>>(
    base?: I,
  ): Application_ApplicationRuntimeInfo_MonitoringConfig {
    return Application_ApplicationRuntimeInfo_MonitoringConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Application_ApplicationRuntimeInfo_MonitoringConfig>, I>>(
    object: I,
  ): Application_ApplicationRuntimeInfo_MonitoringConfig {
    const message = createBaseApplication_ApplicationRuntimeInfo_MonitoringConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseApplication_LabelsEntry(): Application_LabelsEntry {
  return { key: "", value: "" };
}

export const Application_LabelsEntry: MessageFns<Application_LabelsEntry> = {
  encode(message: Application_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Application_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Application_LabelsEntry>, I>>(base?: I): Application_LabelsEntry {
    return Application_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Application_LabelsEntry>, I>>(object: I): Application_LabelsEntry {
    const message = createBaseApplication_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApplicationConfigs(): ApplicationConfigs {
  return { nodes: [] };
}

export const ApplicationConfigs: MessageFns<ApplicationConfigs> = {
  encode(message: ApplicationConfigs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationConfigs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationConfigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationConfigs {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [] };
  },

  toJSON(message: ApplicationConfigs): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplicationConfigs>, I>>(base?: I): ApplicationConfigs {
    return ApplicationConfigs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationConfigs>, I>>(object: I): ApplicationConfigs {
    const message = createBaseApplicationConfigs();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNode(): Node {
  return {
    outputAllOutputChannelsToStream: undefined,
    name: "",
    displayName: "",
    nodeConfig: undefined,
    processor: "",
    parents: [],
  };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputAllOutputChannelsToStream !== undefined) {
      writer.uint32(48).bool(message.outputAllOutputChannelsToStream);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.nodeConfig !== undefined) {
      ProcessorConfig.encode(message.nodeConfig, writer.uint32(26).fork()).join();
    }
    if (message.processor !== "") {
      writer.uint32(34).string(message.processor);
    }
    for (const v of message.parents) {
      Node_InputEdge.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.outputAllOutputChannelsToStream = reader.bool();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeConfig = ProcessorConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.processor = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parents.push(Node_InputEdge.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      outputAllOutputChannelsToStream: isSet(object.outputAllOutputChannelsToStream)
        ? globalThis.Boolean(object.outputAllOutputChannelsToStream)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      nodeConfig: isSet(object.nodeConfig) ? ProcessorConfig.fromJSON(object.nodeConfig) : undefined,
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
      parents: globalThis.Array.isArray(object?.parents)
        ? object.parents.map((e: any) => Node_InputEdge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.outputAllOutputChannelsToStream !== undefined) {
      obj.outputAllOutputChannelsToStream = message.outputAllOutputChannelsToStream;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.nodeConfig !== undefined) {
      obj.nodeConfig = ProcessorConfig.toJSON(message.nodeConfig);
    }
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    if (message.parents?.length) {
      obj.parents = message.parents.map((e) => Node_InputEdge.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.outputAllOutputChannelsToStream = object.outputAllOutputChannelsToStream ?? undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.nodeConfig = (object.nodeConfig !== undefined && object.nodeConfig !== null)
      ? ProcessorConfig.fromPartial(object.nodeConfig)
      : undefined;
    message.processor = object.processor ?? "";
    message.parents = object.parents?.map((e) => Node_InputEdge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNode_InputEdge(): Node_InputEdge {
  return { parentNode: "", parentOutputChannel: "", connectedInputChannel: "" };
}

export const Node_InputEdge: MessageFns<Node_InputEdge> = {
  encode(message: Node_InputEdge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentNode !== "") {
      writer.uint32(10).string(message.parentNode);
    }
    if (message.parentOutputChannel !== "") {
      writer.uint32(18).string(message.parentOutputChannel);
    }
    if (message.connectedInputChannel !== "") {
      writer.uint32(26).string(message.connectedInputChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node_InputEdge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode_InputEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parentNode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parentOutputChannel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectedInputChannel = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node_InputEdge {
    return {
      parentNode: isSet(object.parentNode) ? globalThis.String(object.parentNode) : "",
      parentOutputChannel: isSet(object.parentOutputChannel) ? globalThis.String(object.parentOutputChannel) : "",
      connectedInputChannel: isSet(object.connectedInputChannel) ? globalThis.String(object.connectedInputChannel) : "",
    };
  },

  toJSON(message: Node_InputEdge): unknown {
    const obj: any = {};
    if (message.parentNode !== "") {
      obj.parentNode = message.parentNode;
    }
    if (message.parentOutputChannel !== "") {
      obj.parentOutputChannel = message.parentOutputChannel;
    }
    if (message.connectedInputChannel !== "") {
      obj.connectedInputChannel = message.connectedInputChannel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node_InputEdge>, I>>(base?: I): Node_InputEdge {
    return Node_InputEdge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node_InputEdge>, I>>(object: I): Node_InputEdge {
    const message = createBaseNode_InputEdge();
    message.parentNode = object.parentNode ?? "";
    message.parentOutputChannel = object.parentOutputChannel ?? "";
    message.connectedInputChannel = object.connectedInputChannel ?? "";
    return message;
  },
};

function createBaseDraft(): Draft {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    description: "",
    draftApplicationConfigs: undefined,
  };
}

export const Draft: MessageFns<Draft> = {
  encode(message: Draft, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Draft_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.draftApplicationConfigs !== undefined) {
      ApplicationConfigs.encode(message.draftApplicationConfigs, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Draft {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Draft_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.draftApplicationConfigs = ApplicationConfigs.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Draft {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      draftApplicationConfigs: isSet(object.draftApplicationConfigs)
        ? ApplicationConfigs.fromJSON(object.draftApplicationConfigs)
        : undefined,
    };
  },

  toJSON(message: Draft): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.draftApplicationConfigs !== undefined) {
      obj.draftApplicationConfigs = ApplicationConfigs.toJSON(message.draftApplicationConfigs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Draft>, I>>(base?: I): Draft {
    return Draft.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Draft>, I>>(object: I): Draft {
    const message = createBaseDraft();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.draftApplicationConfigs =
      (object.draftApplicationConfigs !== undefined && object.draftApplicationConfigs !== null)
        ? ApplicationConfigs.fromPartial(object.draftApplicationConfigs)
        : undefined;
    return message;
  },
};

function createBaseDraft_LabelsEntry(): Draft_LabelsEntry {
  return { key: "", value: "" };
}

export const Draft_LabelsEntry: MessageFns<Draft_LabelsEntry> = {
  encode(message: Draft_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Draft_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraft_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Draft_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Draft_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Draft_LabelsEntry>, I>>(base?: I): Draft_LabelsEntry {
    return Draft_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Draft_LabelsEntry>, I>>(object: I): Draft_LabelsEntry {
    const message = createBaseDraft_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProcessor(): Processor {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    description: "",
    processorType: 0,
    modelType: 0,
    customProcessorSourceInfo: undefined,
    state: 0,
    processorIoSpec: undefined,
    configurationTypeurl: "",
    supportedAnnotationTypes: [],
    supportsPostProcessing: false,
  };
}

export const Processor: MessageFns<Processor> = {
  encode(message: Processor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Processor_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(82).string(message.description);
    }
    if (message.processorType !== 0) {
      writer.uint32(48).int32(message.processorType);
    }
    if (message.modelType !== 0) {
      writer.uint32(104).int32(message.modelType);
    }
    if (message.customProcessorSourceInfo !== undefined) {
      CustomProcessorSourceInfo.encode(message.customProcessorSourceInfo, writer.uint32(58).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.processorIoSpec !== undefined) {
      ProcessorIOSpec.encode(message.processorIoSpec, writer.uint32(90).fork()).join();
    }
    if (message.configurationTypeurl !== "") {
      writer.uint32(114).string(message.configurationTypeurl);
    }
    writer.uint32(122).fork();
    for (const v of message.supportedAnnotationTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.supportsPostProcessing !== false) {
      writer.uint32(136).bool(message.supportsPostProcessing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Processor_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.processorType = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.modelType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.customProcessorSourceInfo = CustomProcessorSourceInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.processorIoSpec = ProcessorIOSpec.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.configurationTypeurl = reader.string();
          continue;
        }
        case 15: {
          if (tag === 120) {
            message.supportedAnnotationTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedAnnotationTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.supportsPostProcessing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      processorType: isSet(object.processorType) ? processor_ProcessorTypeFromJSON(object.processorType) : 0,
      modelType: isSet(object.modelType) ? modelTypeFromJSON(object.modelType) : 0,
      customProcessorSourceInfo: isSet(object.customProcessorSourceInfo)
        ? CustomProcessorSourceInfo.fromJSON(object.customProcessorSourceInfo)
        : undefined,
      state: isSet(object.state) ? processor_ProcessorStateFromJSON(object.state) : 0,
      processorIoSpec: isSet(object.processorIoSpec) ? ProcessorIOSpec.fromJSON(object.processorIoSpec) : undefined,
      configurationTypeurl: isSet(object.configurationTypeurl) ? globalThis.String(object.configurationTypeurl) : "",
      supportedAnnotationTypes: globalThis.Array.isArray(object?.supportedAnnotationTypes)
        ? object.supportedAnnotationTypes.map((e: any) => streamAnnotationTypeFromJSON(e))
        : [],
      supportsPostProcessing: isSet(object.supportsPostProcessing)
        ? globalThis.Boolean(object.supportsPostProcessing)
        : false,
    };
  },

  toJSON(message: Processor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.processorType !== 0) {
      obj.processorType = processor_ProcessorTypeToJSON(message.processorType);
    }
    if (message.modelType !== 0) {
      obj.modelType = modelTypeToJSON(message.modelType);
    }
    if (message.customProcessorSourceInfo !== undefined) {
      obj.customProcessorSourceInfo = CustomProcessorSourceInfo.toJSON(message.customProcessorSourceInfo);
    }
    if (message.state !== 0) {
      obj.state = processor_ProcessorStateToJSON(message.state);
    }
    if (message.processorIoSpec !== undefined) {
      obj.processorIoSpec = ProcessorIOSpec.toJSON(message.processorIoSpec);
    }
    if (message.configurationTypeurl !== "") {
      obj.configurationTypeurl = message.configurationTypeurl;
    }
    if (message.supportedAnnotationTypes?.length) {
      obj.supportedAnnotationTypes = message.supportedAnnotationTypes.map((e) => streamAnnotationTypeToJSON(e));
    }
    if (message.supportsPostProcessing !== false) {
      obj.supportsPostProcessing = message.supportsPostProcessing;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Processor>, I>>(base?: I): Processor {
    return Processor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Processor>, I>>(object: I): Processor {
    const message = createBaseProcessor();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.processorType = object.processorType ?? 0;
    message.modelType = object.modelType ?? 0;
    message.customProcessorSourceInfo =
      (object.customProcessorSourceInfo !== undefined && object.customProcessorSourceInfo !== null)
        ? CustomProcessorSourceInfo.fromPartial(object.customProcessorSourceInfo)
        : undefined;
    message.state = object.state ?? 0;
    message.processorIoSpec = (object.processorIoSpec !== undefined && object.processorIoSpec !== null)
      ? ProcessorIOSpec.fromPartial(object.processorIoSpec)
      : undefined;
    message.configurationTypeurl = object.configurationTypeurl ?? "";
    message.supportedAnnotationTypes = object.supportedAnnotationTypes?.map((e) => e) || [];
    message.supportsPostProcessing = object.supportsPostProcessing ?? false;
    return message;
  },
};

function createBaseProcessor_LabelsEntry(): Processor_LabelsEntry {
  return { key: "", value: "" };
}

export const Processor_LabelsEntry: MessageFns<Processor_LabelsEntry> = {
  encode(message: Processor_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processor_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessor_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processor_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Processor_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Processor_LabelsEntry>, I>>(base?: I): Processor_LabelsEntry {
    return Processor_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Processor_LabelsEntry>, I>>(object: I): Processor_LabelsEntry {
    const message = createBaseProcessor_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProcessorIOSpec(): ProcessorIOSpec {
  return {
    graphInputChannelSpecs: [],
    graphOutputChannelSpecs: [],
    instanceResourceInputBindingSpecs: [],
    instanceResourceOutputBindingSpecs: [],
  };
}

export const ProcessorIOSpec: MessageFns<ProcessorIOSpec> = {
  encode(message: ProcessorIOSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.graphInputChannelSpecs) {
      ProcessorIOSpec_GraphInputChannelSpec.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.graphOutputChannelSpecs) {
      ProcessorIOSpec_GraphOutputChannelSpec.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.instanceResourceInputBindingSpecs) {
      ProcessorIOSpec_InstanceResourceInputBindingSpec.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.instanceResourceOutputBindingSpecs) {
      ProcessorIOSpec_InstanceResourceOutputBindingSpec.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.graphInputChannelSpecs.push(ProcessorIOSpec_GraphInputChannelSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.graphOutputChannelSpecs.push(ProcessorIOSpec_GraphOutputChannelSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.instanceResourceInputBindingSpecs.push(
            ProcessorIOSpec_InstanceResourceInputBindingSpec.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.instanceResourceOutputBindingSpecs.push(
            ProcessorIOSpec_InstanceResourceOutputBindingSpec.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec {
    return {
      graphInputChannelSpecs: globalThis.Array.isArray(object?.graphInputChannelSpecs)
        ? object.graphInputChannelSpecs.map((e: any) => ProcessorIOSpec_GraphInputChannelSpec.fromJSON(e))
        : [],
      graphOutputChannelSpecs: globalThis.Array.isArray(object?.graphOutputChannelSpecs)
        ? object.graphOutputChannelSpecs.map((e: any) => ProcessorIOSpec_GraphOutputChannelSpec.fromJSON(e))
        : [],
      instanceResourceInputBindingSpecs: globalThis.Array.isArray(object?.instanceResourceInputBindingSpecs)
        ? object.instanceResourceInputBindingSpecs.map((e: any) =>
          ProcessorIOSpec_InstanceResourceInputBindingSpec.fromJSON(e)
        )
        : [],
      instanceResourceOutputBindingSpecs: globalThis.Array.isArray(object?.instanceResourceOutputBindingSpecs)
        ? object.instanceResourceOutputBindingSpecs.map((e: any) =>
          ProcessorIOSpec_InstanceResourceOutputBindingSpec.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: ProcessorIOSpec): unknown {
    const obj: any = {};
    if (message.graphInputChannelSpecs?.length) {
      obj.graphInputChannelSpecs = message.graphInputChannelSpecs.map((e) =>
        ProcessorIOSpec_GraphInputChannelSpec.toJSON(e)
      );
    }
    if (message.graphOutputChannelSpecs?.length) {
      obj.graphOutputChannelSpecs = message.graphOutputChannelSpecs.map((e) =>
        ProcessorIOSpec_GraphOutputChannelSpec.toJSON(e)
      );
    }
    if (message.instanceResourceInputBindingSpecs?.length) {
      obj.instanceResourceInputBindingSpecs = message.instanceResourceInputBindingSpecs.map((e) =>
        ProcessorIOSpec_InstanceResourceInputBindingSpec.toJSON(e)
      );
    }
    if (message.instanceResourceOutputBindingSpecs?.length) {
      obj.instanceResourceOutputBindingSpecs = message.instanceResourceOutputBindingSpecs.map((e) =>
        ProcessorIOSpec_InstanceResourceOutputBindingSpec.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorIOSpec>, I>>(base?: I): ProcessorIOSpec {
    return ProcessorIOSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorIOSpec>, I>>(object: I): ProcessorIOSpec {
    const message = createBaseProcessorIOSpec();
    message.graphInputChannelSpecs =
      object.graphInputChannelSpecs?.map((e) => ProcessorIOSpec_GraphInputChannelSpec.fromPartial(e)) || [];
    message.graphOutputChannelSpecs =
      object.graphOutputChannelSpecs?.map((e) => ProcessorIOSpec_GraphOutputChannelSpec.fromPartial(e)) || [];
    message.instanceResourceInputBindingSpecs =
      object.instanceResourceInputBindingSpecs?.map((e) =>
        ProcessorIOSpec_InstanceResourceInputBindingSpec.fromPartial(e)
      ) || [];
    message.instanceResourceOutputBindingSpecs =
      object.instanceResourceOutputBindingSpecs?.map((e) =>
        ProcessorIOSpec_InstanceResourceOutputBindingSpec.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseProcessorIOSpec_GraphInputChannelSpec(): ProcessorIOSpec_GraphInputChannelSpec {
  return { name: "", dataType: 0, acceptedDataTypeUris: [], required: false, maxConnectionAllowed: Long.ZERO };
}

export const ProcessorIOSpec_GraphInputChannelSpec: MessageFns<ProcessorIOSpec_GraphInputChannelSpec> = {
  encode(message: ProcessorIOSpec_GraphInputChannelSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== 0) {
      writer.uint32(16).int32(message.dataType);
    }
    for (const v of message.acceptedDataTypeUris) {
      writer.uint32(42).string(v!);
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    if (!message.maxConnectionAllowed.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.maxConnectionAllowed.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec_GraphInputChannelSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec_GraphInputChannelSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.acceptedDataTypeUris.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxConnectionAllowed = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec_GraphInputChannelSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      acceptedDataTypeUris: globalThis.Array.isArray(object?.acceptedDataTypeUris)
        ? object.acceptedDataTypeUris.map((e: any) => globalThis.String(e))
        : [],
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      maxConnectionAllowed: isSet(object.maxConnectionAllowed)
        ? Long.fromValue(object.maxConnectionAllowed)
        : Long.ZERO,
    };
  },

  toJSON(message: ProcessorIOSpec_GraphInputChannelSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.acceptedDataTypeUris?.length) {
      obj.acceptedDataTypeUris = message.acceptedDataTypeUris;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (!message.maxConnectionAllowed.equals(Long.ZERO)) {
      obj.maxConnectionAllowed = (message.maxConnectionAllowed || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorIOSpec_GraphInputChannelSpec>, I>>(
    base?: I,
  ): ProcessorIOSpec_GraphInputChannelSpec {
    return ProcessorIOSpec_GraphInputChannelSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorIOSpec_GraphInputChannelSpec>, I>>(
    object: I,
  ): ProcessorIOSpec_GraphInputChannelSpec {
    const message = createBaseProcessorIOSpec_GraphInputChannelSpec();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? 0;
    message.acceptedDataTypeUris = object.acceptedDataTypeUris?.map((e) => e) || [];
    message.required = object.required ?? false;
    message.maxConnectionAllowed = (object.maxConnectionAllowed !== undefined && object.maxConnectionAllowed !== null)
      ? Long.fromValue(object.maxConnectionAllowed)
      : Long.ZERO;
    return message;
  },
};

function createBaseProcessorIOSpec_GraphOutputChannelSpec(): ProcessorIOSpec_GraphOutputChannelSpec {
  return { name: "", dataType: 0, dataTypeUri: "" };
}

export const ProcessorIOSpec_GraphOutputChannelSpec: MessageFns<ProcessorIOSpec_GraphOutputChannelSpec> = {
  encode(message: ProcessorIOSpec_GraphOutputChannelSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== 0) {
      writer.uint32(16).int32(message.dataType);
    }
    if (message.dataTypeUri !== "") {
      writer.uint32(26).string(message.dataTypeUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec_GraphOutputChannelSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec_GraphOutputChannelSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataTypeUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec_GraphOutputChannelSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      dataTypeUri: isSet(object.dataTypeUri) ? globalThis.String(object.dataTypeUri) : "",
    };
  },

  toJSON(message: ProcessorIOSpec_GraphOutputChannelSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.dataTypeUri !== "") {
      obj.dataTypeUri = message.dataTypeUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorIOSpec_GraphOutputChannelSpec>, I>>(
    base?: I,
  ): ProcessorIOSpec_GraphOutputChannelSpec {
    return ProcessorIOSpec_GraphOutputChannelSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorIOSpec_GraphOutputChannelSpec>, I>>(
    object: I,
  ): ProcessorIOSpec_GraphOutputChannelSpec {
    const message = createBaseProcessorIOSpec_GraphOutputChannelSpec();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? 0;
    message.dataTypeUri = object.dataTypeUri ?? "";
    return message;
  },
};

function createBaseProcessorIOSpec_InstanceResourceInputBindingSpec(): ProcessorIOSpec_InstanceResourceInputBindingSpec {
  return { configTypeUri: undefined, resourceTypeUri: undefined, name: "" };
}

export const ProcessorIOSpec_InstanceResourceInputBindingSpec: MessageFns<
  ProcessorIOSpec_InstanceResourceInputBindingSpec
> = {
  encode(
    message: ProcessorIOSpec_InstanceResourceInputBindingSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.configTypeUri !== undefined) {
      writer.uint32(18).string(message.configTypeUri);
    }
    if (message.resourceTypeUri !== undefined) {
      writer.uint32(26).string(message.resourceTypeUri);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec_InstanceResourceInputBindingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec_InstanceResourceInputBindingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configTypeUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resourceTypeUri = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec_InstanceResourceInputBindingSpec {
    return {
      configTypeUri: isSet(object.configTypeUri) ? globalThis.String(object.configTypeUri) : undefined,
      resourceTypeUri: isSet(object.resourceTypeUri) ? globalThis.String(object.resourceTypeUri) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: ProcessorIOSpec_InstanceResourceInputBindingSpec): unknown {
    const obj: any = {};
    if (message.configTypeUri !== undefined) {
      obj.configTypeUri = message.configTypeUri;
    }
    if (message.resourceTypeUri !== undefined) {
      obj.resourceTypeUri = message.resourceTypeUri;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorIOSpec_InstanceResourceInputBindingSpec>, I>>(
    base?: I,
  ): ProcessorIOSpec_InstanceResourceInputBindingSpec {
    return ProcessorIOSpec_InstanceResourceInputBindingSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorIOSpec_InstanceResourceInputBindingSpec>, I>>(
    object: I,
  ): ProcessorIOSpec_InstanceResourceInputBindingSpec {
    const message = createBaseProcessorIOSpec_InstanceResourceInputBindingSpec();
    message.configTypeUri = object.configTypeUri ?? undefined;
    message.resourceTypeUri = object.resourceTypeUri ?? undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseProcessorIOSpec_InstanceResourceOutputBindingSpec(): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
  return { name: "", resourceTypeUri: "", explicit: false };
}

export const ProcessorIOSpec_InstanceResourceOutputBindingSpec: MessageFns<
  ProcessorIOSpec_InstanceResourceOutputBindingSpec
> = {
  encode(
    message: ProcessorIOSpec_InstanceResourceOutputBindingSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resourceTypeUri !== "") {
      writer.uint32(18).string(message.resourceTypeUri);
    }
    if (message.explicit !== false) {
      writer.uint32(24).bool(message.explicit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec_InstanceResourceOutputBindingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceTypeUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.explicit = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      resourceTypeUri: isSet(object.resourceTypeUri) ? globalThis.String(object.resourceTypeUri) : "",
      explicit: isSet(object.explicit) ? globalThis.Boolean(object.explicit) : false,
    };
  },

  toJSON(message: ProcessorIOSpec_InstanceResourceOutputBindingSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.resourceTypeUri !== "") {
      obj.resourceTypeUri = message.resourceTypeUri;
    }
    if (message.explicit !== false) {
      obj.explicit = message.explicit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorIOSpec_InstanceResourceOutputBindingSpec>, I>>(
    base?: I,
  ): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
    return ProcessorIOSpec_InstanceResourceOutputBindingSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorIOSpec_InstanceResourceOutputBindingSpec>, I>>(
    object: I,
  ): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
    const message = createBaseProcessorIOSpec_InstanceResourceOutputBindingSpec();
    message.name = object.name ?? "";
    message.resourceTypeUri = object.resourceTypeUri ?? "";
    message.explicit = object.explicit ?? false;
    return message;
  },
};

function createBaseCustomProcessorSourceInfo(): CustomProcessorSourceInfo {
  return { vertexModel: undefined, sourceType: 0, additionalInfo: {}, modelSchema: undefined };
}

export const CustomProcessorSourceInfo: MessageFns<CustomProcessorSourceInfo> = {
  encode(message: CustomProcessorSourceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vertexModel !== undefined) {
      writer.uint32(18).string(message.vertexModel);
    }
    if (message.sourceType !== 0) {
      writer.uint32(8).int32(message.sourceType);
    }
    Object.entries(message.additionalInfo).forEach(([key, value]) => {
      CustomProcessorSourceInfo_AdditionalInfoEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.modelSchema !== undefined) {
      CustomProcessorSourceInfo_ModelSchema.encode(message.modelSchema, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomProcessorSourceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomProcessorSourceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vertexModel = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CustomProcessorSourceInfo_AdditionalInfoEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.additionalInfo[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.modelSchema = CustomProcessorSourceInfo_ModelSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomProcessorSourceInfo {
    return {
      vertexModel: isSet(object.vertexModel) ? globalThis.String(object.vertexModel) : undefined,
      sourceType: isSet(object.sourceType) ? customProcessorSourceInfo_SourceTypeFromJSON(object.sourceType) : 0,
      additionalInfo: isObject(object.additionalInfo)
        ? Object.entries(object.additionalInfo).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      modelSchema: isSet(object.modelSchema)
        ? CustomProcessorSourceInfo_ModelSchema.fromJSON(object.modelSchema)
        : undefined,
    };
  },

  toJSON(message: CustomProcessorSourceInfo): unknown {
    const obj: any = {};
    if (message.vertexModel !== undefined) {
      obj.vertexModel = message.vertexModel;
    }
    if (message.sourceType !== 0) {
      obj.sourceType = customProcessorSourceInfo_SourceTypeToJSON(message.sourceType);
    }
    if (message.additionalInfo) {
      const entries = Object.entries(message.additionalInfo);
      if (entries.length > 0) {
        obj.additionalInfo = {};
        entries.forEach(([k, v]) => {
          obj.additionalInfo[k] = v;
        });
      }
    }
    if (message.modelSchema !== undefined) {
      obj.modelSchema = CustomProcessorSourceInfo_ModelSchema.toJSON(message.modelSchema);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomProcessorSourceInfo>, I>>(base?: I): CustomProcessorSourceInfo {
    return CustomProcessorSourceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomProcessorSourceInfo>, I>>(object: I): CustomProcessorSourceInfo {
    const message = createBaseCustomProcessorSourceInfo();
    message.vertexModel = object.vertexModel ?? undefined;
    message.sourceType = object.sourceType ?? 0;
    message.additionalInfo = Object.entries(object.additionalInfo ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.modelSchema = (object.modelSchema !== undefined && object.modelSchema !== null)
      ? CustomProcessorSourceInfo_ModelSchema.fromPartial(object.modelSchema)
      : undefined;
    return message;
  },
};

function createBaseCustomProcessorSourceInfo_ModelSchema(): CustomProcessorSourceInfo_ModelSchema {
  return { instancesSchema: undefined, parametersSchema: undefined, predictionsSchema: undefined };
}

export const CustomProcessorSourceInfo_ModelSchema: MessageFns<CustomProcessorSourceInfo_ModelSchema> = {
  encode(message: CustomProcessorSourceInfo_ModelSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instancesSchema !== undefined) {
      GcsSource.encode(message.instancesSchema, writer.uint32(10).fork()).join();
    }
    if (message.parametersSchema !== undefined) {
      GcsSource.encode(message.parametersSchema, writer.uint32(18).fork()).join();
    }
    if (message.predictionsSchema !== undefined) {
      GcsSource.encode(message.predictionsSchema, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomProcessorSourceInfo_ModelSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomProcessorSourceInfo_ModelSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instancesSchema = GcsSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parametersSchema = GcsSource.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predictionsSchema = GcsSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomProcessorSourceInfo_ModelSchema {
    return {
      instancesSchema: isSet(object.instancesSchema) ? GcsSource.fromJSON(object.instancesSchema) : undefined,
      parametersSchema: isSet(object.parametersSchema) ? GcsSource.fromJSON(object.parametersSchema) : undefined,
      predictionsSchema: isSet(object.predictionsSchema) ? GcsSource.fromJSON(object.predictionsSchema) : undefined,
    };
  },

  toJSON(message: CustomProcessorSourceInfo_ModelSchema): unknown {
    const obj: any = {};
    if (message.instancesSchema !== undefined) {
      obj.instancesSchema = GcsSource.toJSON(message.instancesSchema);
    }
    if (message.parametersSchema !== undefined) {
      obj.parametersSchema = GcsSource.toJSON(message.parametersSchema);
    }
    if (message.predictionsSchema !== undefined) {
      obj.predictionsSchema = GcsSource.toJSON(message.predictionsSchema);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomProcessorSourceInfo_ModelSchema>, I>>(
    base?: I,
  ): CustomProcessorSourceInfo_ModelSchema {
    return CustomProcessorSourceInfo_ModelSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomProcessorSourceInfo_ModelSchema>, I>>(
    object: I,
  ): CustomProcessorSourceInfo_ModelSchema {
    const message = createBaseCustomProcessorSourceInfo_ModelSchema();
    message.instancesSchema = (object.instancesSchema !== undefined && object.instancesSchema !== null)
      ? GcsSource.fromPartial(object.instancesSchema)
      : undefined;
    message.parametersSchema = (object.parametersSchema !== undefined && object.parametersSchema !== null)
      ? GcsSource.fromPartial(object.parametersSchema)
      : undefined;
    message.predictionsSchema = (object.predictionsSchema !== undefined && object.predictionsSchema !== null)
      ? GcsSource.fromPartial(object.predictionsSchema)
      : undefined;
    return message;
  },
};

function createBaseCustomProcessorSourceInfo_AdditionalInfoEntry(): CustomProcessorSourceInfo_AdditionalInfoEntry {
  return { key: "", value: "" };
}

export const CustomProcessorSourceInfo_AdditionalInfoEntry: MessageFns<CustomProcessorSourceInfo_AdditionalInfoEntry> =
  {
    encode(
      message: CustomProcessorSourceInfo_AdditionalInfoEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CustomProcessorSourceInfo_AdditionalInfoEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCustomProcessorSourceInfo_AdditionalInfoEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CustomProcessorSourceInfo_AdditionalInfoEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: CustomProcessorSourceInfo_AdditionalInfoEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CustomProcessorSourceInfo_AdditionalInfoEntry>, I>>(
      base?: I,
    ): CustomProcessorSourceInfo_AdditionalInfoEntry {
      return CustomProcessorSourceInfo_AdditionalInfoEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CustomProcessorSourceInfo_AdditionalInfoEntry>, I>>(
      object: I,
    ): CustomProcessorSourceInfo_AdditionalInfoEntry {
      const message = createBaseCustomProcessorSourceInfo_AdditionalInfoEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseProcessorConfig(): ProcessorConfig {
  return {
    videoStreamInputConfig: undefined,
    aiEnabledDevicesInputConfig: undefined,
    mediaWarehouseConfig: undefined,
    personBlurConfig: undefined,
    occupancyCountConfig: undefined,
    personVehicleDetectionConfig: undefined,
    vertexAutomlVisionConfig: undefined,
    vertexAutomlVideoConfig: undefined,
    vertexCustomConfig: undefined,
    generalObjectDetectionConfig: undefined,
    bigQueryConfig: undefined,
    personalProtectiveEquipmentDetectionConfig: undefined,
  };
}

export const ProcessorConfig: MessageFns<ProcessorConfig> = {
  encode(message: ProcessorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoStreamInputConfig !== undefined) {
      VideoStreamInputConfig.encode(message.videoStreamInputConfig, writer.uint32(74).fork()).join();
    }
    if (message.aiEnabledDevicesInputConfig !== undefined) {
      AIEnabledDevicesInputConfig.encode(message.aiEnabledDevicesInputConfig, writer.uint32(162).fork()).join();
    }
    if (message.mediaWarehouseConfig !== undefined) {
      MediaWarehouseConfig.encode(message.mediaWarehouseConfig, writer.uint32(82).fork()).join();
    }
    if (message.personBlurConfig !== undefined) {
      PersonBlurConfig.encode(message.personBlurConfig, writer.uint32(90).fork()).join();
    }
    if (message.occupancyCountConfig !== undefined) {
      OccupancyCountConfig.encode(message.occupancyCountConfig, writer.uint32(98).fork()).join();
    }
    if (message.personVehicleDetectionConfig !== undefined) {
      PersonVehicleDetectionConfig.encode(message.personVehicleDetectionConfig, writer.uint32(122).fork()).join();
    }
    if (message.vertexAutomlVisionConfig !== undefined) {
      VertexAutoMLVisionConfig.encode(message.vertexAutomlVisionConfig, writer.uint32(106).fork()).join();
    }
    if (message.vertexAutomlVideoConfig !== undefined) {
      VertexAutoMLVideoConfig.encode(message.vertexAutomlVideoConfig, writer.uint32(114).fork()).join();
    }
    if (message.vertexCustomConfig !== undefined) {
      VertexCustomConfig.encode(message.vertexCustomConfig, writer.uint32(138).fork()).join();
    }
    if (message.generalObjectDetectionConfig !== undefined) {
      GeneralObjectDetectionConfig.encode(message.generalObjectDetectionConfig, writer.uint32(146).fork()).join();
    }
    if (message.bigQueryConfig !== undefined) {
      BigQueryConfig.encode(message.bigQueryConfig, writer.uint32(154).fork()).join();
    }
    if (message.personalProtectiveEquipmentDetectionConfig !== undefined) {
      PersonalProtectiveEquipmentDetectionConfig.encode(
        message.personalProtectiveEquipmentDetectionConfig,
        writer.uint32(178).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.videoStreamInputConfig = VideoStreamInputConfig.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.aiEnabledDevicesInputConfig = AIEnabledDevicesInputConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mediaWarehouseConfig = MediaWarehouseConfig.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.personBlurConfig = PersonBlurConfig.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.occupancyCountConfig = OccupancyCountConfig.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.personVehicleDetectionConfig = PersonVehicleDetectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.vertexAutomlVisionConfig = VertexAutoMLVisionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.vertexAutomlVideoConfig = VertexAutoMLVideoConfig.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.vertexCustomConfig = VertexCustomConfig.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.generalObjectDetectionConfig = GeneralObjectDetectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.bigQueryConfig = BigQueryConfig.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.personalProtectiveEquipmentDetectionConfig = PersonalProtectiveEquipmentDetectionConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorConfig {
    return {
      videoStreamInputConfig: isSet(object.videoStreamInputConfig)
        ? VideoStreamInputConfig.fromJSON(object.videoStreamInputConfig)
        : undefined,
      aiEnabledDevicesInputConfig: isSet(object.aiEnabledDevicesInputConfig)
        ? AIEnabledDevicesInputConfig.fromJSON(object.aiEnabledDevicesInputConfig)
        : undefined,
      mediaWarehouseConfig: isSet(object.mediaWarehouseConfig)
        ? MediaWarehouseConfig.fromJSON(object.mediaWarehouseConfig)
        : undefined,
      personBlurConfig: isSet(object.personBlurConfig) ? PersonBlurConfig.fromJSON(object.personBlurConfig) : undefined,
      occupancyCountConfig: isSet(object.occupancyCountConfig)
        ? OccupancyCountConfig.fromJSON(object.occupancyCountConfig)
        : undefined,
      personVehicleDetectionConfig: isSet(object.personVehicleDetectionConfig)
        ? PersonVehicleDetectionConfig.fromJSON(object.personVehicleDetectionConfig)
        : undefined,
      vertexAutomlVisionConfig: isSet(object.vertexAutomlVisionConfig)
        ? VertexAutoMLVisionConfig.fromJSON(object.vertexAutomlVisionConfig)
        : undefined,
      vertexAutomlVideoConfig: isSet(object.vertexAutomlVideoConfig)
        ? VertexAutoMLVideoConfig.fromJSON(object.vertexAutomlVideoConfig)
        : undefined,
      vertexCustomConfig: isSet(object.vertexCustomConfig)
        ? VertexCustomConfig.fromJSON(object.vertexCustomConfig)
        : undefined,
      generalObjectDetectionConfig: isSet(object.generalObjectDetectionConfig)
        ? GeneralObjectDetectionConfig.fromJSON(object.generalObjectDetectionConfig)
        : undefined,
      bigQueryConfig: isSet(object.bigQueryConfig) ? BigQueryConfig.fromJSON(object.bigQueryConfig) : undefined,
      personalProtectiveEquipmentDetectionConfig: isSet(object.personalProtectiveEquipmentDetectionConfig)
        ? PersonalProtectiveEquipmentDetectionConfig.fromJSON(object.personalProtectiveEquipmentDetectionConfig)
        : undefined,
    };
  },

  toJSON(message: ProcessorConfig): unknown {
    const obj: any = {};
    if (message.videoStreamInputConfig !== undefined) {
      obj.videoStreamInputConfig = VideoStreamInputConfig.toJSON(message.videoStreamInputConfig);
    }
    if (message.aiEnabledDevicesInputConfig !== undefined) {
      obj.aiEnabledDevicesInputConfig = AIEnabledDevicesInputConfig.toJSON(message.aiEnabledDevicesInputConfig);
    }
    if (message.mediaWarehouseConfig !== undefined) {
      obj.mediaWarehouseConfig = MediaWarehouseConfig.toJSON(message.mediaWarehouseConfig);
    }
    if (message.personBlurConfig !== undefined) {
      obj.personBlurConfig = PersonBlurConfig.toJSON(message.personBlurConfig);
    }
    if (message.occupancyCountConfig !== undefined) {
      obj.occupancyCountConfig = OccupancyCountConfig.toJSON(message.occupancyCountConfig);
    }
    if (message.personVehicleDetectionConfig !== undefined) {
      obj.personVehicleDetectionConfig = PersonVehicleDetectionConfig.toJSON(message.personVehicleDetectionConfig);
    }
    if (message.vertexAutomlVisionConfig !== undefined) {
      obj.vertexAutomlVisionConfig = VertexAutoMLVisionConfig.toJSON(message.vertexAutomlVisionConfig);
    }
    if (message.vertexAutomlVideoConfig !== undefined) {
      obj.vertexAutomlVideoConfig = VertexAutoMLVideoConfig.toJSON(message.vertexAutomlVideoConfig);
    }
    if (message.vertexCustomConfig !== undefined) {
      obj.vertexCustomConfig = VertexCustomConfig.toJSON(message.vertexCustomConfig);
    }
    if (message.generalObjectDetectionConfig !== undefined) {
      obj.generalObjectDetectionConfig = GeneralObjectDetectionConfig.toJSON(message.generalObjectDetectionConfig);
    }
    if (message.bigQueryConfig !== undefined) {
      obj.bigQueryConfig = BigQueryConfig.toJSON(message.bigQueryConfig);
    }
    if (message.personalProtectiveEquipmentDetectionConfig !== undefined) {
      obj.personalProtectiveEquipmentDetectionConfig = PersonalProtectiveEquipmentDetectionConfig.toJSON(
        message.personalProtectiveEquipmentDetectionConfig,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorConfig>, I>>(base?: I): ProcessorConfig {
    return ProcessorConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorConfig>, I>>(object: I): ProcessorConfig {
    const message = createBaseProcessorConfig();
    message.videoStreamInputConfig =
      (object.videoStreamInputConfig !== undefined && object.videoStreamInputConfig !== null)
        ? VideoStreamInputConfig.fromPartial(object.videoStreamInputConfig)
        : undefined;
    message.aiEnabledDevicesInputConfig =
      (object.aiEnabledDevicesInputConfig !== undefined && object.aiEnabledDevicesInputConfig !== null)
        ? AIEnabledDevicesInputConfig.fromPartial(object.aiEnabledDevicesInputConfig)
        : undefined;
    message.mediaWarehouseConfig = (object.mediaWarehouseConfig !== undefined && object.mediaWarehouseConfig !== null)
      ? MediaWarehouseConfig.fromPartial(object.mediaWarehouseConfig)
      : undefined;
    message.personBlurConfig = (object.personBlurConfig !== undefined && object.personBlurConfig !== null)
      ? PersonBlurConfig.fromPartial(object.personBlurConfig)
      : undefined;
    message.occupancyCountConfig = (object.occupancyCountConfig !== undefined && object.occupancyCountConfig !== null)
      ? OccupancyCountConfig.fromPartial(object.occupancyCountConfig)
      : undefined;
    message.personVehicleDetectionConfig =
      (object.personVehicleDetectionConfig !== undefined && object.personVehicleDetectionConfig !== null)
        ? PersonVehicleDetectionConfig.fromPartial(object.personVehicleDetectionConfig)
        : undefined;
    message.vertexAutomlVisionConfig =
      (object.vertexAutomlVisionConfig !== undefined && object.vertexAutomlVisionConfig !== null)
        ? VertexAutoMLVisionConfig.fromPartial(object.vertexAutomlVisionConfig)
        : undefined;
    message.vertexAutomlVideoConfig =
      (object.vertexAutomlVideoConfig !== undefined && object.vertexAutomlVideoConfig !== null)
        ? VertexAutoMLVideoConfig.fromPartial(object.vertexAutomlVideoConfig)
        : undefined;
    message.vertexCustomConfig = (object.vertexCustomConfig !== undefined && object.vertexCustomConfig !== null)
      ? VertexCustomConfig.fromPartial(object.vertexCustomConfig)
      : undefined;
    message.generalObjectDetectionConfig =
      (object.generalObjectDetectionConfig !== undefined && object.generalObjectDetectionConfig !== null)
        ? GeneralObjectDetectionConfig.fromPartial(object.generalObjectDetectionConfig)
        : undefined;
    message.bigQueryConfig = (object.bigQueryConfig !== undefined && object.bigQueryConfig !== null)
      ? BigQueryConfig.fromPartial(object.bigQueryConfig)
      : undefined;
    message.personalProtectiveEquipmentDetectionConfig =
      (object.personalProtectiveEquipmentDetectionConfig !== undefined &&
          object.personalProtectiveEquipmentDetectionConfig !== null)
        ? PersonalProtectiveEquipmentDetectionConfig.fromPartial(object.personalProtectiveEquipmentDetectionConfig)
        : undefined;
    return message;
  },
};

function createBaseStreamWithAnnotation(): StreamWithAnnotation {
  return { stream: "", applicationAnnotations: [], nodeAnnotations: [] };
}

export const StreamWithAnnotation: MessageFns<StreamWithAnnotation> = {
  encode(message: StreamWithAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stream !== "") {
      writer.uint32(10).string(message.stream);
    }
    for (const v of message.applicationAnnotations) {
      StreamAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.nodeAnnotations) {
      StreamWithAnnotation_NodeAnnotation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamWithAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamWithAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stream = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.applicationAnnotations.push(StreamAnnotation.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeAnnotations.push(StreamWithAnnotation_NodeAnnotation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamWithAnnotation {
    return {
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      applicationAnnotations: globalThis.Array.isArray(object?.applicationAnnotations)
        ? object.applicationAnnotations.map((e: any) => StreamAnnotation.fromJSON(e))
        : [],
      nodeAnnotations: globalThis.Array.isArray(object?.nodeAnnotations)
        ? object.nodeAnnotations.map((e: any) => StreamWithAnnotation_NodeAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamWithAnnotation): unknown {
    const obj: any = {};
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.applicationAnnotations?.length) {
      obj.applicationAnnotations = message.applicationAnnotations.map((e) => StreamAnnotation.toJSON(e));
    }
    if (message.nodeAnnotations?.length) {
      obj.nodeAnnotations = message.nodeAnnotations.map((e) => StreamWithAnnotation_NodeAnnotation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamWithAnnotation>, I>>(base?: I): StreamWithAnnotation {
    return StreamWithAnnotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamWithAnnotation>, I>>(object: I): StreamWithAnnotation {
    const message = createBaseStreamWithAnnotation();
    message.stream = object.stream ?? "";
    message.applicationAnnotations = object.applicationAnnotations?.map((e) => StreamAnnotation.fromPartial(e)) || [];
    message.nodeAnnotations = object.nodeAnnotations?.map((e) => StreamWithAnnotation_NodeAnnotation.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseStreamWithAnnotation_NodeAnnotation(): StreamWithAnnotation_NodeAnnotation {
  return { node: "", annotations: [] };
}

export const StreamWithAnnotation_NodeAnnotation: MessageFns<StreamWithAnnotation_NodeAnnotation> = {
  encode(message: StreamWithAnnotation_NodeAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== "") {
      writer.uint32(10).string(message.node);
    }
    for (const v of message.annotations) {
      StreamAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamWithAnnotation_NodeAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamWithAnnotation_NodeAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotations.push(StreamAnnotation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamWithAnnotation_NodeAnnotation {
    return {
      node: isSet(object.node) ? globalThis.String(object.node) : "",
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => StreamAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamWithAnnotation_NodeAnnotation): unknown {
    const obj: any = {};
    if (message.node !== "") {
      obj.node = message.node;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => StreamAnnotation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamWithAnnotation_NodeAnnotation>, I>>(
    base?: I,
  ): StreamWithAnnotation_NodeAnnotation {
    return StreamWithAnnotation_NodeAnnotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamWithAnnotation_NodeAnnotation>, I>>(
    object: I,
  ): StreamWithAnnotation_NodeAnnotation {
    const message = createBaseStreamWithAnnotation_NodeAnnotation();
    message.node = object.node ?? "";
    message.annotations = object.annotations?.map((e) => StreamAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoStreamInputConfig(): VideoStreamInputConfig {
  return { streams: [], streamsWithAnnotation: [] };
}

export const VideoStreamInputConfig: MessageFns<VideoStreamInputConfig> = {
  encode(message: VideoStreamInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.streams) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.streamsWithAnnotation) {
      StreamWithAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoStreamInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoStreamInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.streams.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.streamsWithAnnotation.push(StreamWithAnnotation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoStreamInputConfig {
    return {
      streams: globalThis.Array.isArray(object?.streams) ? object.streams.map((e: any) => globalThis.String(e)) : [],
      streamsWithAnnotation: globalThis.Array.isArray(object?.streamsWithAnnotation)
        ? object.streamsWithAnnotation.map((e: any) => StreamWithAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoStreamInputConfig): unknown {
    const obj: any = {};
    if (message.streams?.length) {
      obj.streams = message.streams;
    }
    if (message.streamsWithAnnotation?.length) {
      obj.streamsWithAnnotation = message.streamsWithAnnotation.map((e) => StreamWithAnnotation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoStreamInputConfig>, I>>(base?: I): VideoStreamInputConfig {
    return VideoStreamInputConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoStreamInputConfig>, I>>(object: I): VideoStreamInputConfig {
    const message = createBaseVideoStreamInputConfig();
    message.streams = object.streams?.map((e) => e) || [];
    message.streamsWithAnnotation = object.streamsWithAnnotation?.map((e) => StreamWithAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAIEnabledDevicesInputConfig(): AIEnabledDevicesInputConfig {
  return {};
}

export const AIEnabledDevicesInputConfig: MessageFns<AIEnabledDevicesInputConfig> = {
  encode(_: AIEnabledDevicesInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AIEnabledDevicesInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAIEnabledDevicesInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AIEnabledDevicesInputConfig {
    return {};
  },

  toJSON(_: AIEnabledDevicesInputConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AIEnabledDevicesInputConfig>, I>>(base?: I): AIEnabledDevicesInputConfig {
    return AIEnabledDevicesInputConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AIEnabledDevicesInputConfig>, I>>(_: I): AIEnabledDevicesInputConfig {
    const message = createBaseAIEnabledDevicesInputConfig();
    return message;
  },
};

function createBaseMediaWarehouseConfig(): MediaWarehouseConfig {
  return { corpus: "", region: "", ttl: undefined };
}

export const MediaWarehouseConfig: MessageFns<MediaWarehouseConfig> = {
  encode(message: MediaWarehouseConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.corpus !== "") {
      writer.uint32(10).string(message.corpus);
    }
    if (message.region !== "") {
      writer.uint32(18).string(message.region);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaWarehouseConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaWarehouseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.corpus = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaWarehouseConfig {
    return {
      corpus: isSet(object.corpus) ? globalThis.String(object.corpus) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
    };
  },

  toJSON(message: MediaWarehouseConfig): unknown {
    const obj: any = {};
    if (message.corpus !== "") {
      obj.corpus = message.corpus;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MediaWarehouseConfig>, I>>(base?: I): MediaWarehouseConfig {
    return MediaWarehouseConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaWarehouseConfig>, I>>(object: I): MediaWarehouseConfig {
    const message = createBaseMediaWarehouseConfig();
    message.corpus = object.corpus ?? "";
    message.region = object.region ?? "";
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    return message;
  },
};

function createBasePersonBlurConfig(): PersonBlurConfig {
  return { personBlurType: 0, facesOnly: false };
}

export const PersonBlurConfig: MessageFns<PersonBlurConfig> = {
  encode(message: PersonBlurConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.personBlurType !== 0) {
      writer.uint32(8).int32(message.personBlurType);
    }
    if (message.facesOnly !== false) {
      writer.uint32(16).bool(message.facesOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonBlurConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonBlurConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.personBlurType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.facesOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonBlurConfig {
    return {
      personBlurType: isSet(object.personBlurType) ? personBlurConfig_PersonBlurTypeFromJSON(object.personBlurType) : 0,
      facesOnly: isSet(object.facesOnly) ? globalThis.Boolean(object.facesOnly) : false,
    };
  },

  toJSON(message: PersonBlurConfig): unknown {
    const obj: any = {};
    if (message.personBlurType !== 0) {
      obj.personBlurType = personBlurConfig_PersonBlurTypeToJSON(message.personBlurType);
    }
    if (message.facesOnly !== false) {
      obj.facesOnly = message.facesOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonBlurConfig>, I>>(base?: I): PersonBlurConfig {
    return PersonBlurConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonBlurConfig>, I>>(object: I): PersonBlurConfig {
    const message = createBasePersonBlurConfig();
    message.personBlurType = object.personBlurType ?? 0;
    message.facesOnly = object.facesOnly ?? false;
    return message;
  },
};

function createBaseOccupancyCountConfig(): OccupancyCountConfig {
  return { enablePeopleCounting: false, enableVehicleCounting: false, enableDwellingTimeTracking: false };
}

export const OccupancyCountConfig: MessageFns<OccupancyCountConfig> = {
  encode(message: OccupancyCountConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enablePeopleCounting !== false) {
      writer.uint32(8).bool(message.enablePeopleCounting);
    }
    if (message.enableVehicleCounting !== false) {
      writer.uint32(16).bool(message.enableVehicleCounting);
    }
    if (message.enableDwellingTimeTracking !== false) {
      writer.uint32(24).bool(message.enableDwellingTimeTracking);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enablePeopleCounting = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableVehicleCounting = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enableDwellingTimeTracking = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountConfig {
    return {
      enablePeopleCounting: isSet(object.enablePeopleCounting)
        ? globalThis.Boolean(object.enablePeopleCounting)
        : false,
      enableVehicleCounting: isSet(object.enableVehicleCounting)
        ? globalThis.Boolean(object.enableVehicleCounting)
        : false,
      enableDwellingTimeTracking: isSet(object.enableDwellingTimeTracking)
        ? globalThis.Boolean(object.enableDwellingTimeTracking)
        : false,
    };
  },

  toJSON(message: OccupancyCountConfig): unknown {
    const obj: any = {};
    if (message.enablePeopleCounting !== false) {
      obj.enablePeopleCounting = message.enablePeopleCounting;
    }
    if (message.enableVehicleCounting !== false) {
      obj.enableVehicleCounting = message.enableVehicleCounting;
    }
    if (message.enableDwellingTimeTracking !== false) {
      obj.enableDwellingTimeTracking = message.enableDwellingTimeTracking;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OccupancyCountConfig>, I>>(base?: I): OccupancyCountConfig {
    return OccupancyCountConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OccupancyCountConfig>, I>>(object: I): OccupancyCountConfig {
    const message = createBaseOccupancyCountConfig();
    message.enablePeopleCounting = object.enablePeopleCounting ?? false;
    message.enableVehicleCounting = object.enableVehicleCounting ?? false;
    message.enableDwellingTimeTracking = object.enableDwellingTimeTracking ?? false;
    return message;
  },
};

function createBasePersonVehicleDetectionConfig(): PersonVehicleDetectionConfig {
  return { enablePeopleCounting: false, enableVehicleCounting: false };
}

export const PersonVehicleDetectionConfig: MessageFns<PersonVehicleDetectionConfig> = {
  encode(message: PersonVehicleDetectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enablePeopleCounting !== false) {
      writer.uint32(8).bool(message.enablePeopleCounting);
    }
    if (message.enableVehicleCounting !== false) {
      writer.uint32(16).bool(message.enableVehicleCounting);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonVehicleDetectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonVehicleDetectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enablePeopleCounting = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableVehicleCounting = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonVehicleDetectionConfig {
    return {
      enablePeopleCounting: isSet(object.enablePeopleCounting)
        ? globalThis.Boolean(object.enablePeopleCounting)
        : false,
      enableVehicleCounting: isSet(object.enableVehicleCounting)
        ? globalThis.Boolean(object.enableVehicleCounting)
        : false,
    };
  },

  toJSON(message: PersonVehicleDetectionConfig): unknown {
    const obj: any = {};
    if (message.enablePeopleCounting !== false) {
      obj.enablePeopleCounting = message.enablePeopleCounting;
    }
    if (message.enableVehicleCounting !== false) {
      obj.enableVehicleCounting = message.enableVehicleCounting;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonVehicleDetectionConfig>, I>>(base?: I): PersonVehicleDetectionConfig {
    return PersonVehicleDetectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonVehicleDetectionConfig>, I>>(object: I): PersonVehicleDetectionConfig {
    const message = createBasePersonVehicleDetectionConfig();
    message.enablePeopleCounting = object.enablePeopleCounting ?? false;
    message.enableVehicleCounting = object.enableVehicleCounting ?? false;
    return message;
  },
};

function createBasePersonalProtectiveEquipmentDetectionConfig(): PersonalProtectiveEquipmentDetectionConfig {
  return {
    enableFaceCoverageDetection: false,
    enableHeadCoverageDetection: false,
    enableHandsCoverageDetection: false,
  };
}

export const PersonalProtectiveEquipmentDetectionConfig: MessageFns<PersonalProtectiveEquipmentDetectionConfig> = {
  encode(message: PersonalProtectiveEquipmentDetectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableFaceCoverageDetection !== false) {
      writer.uint32(8).bool(message.enableFaceCoverageDetection);
    }
    if (message.enableHeadCoverageDetection !== false) {
      writer.uint32(16).bool(message.enableHeadCoverageDetection);
    }
    if (message.enableHandsCoverageDetection !== false) {
      writer.uint32(24).bool(message.enableHandsCoverageDetection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalProtectiveEquipmentDetectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enableFaceCoverageDetection = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableHeadCoverageDetection = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enableHandsCoverageDetection = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionConfig {
    return {
      enableFaceCoverageDetection: isSet(object.enableFaceCoverageDetection)
        ? globalThis.Boolean(object.enableFaceCoverageDetection)
        : false,
      enableHeadCoverageDetection: isSet(object.enableHeadCoverageDetection)
        ? globalThis.Boolean(object.enableHeadCoverageDetection)
        : false,
      enableHandsCoverageDetection: isSet(object.enableHandsCoverageDetection)
        ? globalThis.Boolean(object.enableHandsCoverageDetection)
        : false,
    };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionConfig): unknown {
    const obj: any = {};
    if (message.enableFaceCoverageDetection !== false) {
      obj.enableFaceCoverageDetection = message.enableFaceCoverageDetection;
    }
    if (message.enableHeadCoverageDetection !== false) {
      obj.enableHeadCoverageDetection = message.enableHeadCoverageDetection;
    }
    if (message.enableHandsCoverageDetection !== false) {
      obj.enableHandsCoverageDetection = message.enableHandsCoverageDetection;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonalProtectiveEquipmentDetectionConfig>, I>>(
    base?: I,
  ): PersonalProtectiveEquipmentDetectionConfig {
    return PersonalProtectiveEquipmentDetectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonalProtectiveEquipmentDetectionConfig>, I>>(
    object: I,
  ): PersonalProtectiveEquipmentDetectionConfig {
    const message = createBasePersonalProtectiveEquipmentDetectionConfig();
    message.enableFaceCoverageDetection = object.enableFaceCoverageDetection ?? false;
    message.enableHeadCoverageDetection = object.enableHeadCoverageDetection ?? false;
    message.enableHandsCoverageDetection = object.enableHandsCoverageDetection ?? false;
    return message;
  },
};

function createBaseGeneralObjectDetectionConfig(): GeneralObjectDetectionConfig {
  return {};
}

export const GeneralObjectDetectionConfig: MessageFns<GeneralObjectDetectionConfig> = {
  encode(_: GeneralObjectDetectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneralObjectDetectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneralObjectDetectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GeneralObjectDetectionConfig {
    return {};
  },

  toJSON(_: GeneralObjectDetectionConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneralObjectDetectionConfig>, I>>(base?: I): GeneralObjectDetectionConfig {
    return GeneralObjectDetectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneralObjectDetectionConfig>, I>>(_: I): GeneralObjectDetectionConfig {
    const message = createBaseGeneralObjectDetectionConfig();
    return message;
  },
};

function createBaseBigQueryConfig(): BigQueryConfig {
  return { table: "", cloudFunctionMapping: {}, createDefaultTableIfNotExists: false };
}

export const BigQueryConfig: MessageFns<BigQueryConfig> = {
  encode(message: BigQueryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    Object.entries(message.cloudFunctionMapping).forEach(([key, value]) => {
      BigQueryConfig_CloudFunctionMappingEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.createDefaultTableIfNotExists !== false) {
      writer.uint32(24).bool(message.createDefaultTableIfNotExists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQueryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQueryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = BigQueryConfig_CloudFunctionMappingEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.cloudFunctionMapping[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createDefaultTableIfNotExists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQueryConfig {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      cloudFunctionMapping: isObject(object.cloudFunctionMapping)
        ? Object.entries(object.cloudFunctionMapping).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createDefaultTableIfNotExists: isSet(object.createDefaultTableIfNotExists)
        ? globalThis.Boolean(object.createDefaultTableIfNotExists)
        : false,
    };
  },

  toJSON(message: BigQueryConfig): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.cloudFunctionMapping) {
      const entries = Object.entries(message.cloudFunctionMapping);
      if (entries.length > 0) {
        obj.cloudFunctionMapping = {};
        entries.forEach(([k, v]) => {
          obj.cloudFunctionMapping[k] = v;
        });
      }
    }
    if (message.createDefaultTableIfNotExists !== false) {
      obj.createDefaultTableIfNotExists = message.createDefaultTableIfNotExists;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BigQueryConfig>, I>>(base?: I): BigQueryConfig {
    return BigQueryConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BigQueryConfig>, I>>(object: I): BigQueryConfig {
    const message = createBaseBigQueryConfig();
    message.table = object.table ?? "";
    message.cloudFunctionMapping = Object.entries(object.cloudFunctionMapping ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createDefaultTableIfNotExists = object.createDefaultTableIfNotExists ?? false;
    return message;
  },
};

function createBaseBigQueryConfig_CloudFunctionMappingEntry(): BigQueryConfig_CloudFunctionMappingEntry {
  return { key: "", value: "" };
}

export const BigQueryConfig_CloudFunctionMappingEntry: MessageFns<BigQueryConfig_CloudFunctionMappingEntry> = {
  encode(message: BigQueryConfig_CloudFunctionMappingEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQueryConfig_CloudFunctionMappingEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQueryConfig_CloudFunctionMappingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQueryConfig_CloudFunctionMappingEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BigQueryConfig_CloudFunctionMappingEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BigQueryConfig_CloudFunctionMappingEntry>, I>>(
    base?: I,
  ): BigQueryConfig_CloudFunctionMappingEntry {
    return BigQueryConfig_CloudFunctionMappingEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BigQueryConfig_CloudFunctionMappingEntry>, I>>(
    object: I,
  ): BigQueryConfig_CloudFunctionMappingEntry {
    const message = createBaseBigQueryConfig_CloudFunctionMappingEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVertexAutoMLVisionConfig(): VertexAutoMLVisionConfig {
  return { confidenceThreshold: 0, maxPredictions: 0 };
}

export const VertexAutoMLVisionConfig: MessageFns<VertexAutoMLVisionConfig> = {
  encode(message: VertexAutoMLVisionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confidenceThreshold !== 0) {
      writer.uint32(13).float(message.confidenceThreshold);
    }
    if (message.maxPredictions !== 0) {
      writer.uint32(16).int32(message.maxPredictions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexAutoMLVisionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexAutoMLVisionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.confidenceThreshold = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxPredictions = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexAutoMLVisionConfig {
    return {
      confidenceThreshold: isSet(object.confidenceThreshold) ? globalThis.Number(object.confidenceThreshold) : 0,
      maxPredictions: isSet(object.maxPredictions) ? globalThis.Number(object.maxPredictions) : 0,
    };
  },

  toJSON(message: VertexAutoMLVisionConfig): unknown {
    const obj: any = {};
    if (message.confidenceThreshold !== 0) {
      obj.confidenceThreshold = message.confidenceThreshold;
    }
    if (message.maxPredictions !== 0) {
      obj.maxPredictions = Math.round(message.maxPredictions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VertexAutoMLVisionConfig>, I>>(base?: I): VertexAutoMLVisionConfig {
    return VertexAutoMLVisionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VertexAutoMLVisionConfig>, I>>(object: I): VertexAutoMLVisionConfig {
    const message = createBaseVertexAutoMLVisionConfig();
    message.confidenceThreshold = object.confidenceThreshold ?? 0;
    message.maxPredictions = object.maxPredictions ?? 0;
    return message;
  },
};

function createBaseVertexAutoMLVideoConfig(): VertexAutoMLVideoConfig {
  return { confidenceThreshold: 0, blockedLabels: [], maxPredictions: 0, boundingBoxSizeLimit: 0 };
}

export const VertexAutoMLVideoConfig: MessageFns<VertexAutoMLVideoConfig> = {
  encode(message: VertexAutoMLVideoConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confidenceThreshold !== 0) {
      writer.uint32(13).float(message.confidenceThreshold);
    }
    for (const v of message.blockedLabels) {
      writer.uint32(18).string(v!);
    }
    if (message.maxPredictions !== 0) {
      writer.uint32(24).int32(message.maxPredictions);
    }
    if (message.boundingBoxSizeLimit !== 0) {
      writer.uint32(37).float(message.boundingBoxSizeLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexAutoMLVideoConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexAutoMLVideoConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.confidenceThreshold = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockedLabels.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxPredictions = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.boundingBoxSizeLimit = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexAutoMLVideoConfig {
    return {
      confidenceThreshold: isSet(object.confidenceThreshold) ? globalThis.Number(object.confidenceThreshold) : 0,
      blockedLabels: globalThis.Array.isArray(object?.blockedLabels)
        ? object.blockedLabels.map((e: any) => globalThis.String(e))
        : [],
      maxPredictions: isSet(object.maxPredictions) ? globalThis.Number(object.maxPredictions) : 0,
      boundingBoxSizeLimit: isSet(object.boundingBoxSizeLimit) ? globalThis.Number(object.boundingBoxSizeLimit) : 0,
    };
  },

  toJSON(message: VertexAutoMLVideoConfig): unknown {
    const obj: any = {};
    if (message.confidenceThreshold !== 0) {
      obj.confidenceThreshold = message.confidenceThreshold;
    }
    if (message.blockedLabels?.length) {
      obj.blockedLabels = message.blockedLabels;
    }
    if (message.maxPredictions !== 0) {
      obj.maxPredictions = Math.round(message.maxPredictions);
    }
    if (message.boundingBoxSizeLimit !== 0) {
      obj.boundingBoxSizeLimit = message.boundingBoxSizeLimit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VertexAutoMLVideoConfig>, I>>(base?: I): VertexAutoMLVideoConfig {
    return VertexAutoMLVideoConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VertexAutoMLVideoConfig>, I>>(object: I): VertexAutoMLVideoConfig {
    const message = createBaseVertexAutoMLVideoConfig();
    message.confidenceThreshold = object.confidenceThreshold ?? 0;
    message.blockedLabels = object.blockedLabels?.map((e) => e) || [];
    message.maxPredictions = object.maxPredictions ?? 0;
    message.boundingBoxSizeLimit = object.boundingBoxSizeLimit ?? 0;
    return message;
  },
};

function createBaseVertexCustomConfig(): VertexCustomConfig {
  return {
    maxPredictionFps: 0,
    dedicatedResources: undefined,
    postProcessingCloudFunction: "",
    attachApplicationMetadata: false,
  };
}

export const VertexCustomConfig: MessageFns<VertexCustomConfig> = {
  encode(message: VertexCustomConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxPredictionFps !== 0) {
      writer.uint32(8).int32(message.maxPredictionFps);
    }
    if (message.dedicatedResources !== undefined) {
      DedicatedResources.encode(message.dedicatedResources, writer.uint32(18).fork()).join();
    }
    if (message.postProcessingCloudFunction !== "") {
      writer.uint32(26).string(message.postProcessingCloudFunction);
    }
    if (message.attachApplicationMetadata !== false) {
      writer.uint32(32).bool(message.attachApplicationMetadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexCustomConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexCustomConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxPredictionFps = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dedicatedResources = DedicatedResources.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.postProcessingCloudFunction = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attachApplicationMetadata = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexCustomConfig {
    return {
      maxPredictionFps: isSet(object.maxPredictionFps) ? globalThis.Number(object.maxPredictionFps) : 0,
      dedicatedResources: isSet(object.dedicatedResources)
        ? DedicatedResources.fromJSON(object.dedicatedResources)
        : undefined,
      postProcessingCloudFunction: isSet(object.postProcessingCloudFunction)
        ? globalThis.String(object.postProcessingCloudFunction)
        : "",
      attachApplicationMetadata: isSet(object.attachApplicationMetadata)
        ? globalThis.Boolean(object.attachApplicationMetadata)
        : false,
    };
  },

  toJSON(message: VertexCustomConfig): unknown {
    const obj: any = {};
    if (message.maxPredictionFps !== 0) {
      obj.maxPredictionFps = Math.round(message.maxPredictionFps);
    }
    if (message.dedicatedResources !== undefined) {
      obj.dedicatedResources = DedicatedResources.toJSON(message.dedicatedResources);
    }
    if (message.postProcessingCloudFunction !== "") {
      obj.postProcessingCloudFunction = message.postProcessingCloudFunction;
    }
    if (message.attachApplicationMetadata !== false) {
      obj.attachApplicationMetadata = message.attachApplicationMetadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VertexCustomConfig>, I>>(base?: I): VertexCustomConfig {
    return VertexCustomConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VertexCustomConfig>, I>>(object: I): VertexCustomConfig {
    const message = createBaseVertexCustomConfig();
    message.maxPredictionFps = object.maxPredictionFps ?? 0;
    message.dedicatedResources = (object.dedicatedResources !== undefined && object.dedicatedResources !== null)
      ? DedicatedResources.fromPartial(object.dedicatedResources)
      : undefined;
    message.postProcessingCloudFunction = object.postProcessingCloudFunction ?? "";
    message.attachApplicationMetadata = object.attachApplicationMetadata ?? false;
    return message;
  },
};

function createBaseMachineSpec(): MachineSpec {
  return { machineType: "", acceleratorType: 0, acceleratorCount: 0 };
}

export const MachineSpec: MessageFns<MachineSpec> = {
  encode(message: MachineSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineType !== "") {
      writer.uint32(10).string(message.machineType);
    }
    if (message.acceleratorType !== 0) {
      writer.uint32(16).int32(message.acceleratorType);
    }
    if (message.acceleratorCount !== 0) {
      writer.uint32(24).int32(message.acceleratorCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MachineSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachineSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.acceleratorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.acceleratorCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MachineSpec {
    return {
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      acceleratorType: isSet(object.acceleratorType) ? acceleratorTypeFromJSON(object.acceleratorType) : 0,
      acceleratorCount: isSet(object.acceleratorCount) ? globalThis.Number(object.acceleratorCount) : 0,
    };
  },

  toJSON(message: MachineSpec): unknown {
    const obj: any = {};
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.acceleratorType !== 0) {
      obj.acceleratorType = acceleratorTypeToJSON(message.acceleratorType);
    }
    if (message.acceleratorCount !== 0) {
      obj.acceleratorCount = Math.round(message.acceleratorCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MachineSpec>, I>>(base?: I): MachineSpec {
    return MachineSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MachineSpec>, I>>(object: I): MachineSpec {
    const message = createBaseMachineSpec();
    message.machineType = object.machineType ?? "";
    message.acceleratorType = object.acceleratorType ?? 0;
    message.acceleratorCount = object.acceleratorCount ?? 0;
    return message;
  },
};

function createBaseAutoscalingMetricSpec(): AutoscalingMetricSpec {
  return { metricName: "", target: 0 };
}

export const AutoscalingMetricSpec: MessageFns<AutoscalingMetricSpec> = {
  encode(message: AutoscalingMetricSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    if (message.target !== 0) {
      writer.uint32(16).int32(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingMetricSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingMetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.target = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingMetricSpec {
    return {
      metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "",
      target: isSet(object.target) ? globalThis.Number(object.target) : 0,
    };
  },

  toJSON(message: AutoscalingMetricSpec): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    if (message.target !== 0) {
      obj.target = Math.round(message.target);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AutoscalingMetricSpec>, I>>(base?: I): AutoscalingMetricSpec {
    return AutoscalingMetricSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AutoscalingMetricSpec>, I>>(object: I): AutoscalingMetricSpec {
    const message = createBaseAutoscalingMetricSpec();
    message.metricName = object.metricName ?? "";
    message.target = object.target ?? 0;
    return message;
  },
};

function createBaseDedicatedResources(): DedicatedResources {
  return { machineSpec: undefined, minReplicaCount: 0, maxReplicaCount: 0, autoscalingMetricSpecs: [] };
}

export const DedicatedResources: MessageFns<DedicatedResources> = {
  encode(message: DedicatedResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineSpec !== undefined) {
      MachineSpec.encode(message.machineSpec, writer.uint32(10).fork()).join();
    }
    if (message.minReplicaCount !== 0) {
      writer.uint32(16).int32(message.minReplicaCount);
    }
    if (message.maxReplicaCount !== 0) {
      writer.uint32(24).int32(message.maxReplicaCount);
    }
    for (const v of message.autoscalingMetricSpecs) {
      AutoscalingMetricSpec.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DedicatedResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDedicatedResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.machineSpec = MachineSpec.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minReplicaCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxReplicaCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.autoscalingMetricSpecs.push(AutoscalingMetricSpec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DedicatedResources {
    return {
      machineSpec: isSet(object.machineSpec) ? MachineSpec.fromJSON(object.machineSpec) : undefined,
      minReplicaCount: isSet(object.minReplicaCount) ? globalThis.Number(object.minReplicaCount) : 0,
      maxReplicaCount: isSet(object.maxReplicaCount) ? globalThis.Number(object.maxReplicaCount) : 0,
      autoscalingMetricSpecs: globalThis.Array.isArray(object?.autoscalingMetricSpecs)
        ? object.autoscalingMetricSpecs.map((e: any) => AutoscalingMetricSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DedicatedResources): unknown {
    const obj: any = {};
    if (message.machineSpec !== undefined) {
      obj.machineSpec = MachineSpec.toJSON(message.machineSpec);
    }
    if (message.minReplicaCount !== 0) {
      obj.minReplicaCount = Math.round(message.minReplicaCount);
    }
    if (message.maxReplicaCount !== 0) {
      obj.maxReplicaCount = Math.round(message.maxReplicaCount);
    }
    if (message.autoscalingMetricSpecs?.length) {
      obj.autoscalingMetricSpecs = message.autoscalingMetricSpecs.map((e) => AutoscalingMetricSpec.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DedicatedResources>, I>>(base?: I): DedicatedResources {
    return DedicatedResources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DedicatedResources>, I>>(object: I): DedicatedResources {
    const message = createBaseDedicatedResources();
    message.machineSpec = (object.machineSpec !== undefined && object.machineSpec !== null)
      ? MachineSpec.fromPartial(object.machineSpec)
      : undefined;
    message.minReplicaCount = object.minReplicaCount ?? 0;
    message.maxReplicaCount = object.maxReplicaCount ?? 0;
    message.autoscalingMetricSpecs = object.autoscalingMetricSpecs?.map((e) => AutoscalingMetricSpec.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseStream(): Stream {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    annotations: {},
    displayName: "",
    enableHlsPlayback: false,
    mediaWarehouseAsset: "",
  };
}

export const Stream: MessageFns<Stream> = {
  encode(message: Stream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Stream_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      Stream_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    if (message.enableHlsPlayback !== false) {
      writer.uint32(56).bool(message.enableHlsPlayback);
    }
    if (message.mediaWarehouseAsset !== "") {
      writer.uint32(66).string(message.mediaWarehouseAsset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Stream_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = Stream_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.enableHlsPlayback = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mediaWarehouseAsset = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stream {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      enableHlsPlayback: isSet(object.enableHlsPlayback) ? globalThis.Boolean(object.enableHlsPlayback) : false,
      mediaWarehouseAsset: isSet(object.mediaWarehouseAsset) ? globalThis.String(object.mediaWarehouseAsset) : "",
    };
  },

  toJSON(message: Stream): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.enableHlsPlayback !== false) {
      obj.enableHlsPlayback = message.enableHlsPlayback;
    }
    if (message.mediaWarehouseAsset !== "") {
      obj.mediaWarehouseAsset = message.mediaWarehouseAsset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stream>, I>>(base?: I): Stream {
    return Stream.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stream>, I>>(object: I): Stream {
    const message = createBaseStream();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.displayName = object.displayName ?? "";
    message.enableHlsPlayback = object.enableHlsPlayback ?? false;
    message.mediaWarehouseAsset = object.mediaWarehouseAsset ?? "";
    return message;
  },
};

function createBaseStream_LabelsEntry(): Stream_LabelsEntry {
  return { key: "", value: "" };
}

export const Stream_LabelsEntry: MessageFns<Stream_LabelsEntry> = {
  encode(message: Stream_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stream_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stream_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Stream_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stream_LabelsEntry>, I>>(base?: I): Stream_LabelsEntry {
    return Stream_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stream_LabelsEntry>, I>>(object: I): Stream_LabelsEntry {
    const message = createBaseStream_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStream_AnnotationsEntry(): Stream_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Stream_AnnotationsEntry: MessageFns<Stream_AnnotationsEntry> = {
  encode(message: Stream_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stream_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stream_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Stream_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stream_AnnotationsEntry>, I>>(base?: I): Stream_AnnotationsEntry {
    return Stream_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stream_AnnotationsEntry>, I>>(object: I): Stream_AnnotationsEntry {
    const message = createBaseStream_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    annotations: {},
    alignmentClock: 0,
    gracePeriod: undefined,
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Event_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      Event_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.alignmentClock !== 0) {
      writer.uint32(48).int32(message.alignmentClock);
    }
    if (message.gracePeriod !== undefined) {
      Duration.encode(message.gracePeriod, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Event_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = Event_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.alignmentClock = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gracePeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      alignmentClock: isSet(object.alignmentClock) ? event_ClockFromJSON(object.alignmentClock) : 0,
      gracePeriod: isSet(object.gracePeriod) ? Duration.fromJSON(object.gracePeriod) : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.alignmentClock !== 0) {
      obj.alignmentClock = event_ClockToJSON(message.alignmentClock);
    }
    if (message.gracePeriod !== undefined) {
      obj.gracePeriod = Duration.toJSON(message.gracePeriod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.alignmentClock = object.alignmentClock ?? 0;
    message.gracePeriod = (object.gracePeriod !== undefined && object.gracePeriod !== null)
      ? Duration.fromPartial(object.gracePeriod)
      : undefined;
    return message;
  },
};

function createBaseEvent_LabelsEntry(): Event_LabelsEntry {
  return { key: "", value: "" };
}

export const Event_LabelsEntry: MessageFns<Event_LabelsEntry> = {
  encode(message: Event_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Event_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event_LabelsEntry>, I>>(base?: I): Event_LabelsEntry {
    return Event_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event_LabelsEntry>, I>>(object: I): Event_LabelsEntry {
    const message = createBaseEvent_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEvent_AnnotationsEntry(): Event_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Event_AnnotationsEntry: MessageFns<Event_AnnotationsEntry> = {
  encode(message: Event_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Event_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event_AnnotationsEntry>, I>>(base?: I): Event_AnnotationsEntry {
    return Event_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event_AnnotationsEntry>, I>>(object: I): Event_AnnotationsEntry {
    const message = createBaseEvent_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSeries(): Series {
  return { name: "", createTime: undefined, updateTime: undefined, labels: {}, annotations: {}, stream: "", event: "" };
}

export const Series: MessageFns<Series> = {
  encode(message: Series, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Series_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      Series_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.stream !== "") {
      writer.uint32(50).string(message.stream);
    }
    if (message.event !== "") {
      writer.uint32(58).string(message.event);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Series {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Series_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = Series_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stream = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.event = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Series {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      event: isSet(object.event) ? globalThis.String(object.event) : "",
    };
  },

  toJSON(message: Series): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.event !== "") {
      obj.event = message.event;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Series>, I>>(base?: I): Series {
    return Series.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Series>, I>>(object: I): Series {
    const message = createBaseSeries();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.stream = object.stream ?? "";
    message.event = object.event ?? "";
    return message;
  },
};

function createBaseSeries_LabelsEntry(): Series_LabelsEntry {
  return { key: "", value: "" };
}

export const Series_LabelsEntry: MessageFns<Series_LabelsEntry> = {
  encode(message: Series_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Series_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeries_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Series_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Series_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Series_LabelsEntry>, I>>(base?: I): Series_LabelsEntry {
    return Series_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Series_LabelsEntry>, I>>(object: I): Series_LabelsEntry {
    const message = createBaseSeries_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSeries_AnnotationsEntry(): Series_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Series_AnnotationsEntry: MessageFns<Series_AnnotationsEntry> = {
  encode(message: Series_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Series_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeries_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Series_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Series_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Series_AnnotationsEntry>, I>>(base?: I): Series_AnnotationsEntry {
    return Series_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Series_AnnotationsEntry>, I>>(object: I): Series_AnnotationsEntry {
    const message = createBaseSeries_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSeriesEventData(): SeriesEventData {
  return { payload: undefined };
}

export const SeriesEventData: MessageFns<SeriesEventData> = {
  encode(message: SeriesEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Series.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SeriesEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeriesEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Series.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SeriesEventData {
    return { payload: isSet(object.payload) ? Series.fromJSON(object.payload) : undefined };
  },

  toJSON(message: SeriesEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Series.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SeriesEventData>, I>>(base?: I): SeriesEventData {
    return SeriesEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SeriesEventData>, I>>(object: I): SeriesEventData {
    const message = createBaseSeriesEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Series.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseDraftEventData(): DraftEventData {
  return { payload: undefined };
}

export const DraftEventData: MessageFns<DraftEventData> = {
  encode(message: DraftEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Draft.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DraftEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraftEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Draft.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DraftEventData {
    return { payload: isSet(object.payload) ? Draft.fromJSON(object.payload) : undefined };
  },

  toJSON(message: DraftEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Draft.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DraftEventData>, I>>(base?: I): DraftEventData {
    return DraftEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DraftEventData>, I>>(object: I): DraftEventData {
    const message = createBaseDraftEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Draft.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseProcessorEventData(): ProcessorEventData {
  return { payload: undefined };
}

export const ProcessorEventData: MessageFns<ProcessorEventData> = {
  encode(message: ProcessorEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Processor.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Processor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorEventData {
    return { payload: isSet(object.payload) ? Processor.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ProcessorEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Processor.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorEventData>, I>>(base?: I): ProcessorEventData {
    return ProcessorEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorEventData>, I>>(object: I): ProcessorEventData {
    const message = createBaseProcessorEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Processor.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseAnalysisEventData(): AnalysisEventData {
  return { payload: undefined };
}

export const AnalysisEventData: MessageFns<AnalysisEventData> = {
  encode(message: AnalysisEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Analysis.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Analysis.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisEventData {
    return { payload: isSet(object.payload) ? Analysis.fromJSON(object.payload) : undefined };
  },

  toJSON(message: AnalysisEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Analysis.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalysisEventData>, I>>(base?: I): AnalysisEventData {
    return AnalysisEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalysisEventData>, I>>(object: I): AnalysisEventData {
    const message = createBaseAnalysisEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Analysis.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseClusterEventData(): ClusterEventData {
  return { payload: undefined };
}

export const ClusterEventData: MessageFns<ClusterEventData> = {
  encode(message: ClusterEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Cluster.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Cluster.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterEventData {
    return { payload: isSet(object.payload) ? Cluster.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ClusterEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Cluster.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterEventData>, I>>(base?: I): ClusterEventData {
    return ClusterEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterEventData>, I>>(object: I): ClusterEventData {
    const message = createBaseClusterEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Cluster.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseEventEventData(): EventEventData {
  return { payload: undefined };
}

export const EventEventData: MessageFns<EventEventData> = {
  encode(message: EventEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Event.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Event.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEventData {
    return { payload: isSet(object.payload) ? Event.fromJSON(object.payload) : undefined };
  },

  toJSON(message: EventEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Event.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventEventData>, I>>(base?: I): EventEventData {
    return EventEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventEventData>, I>>(object: I): EventEventData {
    const message = createBaseEventEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Event.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseProcessEventData(): ProcessEventData {
  return { payload: undefined };
}

export const ProcessEventData: MessageFns<ProcessEventData> = {
  encode(message: ProcessEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Process.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Process.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessEventData {
    return { payload: isSet(object.payload) ? Process.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ProcessEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Process.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessEventData>, I>>(base?: I): ProcessEventData {
    return ProcessEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessEventData>, I>>(object: I): ProcessEventData {
    const message = createBaseProcessEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Process.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseStreamEventData(): StreamEventData {
  return { payload: undefined };
}

export const StreamEventData: MessageFns<StreamEventData> = {
  encode(message: StreamEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Stream.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Stream.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamEventData {
    return { payload: isSet(object.payload) ? Stream.fromJSON(object.payload) : undefined };
  },

  toJSON(message: StreamEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Stream.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamEventData>, I>>(base?: I): StreamEventData {
    return StreamEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamEventData>, I>>(object: I): StreamEventData {
    const message = createBaseStreamEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Stream.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseApplicationEventData(): ApplicationEventData {
  return { payload: undefined };
}

export const ApplicationEventData: MessageFns<ApplicationEventData> = {
  encode(message: ApplicationEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Application.encode(message.payload, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = Application.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationEventData {
    return { payload: isSet(object.payload) ? Application.fromJSON(object.payload) : undefined };
  },

  toJSON(message: ApplicationEventData): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = Application.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplicationEventData>, I>>(base?: I): ApplicationEventData {
    return ApplicationEventData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationEventData>, I>>(object: I): ApplicationEventData {
    const message = createBaseApplicationEventData();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Application.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
