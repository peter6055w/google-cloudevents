// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/firebase/analytics/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.events.firebase.analytics.v1";

/** The data within Firebase Analytics log events. */
export interface AnalyticsLogData {
  /** User related dimensions. */
  userDim?:
    | UserDimensions
    | undefined;
  /** A repeated record of event related dimensions. */
  eventDim: EventDimensions[];
}

/** Message containing information about the user associated with the event. */
export interface UserDimensions {
  /** The user ID set via the setUserId API. */
  userId: string;
  /** The time (in microseconds) at which the user first opened the app. */
  firstOpenTimestampMicros: Long;
  /**
   * A repeated record of user properties set with the setUserProperty API.
   * https://firebase.google.com/docs/analytics/android/properties
   */
  userProperties: { [key: string]: UserPropertyValue };
  /** Device information. */
  deviceInfo?:
    | DeviceInfo
    | undefined;
  /** User's geographic information. */
  geoInfo?:
    | GeoInfo
    | undefined;
  /** App information. */
  appInfo?:
    | AppInfo
    | undefined;
  /** Information about marketing campaign which acquired the user. */
  trafficSource?:
    | TrafficSource
    | undefined;
  /** Information regarding the bundle in which these events were uploaded. */
  bundleInfo?:
    | ExportBundleInfo
    | undefined;
  /** Lifetime Value information about this user. */
  ltvInfo?: LtvInfo | undefined;
}

export interface UserDimensions_UserPropertiesEntry {
  key: string;
  value?: UserPropertyValue | undefined;
}

/**
 * Predefined (eg: LTV) or custom properties (eg: birthday) stored on client
 * side and associated with subsequent HitBundles.
 */
export interface UserPropertyValue {
  /** Last set value of user property. */
  value?:
    | AnalyticsValue
    | undefined;
  /** UTC client time when user property was last set. */
  setTimestampUsec: Long;
  /** Index for user property (one-based). */
  index: number;
}

/**
 * Value for Event Params and UserProperty can be of type string or int or
 * float or double.
 */
export interface AnalyticsValue {
  stringValue?: string | undefined;
  intValue?: Long | undefined;
  floatValue?: number | undefined;
  doubleValue?: number | undefined;
}

/** Message containing device informations. */
export interface DeviceInfo {
  /**
   * Device category.
   * Eg. tablet or mobile.
   */
  deviceCategory: string;
  /**
   * Device brand name.
   * Eg. Samsung, HTC, etc.
   */
  mobileBrandName: string;
  /**
   * Device model name.
   * Eg. GT-I9192
   */
  mobileModelName: string;
  /**
   * Device marketing name.
   * Eg. Galaxy S4 Mini
   */
  mobileMarketingName: string;
  /**
   * Device model.
   * Eg. GT-I9192
   */
  deviceModel: string;
  /**
   * Device OS version when data capture ended.
   * Eg. 4.4.2
   */
  platformVersion: string;
  /**
   * Vendor specific device identifier. This is IDFV on iOS. Not used for
   * Android.
   * Example: "599F9C00-92DC-4B5C-9464-7971F01F8370"
   */
  deviceId: string;
  /**
   * The type of the resettable_device_id is always IDFA on iOS and AdId
   * on Android.
   * Example: "71683BF9-FA3B-4B0D-9535-A1F05188BAF3"
   */
  resettableDeviceId: string;
  /**
   * The user language.
   * Eg. "en-us", "en-za", "zh-tw", "jp"
   */
  userDefaultLanguage: string;
  /** The timezone of the device when data was uploaded as seconds skew from UTC. */
  deviceTimeZoneOffsetSeconds: number;
  /**
   * The device's Limit Ad Tracking setting.
   * When true, we cannot use device_id for remarketing, demographics or
   * influencing ads serving behaviour. However, we can use device_id for
   * conversion tracking and campaign attribution.
   */
  limitedAdTracking: boolean;
}

/** Message which contains App Information. */
export interface AppInfo {
  /**
   * The app's version name
   * Examples: "1.0", "4.3.1.1.213361", "2.3 (1824253)", "v1.8b22p6"
   */
  appVersion: string;
  /**
   * Unique id for this instance of the app.
   * Example: "71683BF9FA3B4B0D9535A1F05188BAF3"
   */
  appInstanceId: string;
  /**
   * The identifier of the store that installed the app.
   * Eg. "com.sec.android.app.samsungapps", "com.amazon.venezia",
   * "com.nokia.nstore"
   */
  appStore: string;
  /**
   * The app platform.
   * Eg "ANDROID", "IOS".
   */
  appPlatform: string;
  /** Unique application identifier within an app store. */
  appId: string;
}

/** User's geographic informaiton. */
export interface GeoInfo {
  /**
   * The geographic continent.
   * Eg. Americas
   */
  continent: string;
  /**
   * The geographic country.
   * Eg. Brazil
   */
  country: string;
  /**
   * The geographic region.
   * Eg. State of Sao Paulo
   */
  region: string;
  /**
   * The geographic city.
   * Eg. Sao Paulo
   */
  city: string;
}

/** Mesage containing marketing campaign information which acquired the user. */
export interface TrafficSource {
  /** The name of the campaign which acquired the user. */
  userAcquiredCampaign: string;
  /** The name of the network which acquired the user. */
  userAcquiredSource: string;
  /** The name of the medium which acquired the user. */
  userAcquiredMedium: string;
}

/**
 * Message containing information regarding the bundle in which these
 * events were uploaded.
 */
export interface ExportBundleInfo {
  /** Monotonically increasing index for each bundle set by SDK. */
  bundleSequenceId: number;
  /** Timestamp offset between collection time and upload time. */
  serverTimestampOffsetMicros: Long;
}

/** Lifetime Value information about this user. */
export interface LtvInfo {
  /** The Lifetime Value revenue of this user. */
  revenue: number;
  /** The currency corresponding to the revenue. */
  currency: string;
}

/** Message containing information pertaining to the event. */
export interface EventDimensions {
  /**
   * The date on which this event was logged.
   * (YYYYMMDD format in the registered timezone of your app.)
   */
  date: string;
  /** The name of this event. */
  name: string;
  /** A repeated record of the parameters associated with this event. */
  params: { [key: string]: AnalyticsValue };
  /** UTC client time when the event happened. */
  timestampMicros: Long;
  /** UTC client time when the previous event happened. */
  previousTimestampMicros: Long;
  /** Value param in USD. */
  valueInUsd: number;
}

export interface EventDimensions_ParamsEntry {
  key: string;
  value?: AnalyticsValue | undefined;
}

function createBaseAnalyticsLogData(): AnalyticsLogData {
  return { userDim: undefined, eventDim: [] };
}

export const AnalyticsLogData: MessageFns<AnalyticsLogData> = {
  encode(message: AnalyticsLogData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userDim !== undefined) {
      UserDimensions.encode(message.userDim, writer.uint32(10).fork()).join();
    }
    for (const v of message.eventDim) {
      EventDimensions.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyticsLogData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyticsLogData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userDim = UserDimensions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventDim.push(EventDimensions.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyticsLogData {
    return {
      userDim: isSet(object.userDim) ? UserDimensions.fromJSON(object.userDim) : undefined,
      eventDim: globalThis.Array.isArray(object?.eventDim)
        ? object.eventDim.map((e: any) => EventDimensions.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnalyticsLogData): unknown {
    const obj: any = {};
    if (message.userDim !== undefined) {
      obj.userDim = UserDimensions.toJSON(message.userDim);
    }
    if (message.eventDim?.length) {
      obj.eventDim = message.eventDim.map((e) => EventDimensions.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyticsLogData>, I>>(base?: I): AnalyticsLogData {
    return AnalyticsLogData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyticsLogData>, I>>(object: I): AnalyticsLogData {
    const message = createBaseAnalyticsLogData();
    message.userDim = (object.userDim !== undefined && object.userDim !== null)
      ? UserDimensions.fromPartial(object.userDim)
      : undefined;
    message.eventDim = object.eventDim?.map((e) => EventDimensions.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserDimensions(): UserDimensions {
  return {
    userId: "",
    firstOpenTimestampMicros: Long.ZERO,
    userProperties: {},
    deviceInfo: undefined,
    geoInfo: undefined,
    appInfo: undefined,
    trafficSource: undefined,
    bundleInfo: undefined,
    ltvInfo: undefined,
  };
}

export const UserDimensions: MessageFns<UserDimensions> = {
  encode(message: UserDimensions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (!message.firstOpenTimestampMicros.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.firstOpenTimestampMicros.toString());
    }
    Object.entries(message.userProperties).forEach(([key, value]) => {
      UserDimensions_UserPropertiesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.deviceInfo !== undefined) {
      DeviceInfo.encode(message.deviceInfo, writer.uint32(34).fork()).join();
    }
    if (message.geoInfo !== undefined) {
      GeoInfo.encode(message.geoInfo, writer.uint32(42).fork()).join();
    }
    if (message.appInfo !== undefined) {
      AppInfo.encode(message.appInfo, writer.uint32(50).fork()).join();
    }
    if (message.trafficSource !== undefined) {
      TrafficSource.encode(message.trafficSource, writer.uint32(58).fork()).join();
    }
    if (message.bundleInfo !== undefined) {
      ExportBundleInfo.encode(message.bundleInfo, writer.uint32(66).fork()).join();
    }
    if (message.ltvInfo !== undefined) {
      LtvInfo.encode(message.ltvInfo, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserDimensions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.firstOpenTimestampMicros = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = UserDimensions_UserPropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.userProperties[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deviceInfo = DeviceInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.geoInfo = GeoInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.appInfo = AppInfo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.trafficSource = TrafficSource.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bundleInfo = ExportBundleInfo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ltvInfo = LtvInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDimensions {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      firstOpenTimestampMicros: isSet(object.firstOpenTimestampMicros)
        ? Long.fromValue(object.firstOpenTimestampMicros)
        : Long.ZERO,
      userProperties: isObject(object.userProperties)
        ? Object.entries(object.userProperties).reduce<{ [key: string]: UserPropertyValue }>((acc, [key, value]) => {
          acc[key] = UserPropertyValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      deviceInfo: isSet(object.deviceInfo) ? DeviceInfo.fromJSON(object.deviceInfo) : undefined,
      geoInfo: isSet(object.geoInfo) ? GeoInfo.fromJSON(object.geoInfo) : undefined,
      appInfo: isSet(object.appInfo) ? AppInfo.fromJSON(object.appInfo) : undefined,
      trafficSource: isSet(object.trafficSource) ? TrafficSource.fromJSON(object.trafficSource) : undefined,
      bundleInfo: isSet(object.bundleInfo) ? ExportBundleInfo.fromJSON(object.bundleInfo) : undefined,
      ltvInfo: isSet(object.ltvInfo) ? LtvInfo.fromJSON(object.ltvInfo) : undefined,
    };
  },

  toJSON(message: UserDimensions): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (!message.firstOpenTimestampMicros.equals(Long.ZERO)) {
      obj.firstOpenTimestampMicros = (message.firstOpenTimestampMicros || Long.ZERO).toString();
    }
    if (message.userProperties) {
      const entries = Object.entries(message.userProperties);
      if (entries.length > 0) {
        obj.userProperties = {};
        entries.forEach(([k, v]) => {
          obj.userProperties[k] = UserPropertyValue.toJSON(v);
        });
      }
    }
    if (message.deviceInfo !== undefined) {
      obj.deviceInfo = DeviceInfo.toJSON(message.deviceInfo);
    }
    if (message.geoInfo !== undefined) {
      obj.geoInfo = GeoInfo.toJSON(message.geoInfo);
    }
    if (message.appInfo !== undefined) {
      obj.appInfo = AppInfo.toJSON(message.appInfo);
    }
    if (message.trafficSource !== undefined) {
      obj.trafficSource = TrafficSource.toJSON(message.trafficSource);
    }
    if (message.bundleInfo !== undefined) {
      obj.bundleInfo = ExportBundleInfo.toJSON(message.bundleInfo);
    }
    if (message.ltvInfo !== undefined) {
      obj.ltvInfo = LtvInfo.toJSON(message.ltvInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDimensions>, I>>(base?: I): UserDimensions {
    return UserDimensions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDimensions>, I>>(object: I): UserDimensions {
    const message = createBaseUserDimensions();
    message.userId = object.userId ?? "";
    message.firstOpenTimestampMicros =
      (object.firstOpenTimestampMicros !== undefined && object.firstOpenTimestampMicros !== null)
        ? Long.fromValue(object.firstOpenTimestampMicros)
        : Long.ZERO;
    message.userProperties = Object.entries(object.userProperties ?? {}).reduce<{ [key: string]: UserPropertyValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = UserPropertyValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.deviceInfo = (object.deviceInfo !== undefined && object.deviceInfo !== null)
      ? DeviceInfo.fromPartial(object.deviceInfo)
      : undefined;
    message.geoInfo = (object.geoInfo !== undefined && object.geoInfo !== null)
      ? GeoInfo.fromPartial(object.geoInfo)
      : undefined;
    message.appInfo = (object.appInfo !== undefined && object.appInfo !== null)
      ? AppInfo.fromPartial(object.appInfo)
      : undefined;
    message.trafficSource = (object.trafficSource !== undefined && object.trafficSource !== null)
      ? TrafficSource.fromPartial(object.trafficSource)
      : undefined;
    message.bundleInfo = (object.bundleInfo !== undefined && object.bundleInfo !== null)
      ? ExportBundleInfo.fromPartial(object.bundleInfo)
      : undefined;
    message.ltvInfo = (object.ltvInfo !== undefined && object.ltvInfo !== null)
      ? LtvInfo.fromPartial(object.ltvInfo)
      : undefined;
    return message;
  },
};

function createBaseUserDimensions_UserPropertiesEntry(): UserDimensions_UserPropertiesEntry {
  return { key: "", value: undefined };
}

export const UserDimensions_UserPropertiesEntry: MessageFns<UserDimensions_UserPropertiesEntry> = {
  encode(message: UserDimensions_UserPropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      UserPropertyValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserDimensions_UserPropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDimensions_UserPropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = UserPropertyValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDimensions_UserPropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? UserPropertyValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UserDimensions_UserPropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = UserPropertyValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDimensions_UserPropertiesEntry>, I>>(
    base?: I,
  ): UserDimensions_UserPropertiesEntry {
    return UserDimensions_UserPropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDimensions_UserPropertiesEntry>, I>>(
    object: I,
  ): UserDimensions_UserPropertiesEntry {
    const message = createBaseUserDimensions_UserPropertiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? UserPropertyValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUserPropertyValue(): UserPropertyValue {
  return { value: undefined, setTimestampUsec: Long.ZERO, index: 0 };
}

export const UserPropertyValue: MessageFns<UserPropertyValue> = {
  encode(message: UserPropertyValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      AnalyticsValue.encode(message.value, writer.uint32(10).fork()).join();
    }
    if (!message.setTimestampUsec.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.setTimestampUsec.toString());
    }
    if (message.index !== 0) {
      writer.uint32(24).int32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserPropertyValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPropertyValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = AnalyticsValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setTimestampUsec = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPropertyValue {
    return {
      value: isSet(object.value) ? AnalyticsValue.fromJSON(object.value) : undefined,
      setTimestampUsec: isSet(object.setTimestampUsec) ? Long.fromValue(object.setTimestampUsec) : Long.ZERO,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: UserPropertyValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = AnalyticsValue.toJSON(message.value);
    }
    if (!message.setTimestampUsec.equals(Long.ZERO)) {
      obj.setTimestampUsec = (message.setTimestampUsec || Long.ZERO).toString();
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPropertyValue>, I>>(base?: I): UserPropertyValue {
    return UserPropertyValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPropertyValue>, I>>(object: I): UserPropertyValue {
    const message = createBaseUserPropertyValue();
    message.value = (object.value !== undefined && object.value !== null)
      ? AnalyticsValue.fromPartial(object.value)
      : undefined;
    message.setTimestampUsec = (object.setTimestampUsec !== undefined && object.setTimestampUsec !== null)
      ? Long.fromValue(object.setTimestampUsec)
      : Long.ZERO;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseAnalyticsValue(): AnalyticsValue {
  return { stringValue: undefined, intValue: undefined, floatValue: undefined, doubleValue: undefined };
}

export const AnalyticsValue: MessageFns<AnalyticsValue> = {
  encode(message: AnalyticsValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int64(message.intValue.toString());
    }
    if (message.floatValue !== undefined) {
      writer.uint32(29).float(message.floatValue);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(33).double(message.doubleValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyticsValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyticsValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.floatValue = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyticsValue {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
    };
  },

  toJSON(message: AnalyticsValue): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.floatValue !== undefined) {
      obj.floatValue = message.floatValue;
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyticsValue>, I>>(base?: I): AnalyticsValue {
    return AnalyticsValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyticsValue>, I>>(object: I): AnalyticsValue {
    const message = createBaseAnalyticsValue();
    message.stringValue = object.stringValue ?? undefined;
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.floatValue = object.floatValue ?? undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    return message;
  },
};

function createBaseDeviceInfo(): DeviceInfo {
  return {
    deviceCategory: "",
    mobileBrandName: "",
    mobileModelName: "",
    mobileMarketingName: "",
    deviceModel: "",
    platformVersion: "",
    deviceId: "",
    resettableDeviceId: "",
    userDefaultLanguage: "",
    deviceTimeZoneOffsetSeconds: 0,
    limitedAdTracking: false,
  };
}

export const DeviceInfo: MessageFns<DeviceInfo> = {
  encode(message: DeviceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceCategory !== "") {
      writer.uint32(10).string(message.deviceCategory);
    }
    if (message.mobileBrandName !== "") {
      writer.uint32(18).string(message.mobileBrandName);
    }
    if (message.mobileModelName !== "") {
      writer.uint32(26).string(message.mobileModelName);
    }
    if (message.mobileMarketingName !== "") {
      writer.uint32(34).string(message.mobileMarketingName);
    }
    if (message.deviceModel !== "") {
      writer.uint32(98).string(message.deviceModel);
    }
    if (message.platformVersion !== "") {
      writer.uint32(50).string(message.platformVersion);
    }
    if (message.deviceId !== "") {
      writer.uint32(58).string(message.deviceId);
    }
    if (message.resettableDeviceId !== "") {
      writer.uint32(66).string(message.resettableDeviceId);
    }
    if (message.userDefaultLanguage !== "") {
      writer.uint32(74).string(message.userDefaultLanguage);
    }
    if (message.deviceTimeZoneOffsetSeconds !== 0) {
      writer.uint32(80).int32(message.deviceTimeZoneOffsetSeconds);
    }
    if (message.limitedAdTracking !== false) {
      writer.uint32(88).bool(message.limitedAdTracking);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceCategory = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mobileBrandName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mobileModelName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mobileMarketingName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.deviceModel = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.platformVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resettableDeviceId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userDefaultLanguage = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.deviceTimeZoneOffsetSeconds = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.limitedAdTracking = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceInfo {
    return {
      deviceCategory: isSet(object.deviceCategory) ? globalThis.String(object.deviceCategory) : "",
      mobileBrandName: isSet(object.mobileBrandName) ? globalThis.String(object.mobileBrandName) : "",
      mobileModelName: isSet(object.mobileModelName) ? globalThis.String(object.mobileModelName) : "",
      mobileMarketingName: isSet(object.mobileMarketingName) ? globalThis.String(object.mobileMarketingName) : "",
      deviceModel: isSet(object.deviceModel) ? globalThis.String(object.deviceModel) : "",
      platformVersion: isSet(object.platformVersion) ? globalThis.String(object.platformVersion) : "",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      resettableDeviceId: isSet(object.resettableDeviceId) ? globalThis.String(object.resettableDeviceId) : "",
      userDefaultLanguage: isSet(object.userDefaultLanguage) ? globalThis.String(object.userDefaultLanguage) : "",
      deviceTimeZoneOffsetSeconds: isSet(object.deviceTimeZoneOffsetSeconds)
        ? globalThis.Number(object.deviceTimeZoneOffsetSeconds)
        : 0,
      limitedAdTracking: isSet(object.limitedAdTracking) ? globalThis.Boolean(object.limitedAdTracking) : false,
    };
  },

  toJSON(message: DeviceInfo): unknown {
    const obj: any = {};
    if (message.deviceCategory !== "") {
      obj.deviceCategory = message.deviceCategory;
    }
    if (message.mobileBrandName !== "") {
      obj.mobileBrandName = message.mobileBrandName;
    }
    if (message.mobileModelName !== "") {
      obj.mobileModelName = message.mobileModelName;
    }
    if (message.mobileMarketingName !== "") {
      obj.mobileMarketingName = message.mobileMarketingName;
    }
    if (message.deviceModel !== "") {
      obj.deviceModel = message.deviceModel;
    }
    if (message.platformVersion !== "") {
      obj.platformVersion = message.platformVersion;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.resettableDeviceId !== "") {
      obj.resettableDeviceId = message.resettableDeviceId;
    }
    if (message.userDefaultLanguage !== "") {
      obj.userDefaultLanguage = message.userDefaultLanguage;
    }
    if (message.deviceTimeZoneOffsetSeconds !== 0) {
      obj.deviceTimeZoneOffsetSeconds = Math.round(message.deviceTimeZoneOffsetSeconds);
    }
    if (message.limitedAdTracking !== false) {
      obj.limitedAdTracking = message.limitedAdTracking;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeviceInfo>, I>>(base?: I): DeviceInfo {
    return DeviceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeviceInfo>, I>>(object: I): DeviceInfo {
    const message = createBaseDeviceInfo();
    message.deviceCategory = object.deviceCategory ?? "";
    message.mobileBrandName = object.mobileBrandName ?? "";
    message.mobileModelName = object.mobileModelName ?? "";
    message.mobileMarketingName = object.mobileMarketingName ?? "";
    message.deviceModel = object.deviceModel ?? "";
    message.platformVersion = object.platformVersion ?? "";
    message.deviceId = object.deviceId ?? "";
    message.resettableDeviceId = object.resettableDeviceId ?? "";
    message.userDefaultLanguage = object.userDefaultLanguage ?? "";
    message.deviceTimeZoneOffsetSeconds = object.deviceTimeZoneOffsetSeconds ?? 0;
    message.limitedAdTracking = object.limitedAdTracking ?? false;
    return message;
  },
};

function createBaseAppInfo(): AppInfo {
  return { appVersion: "", appInstanceId: "", appStore: "", appPlatform: "", appId: "" };
}

export const AppInfo: MessageFns<AppInfo> = {
  encode(message: AppInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appVersion !== "") {
      writer.uint32(10).string(message.appVersion);
    }
    if (message.appInstanceId !== "") {
      writer.uint32(18).string(message.appInstanceId);
    }
    if (message.appStore !== "") {
      writer.uint32(26).string(message.appStore);
    }
    if (message.appPlatform !== "") {
      writer.uint32(34).string(message.appPlatform);
    }
    if (message.appId !== "") {
      writer.uint32(42).string(message.appId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appInstanceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appStore = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appPlatform = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppInfo {
    return {
      appVersion: isSet(object.appVersion) ? globalThis.String(object.appVersion) : "",
      appInstanceId: isSet(object.appInstanceId) ? globalThis.String(object.appInstanceId) : "",
      appStore: isSet(object.appStore) ? globalThis.String(object.appStore) : "",
      appPlatform: isSet(object.appPlatform) ? globalThis.String(object.appPlatform) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
    };
  },

  toJSON(message: AppInfo): unknown {
    const obj: any = {};
    if (message.appVersion !== "") {
      obj.appVersion = message.appVersion;
    }
    if (message.appInstanceId !== "") {
      obj.appInstanceId = message.appInstanceId;
    }
    if (message.appStore !== "") {
      obj.appStore = message.appStore;
    }
    if (message.appPlatform !== "") {
      obj.appPlatform = message.appPlatform;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppInfo>, I>>(base?: I): AppInfo {
    return AppInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppInfo>, I>>(object: I): AppInfo {
    const message = createBaseAppInfo();
    message.appVersion = object.appVersion ?? "";
    message.appInstanceId = object.appInstanceId ?? "";
    message.appStore = object.appStore ?? "";
    message.appPlatform = object.appPlatform ?? "";
    message.appId = object.appId ?? "";
    return message;
  },
};

function createBaseGeoInfo(): GeoInfo {
  return { continent: "", country: "", region: "", city: "" };
}

export const GeoInfo: MessageFns<GeoInfo> = {
  encode(message: GeoInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.continent !== "") {
      writer.uint32(10).string(message.continent);
    }
    if (message.country !== "") {
      writer.uint32(18).string(message.country);
    }
    if (message.region !== "") {
      writer.uint32(26).string(message.region);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.continent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoInfo {
    return {
      continent: isSet(object.continent) ? globalThis.String(object.continent) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
    };
  },

  toJSON(message: GeoInfo): unknown {
    const obj: any = {};
    if (message.continent !== "") {
      obj.continent = message.continent;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoInfo>, I>>(base?: I): GeoInfo {
    return GeoInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoInfo>, I>>(object: I): GeoInfo {
    const message = createBaseGeoInfo();
    message.continent = object.continent ?? "";
    message.country = object.country ?? "";
    message.region = object.region ?? "";
    message.city = object.city ?? "";
    return message;
  },
};

function createBaseTrafficSource(): TrafficSource {
  return { userAcquiredCampaign: "", userAcquiredSource: "", userAcquiredMedium: "" };
}

export const TrafficSource: MessageFns<TrafficSource> = {
  encode(message: TrafficSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAcquiredCampaign !== "") {
      writer.uint32(18).string(message.userAcquiredCampaign);
    }
    if (message.userAcquiredSource !== "") {
      writer.uint32(26).string(message.userAcquiredSource);
    }
    if (message.userAcquiredMedium !== "") {
      writer.uint32(34).string(message.userAcquiredMedium);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrafficSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrafficSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userAcquiredCampaign = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAcquiredSource = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userAcquiredMedium = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrafficSource {
    return {
      userAcquiredCampaign: isSet(object.userAcquiredCampaign) ? globalThis.String(object.userAcquiredCampaign) : "",
      userAcquiredSource: isSet(object.userAcquiredSource) ? globalThis.String(object.userAcquiredSource) : "",
      userAcquiredMedium: isSet(object.userAcquiredMedium) ? globalThis.String(object.userAcquiredMedium) : "",
    };
  },

  toJSON(message: TrafficSource): unknown {
    const obj: any = {};
    if (message.userAcquiredCampaign !== "") {
      obj.userAcquiredCampaign = message.userAcquiredCampaign;
    }
    if (message.userAcquiredSource !== "") {
      obj.userAcquiredSource = message.userAcquiredSource;
    }
    if (message.userAcquiredMedium !== "") {
      obj.userAcquiredMedium = message.userAcquiredMedium;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrafficSource>, I>>(base?: I): TrafficSource {
    return TrafficSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrafficSource>, I>>(object: I): TrafficSource {
    const message = createBaseTrafficSource();
    message.userAcquiredCampaign = object.userAcquiredCampaign ?? "";
    message.userAcquiredSource = object.userAcquiredSource ?? "";
    message.userAcquiredMedium = object.userAcquiredMedium ?? "";
    return message;
  },
};

function createBaseExportBundleInfo(): ExportBundleInfo {
  return { bundleSequenceId: 0, serverTimestampOffsetMicros: Long.ZERO };
}

export const ExportBundleInfo: MessageFns<ExportBundleInfo> = {
  encode(message: ExportBundleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bundleSequenceId !== 0) {
      writer.uint32(8).int32(message.bundleSequenceId);
    }
    if (!message.serverTimestampOffsetMicros.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.serverTimestampOffsetMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportBundleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportBundleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bundleSequenceId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serverTimestampOffsetMicros = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportBundleInfo {
    return {
      bundleSequenceId: isSet(object.bundleSequenceId) ? globalThis.Number(object.bundleSequenceId) : 0,
      serverTimestampOffsetMicros: isSet(object.serverTimestampOffsetMicros)
        ? Long.fromValue(object.serverTimestampOffsetMicros)
        : Long.ZERO,
    };
  },

  toJSON(message: ExportBundleInfo): unknown {
    const obj: any = {};
    if (message.bundleSequenceId !== 0) {
      obj.bundleSequenceId = Math.round(message.bundleSequenceId);
    }
    if (!message.serverTimestampOffsetMicros.equals(Long.ZERO)) {
      obj.serverTimestampOffsetMicros = (message.serverTimestampOffsetMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportBundleInfo>, I>>(base?: I): ExportBundleInfo {
    return ExportBundleInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportBundleInfo>, I>>(object: I): ExportBundleInfo {
    const message = createBaseExportBundleInfo();
    message.bundleSequenceId = object.bundleSequenceId ?? 0;
    message.serverTimestampOffsetMicros =
      (object.serverTimestampOffsetMicros !== undefined && object.serverTimestampOffsetMicros !== null)
        ? Long.fromValue(object.serverTimestampOffsetMicros)
        : Long.ZERO;
    return message;
  },
};

function createBaseLtvInfo(): LtvInfo {
  return { revenue: 0, currency: "" };
}

export const LtvInfo: MessageFns<LtvInfo> = {
  encode(message: LtvInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revenue !== 0) {
      writer.uint32(9).double(message.revenue);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LtvInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLtvInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.revenue = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LtvInfo {
    return {
      revenue: isSet(object.revenue) ? globalThis.Number(object.revenue) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: LtvInfo): unknown {
    const obj: any = {};
    if (message.revenue !== 0) {
      obj.revenue = message.revenue;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LtvInfo>, I>>(base?: I): LtvInfo {
    return LtvInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LtvInfo>, I>>(object: I): LtvInfo {
    const message = createBaseLtvInfo();
    message.revenue = object.revenue ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseEventDimensions(): EventDimensions {
  return {
    date: "",
    name: "",
    params: {},
    timestampMicros: Long.ZERO,
    previousTimestampMicros: Long.ZERO,
    valueInUsd: 0,
  };
}

export const EventDimensions: MessageFns<EventDimensions> = {
  encode(message: EventDimensions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(50).string(message.date);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.params).forEach(([key, value]) => {
      EventDimensions_ParamsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (!message.timestampMicros.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.timestampMicros.toString());
    }
    if (!message.previousTimestampMicros.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.previousTimestampMicros.toString());
    }
    if (message.valueInUsd !== 0) {
      writer.uint32(57).double(message.valueInUsd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventDimensions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = EventDimensions_ParamsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.params[entry2.key] = entry2.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestampMicros = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.previousTimestampMicros = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.valueInUsd = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventDimensions {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      params: isObject(object.params)
        ? Object.entries(object.params).reduce<{ [key: string]: AnalyticsValue }>((acc, [key, value]) => {
          acc[key] = AnalyticsValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      timestampMicros: isSet(object.timestampMicros) ? Long.fromValue(object.timestampMicros) : Long.ZERO,
      previousTimestampMicros: isSet(object.previousTimestampMicros)
        ? Long.fromValue(object.previousTimestampMicros)
        : Long.ZERO,
      valueInUsd: isSet(object.valueInUsd) ? globalThis.Number(object.valueInUsd) : 0,
    };
  },

  toJSON(message: EventDimensions): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.params) {
      const entries = Object.entries(message.params);
      if (entries.length > 0) {
        obj.params = {};
        entries.forEach(([k, v]) => {
          obj.params[k] = AnalyticsValue.toJSON(v);
        });
      }
    }
    if (!message.timestampMicros.equals(Long.ZERO)) {
      obj.timestampMicros = (message.timestampMicros || Long.ZERO).toString();
    }
    if (!message.previousTimestampMicros.equals(Long.ZERO)) {
      obj.previousTimestampMicros = (message.previousTimestampMicros || Long.ZERO).toString();
    }
    if (message.valueInUsd !== 0) {
      obj.valueInUsd = message.valueInUsd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventDimensions>, I>>(base?: I): EventDimensions {
    return EventDimensions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventDimensions>, I>>(object: I): EventDimensions {
    const message = createBaseEventDimensions();
    message.date = object.date ?? "";
    message.name = object.name ?? "";
    message.params = Object.entries(object.params ?? {}).reduce<{ [key: string]: AnalyticsValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AnalyticsValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.timestampMicros = (object.timestampMicros !== undefined && object.timestampMicros !== null)
      ? Long.fromValue(object.timestampMicros)
      : Long.ZERO;
    message.previousTimestampMicros =
      (object.previousTimestampMicros !== undefined && object.previousTimestampMicros !== null)
        ? Long.fromValue(object.previousTimestampMicros)
        : Long.ZERO;
    message.valueInUsd = object.valueInUsd ?? 0;
    return message;
  },
};

function createBaseEventDimensions_ParamsEntry(): EventDimensions_ParamsEntry {
  return { key: "", value: undefined };
}

export const EventDimensions_ParamsEntry: MessageFns<EventDimensions_ParamsEntry> = {
  encode(message: EventDimensions_ParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AnalyticsValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventDimensions_ParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDimensions_ParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AnalyticsValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventDimensions_ParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AnalyticsValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EventDimensions_ParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AnalyticsValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventDimensions_ParamsEntry>, I>>(base?: I): EventDimensions_ParamsEntry {
    return EventDimensions_ParamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventDimensions_ParamsEntry>, I>>(object: I): EventDimensions_ParamsEntry {
    const message = createBaseEventDimensions_ParamsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AnalyticsValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
