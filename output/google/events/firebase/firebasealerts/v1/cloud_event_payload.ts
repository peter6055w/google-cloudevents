// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: google/events/firebase/firebasealerts/v1/cloud_event_payload.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp";
import { DateMessage } from "../../../../type/date";

export const protobufPackage = "google.events.firebase.firebasealerts.v1";

/** Basic information of the Crashlytics issue */
export interface CrashlyticsIssue {
  id: string;
  title: string;
  subtitle: string;
  appVersion: string;
}

export interface CrashlyticsNewFatalIssuePayload {
  /** Basic information of the Crashlytics issue */
  issue?: CrashlyticsIssue | undefined;
}

export interface CrashlyticsNewNonfatalIssuePayload {
  /** Basic information of the Crashlytics issue */
  issue?: CrashlyticsIssue | undefined;
}

export interface CrashlyticsRegressionAlertPayload {
  /** The type of the Crashlytics issue, e.g. new fatal, new nonfatal, ANR */
  type: string;
  /** Basic information of the Crashlytics issue */
  issue?:
    | CrashlyticsIssue
    | undefined;
  /**
   * The time that the Crashlytics issues was most recently resolved before it
   * began to reoccur
   */
  resolveTime?: Date | undefined;
}

export interface CrashlyticsVelocityAlertPayload {
  /** Basic information of the Crashlytics issue */
  issue?:
    | CrashlyticsIssue
    | undefined;
  /** The time that the Crashlytics issue gets created */
  createTime?:
    | Date
    | undefined;
  /**
   * The number of user sessions for the given app version that had this
   * specific crash issue in the time period used to trigger the velocity alert,
   * which is currently 1h
   */
  crashCount: Long;
  /**
   * The percentage of user sessions for the given app version that had this
   * specific crash issue in the time period used to trigger the velocity alert,
   * which is currently 1h
   */
  crashPercentage: number;
  /**
   * The first app version where this issue was seen, and not necessarily the
   * version that has triggered the alert
   */
  firstVersion: string;
}

export interface CrashlyticsStabilityDigestPayload {
  /**
   * The date that the digest gets created, issues in the digest should
   * have the same date as the digest date
   */
  digestDate?:
    | DateMessage
    | undefined;
  /** A stability digest contains several trending Crashlytics issues */
  trendingIssues: CrashlyticsStabilityDigestPayload_TrendingIssueDetails[];
}

export interface CrashlyticsStabilityDigestPayload_TrendingIssueDetails {
  /** The type of the Crashlytics issue, e.g. new fatal, new nonfatal, ANR */
  type: string;
  /** Basic information of the Crashlytics issue */
  issue?:
    | CrashlyticsIssue
    | undefined;
  /** The number of crashes that occurred with the issue */
  eventCount: Long;
  /** The number of distinct users that were affected by the issue */
  userCount: Long;
}

export interface CrashlyticsNewAnrIssuePayload {
  issue?: CrashlyticsIssue | undefined;
}

export interface CrashlyticsMissingSymbolsPayload {
  appVersion: string;
  uuid: string;
}

export interface FireperfThresholdAlertPayload {
  /**
   * Name of the trace or network request this alert is for (e.g.
   * my_custom_trace, firebase.com/api/123)
   */
  eventName: string;
  /**
   * The resource type this alert is for (i.e. trace, network request, screen
   * rendering, etc.)
   */
  eventType: string;
  /**
   * The metric type this alert is for (i.e. success rate, response time,
   * duration, etc.)
   */
  metricType: string;
  /** The number of events checked for this alert condition */
  numSamples: Long;
  /** The threshold value of the alert condition without units (e.g. "75", "2.1") */
  thresholdValue: number;
  /** The unit for the alert threshold (e.g. "percent", "seconds") */
  thresholdUnit: string;
  /**
   * The percentile of the alert condition, can be 0 if percentile is not
   * applicable to the alert condition; range: [0, 100]
   */
  conditionPercentile: number;
  /**
   * The app version this alert was triggered for, can be empty if the alert is
   * for a network request (because the alert was checked against data from all
   * versions of app) or a web app (where the app is versionless)
   */
  appVersion: string;
  /** The value that violated the alert condition (e.g. "76.5", "3") */
  violationValue: number;
  /** The unit for the violation value (e.g. "percent", "seconds") */
  violationUnit: string;
  /** The link to Fireconsole to investigate more into this alert */
  investigateUri: string;
}

export interface AppDistroNewTesterIosDevicePayload {
  testerName: string;
  testerEmail: string;
  testerDeviceModelName: string;
  testerDeviceIdentifier: string;
}

export interface AppDistroInAppFeedbackPayload {
  /**
   * Resource name. Format:
   * projects/{project_number}/apps/{app_id}/releases/{release_id}/feedbackReports/{feedback_id}
   */
  feedbackReport: string;
  /** Deep link back to the Firebase console. */
  feedbackConsoleUri: string;
  /** Name of the tester. */
  testerName: string;
  /** Email address of the tester. */
  testerEmail: string;
  /**
   * Version consisting of `versionName` and `versionCode` for Android and
   * `CFBundleShortVersionString` and `CFBundleVersion` for iOS.
   */
  appVersion: string;
  /** Text entered by the tester. */
  text: string;
  /** URI to download screenshot.  This URI is fast expiring. */
  screenshotUri: string;
}

export interface BillingPlanUpdatePayload {
  /** A Firebase plan */
  billingPlan: string;
  /** The email address of the person that triggered billing plan change */
  principalEmail: string;
  /** The type of the notification, e.g. upgrade, downgrade */
  notificationType: string;
}

export interface BillingPlanAutomatedUpdatePayload {
  /** A Firebase plan */
  billingPlan: string;
  /** The type of the notification, e.g. upgrade, downgrade */
  notificationType: string;
}

function createBaseCrashlyticsIssue(): CrashlyticsIssue {
  return { id: "", title: "", subtitle: "", appVersion: "" };
}

export const CrashlyticsIssue: MessageFns<CrashlyticsIssue> = {
  encode(message: CrashlyticsIssue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.subtitle !== "") {
      writer.uint32(26).string(message.subtitle);
    }
    if (message.appVersion !== "") {
      writer.uint32(34).string(message.appVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subtitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsIssue {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      subtitle: isSet(object.subtitle) ? globalThis.String(object.subtitle) : "",
      appVersion: isSet(object.appVersion) ? globalThis.String(object.appVersion) : "",
    };
  },

  toJSON(message: CrashlyticsIssue): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.subtitle !== "") {
      obj.subtitle = message.subtitle;
    }
    if (message.appVersion !== "") {
      obj.appVersion = message.appVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsIssue>, I>>(base?: I): CrashlyticsIssue {
    return CrashlyticsIssue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsIssue>, I>>(object: I): CrashlyticsIssue {
    const message = createBaseCrashlyticsIssue();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.subtitle = object.subtitle ?? "";
    message.appVersion = object.appVersion ?? "";
    return message;
  },
};

function createBaseCrashlyticsNewFatalIssuePayload(): CrashlyticsNewFatalIssuePayload {
  return { issue: undefined };
}

export const CrashlyticsNewFatalIssuePayload: MessageFns<CrashlyticsNewFatalIssuePayload> = {
  encode(message: CrashlyticsNewFatalIssuePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issue !== undefined) {
      CrashlyticsIssue.encode(message.issue, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsNewFatalIssuePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsNewFatalIssuePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issue = CrashlyticsIssue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsNewFatalIssuePayload {
    return { issue: isSet(object.issue) ? CrashlyticsIssue.fromJSON(object.issue) : undefined };
  },

  toJSON(message: CrashlyticsNewFatalIssuePayload): unknown {
    const obj: any = {};
    if (message.issue !== undefined) {
      obj.issue = CrashlyticsIssue.toJSON(message.issue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsNewFatalIssuePayload>, I>>(base?: I): CrashlyticsNewFatalIssuePayload {
    return CrashlyticsNewFatalIssuePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsNewFatalIssuePayload>, I>>(
    object: I,
  ): CrashlyticsNewFatalIssuePayload {
    const message = createBaseCrashlyticsNewFatalIssuePayload();
    message.issue = (object.issue !== undefined && object.issue !== null)
      ? CrashlyticsIssue.fromPartial(object.issue)
      : undefined;
    return message;
  },
};

function createBaseCrashlyticsNewNonfatalIssuePayload(): CrashlyticsNewNonfatalIssuePayload {
  return { issue: undefined };
}

export const CrashlyticsNewNonfatalIssuePayload: MessageFns<CrashlyticsNewNonfatalIssuePayload> = {
  encode(message: CrashlyticsNewNonfatalIssuePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issue !== undefined) {
      CrashlyticsIssue.encode(message.issue, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsNewNonfatalIssuePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsNewNonfatalIssuePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issue = CrashlyticsIssue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsNewNonfatalIssuePayload {
    return { issue: isSet(object.issue) ? CrashlyticsIssue.fromJSON(object.issue) : undefined };
  },

  toJSON(message: CrashlyticsNewNonfatalIssuePayload): unknown {
    const obj: any = {};
    if (message.issue !== undefined) {
      obj.issue = CrashlyticsIssue.toJSON(message.issue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsNewNonfatalIssuePayload>, I>>(
    base?: I,
  ): CrashlyticsNewNonfatalIssuePayload {
    return CrashlyticsNewNonfatalIssuePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsNewNonfatalIssuePayload>, I>>(
    object: I,
  ): CrashlyticsNewNonfatalIssuePayload {
    const message = createBaseCrashlyticsNewNonfatalIssuePayload();
    message.issue = (object.issue !== undefined && object.issue !== null)
      ? CrashlyticsIssue.fromPartial(object.issue)
      : undefined;
    return message;
  },
};

function createBaseCrashlyticsRegressionAlertPayload(): CrashlyticsRegressionAlertPayload {
  return { type: "", issue: undefined, resolveTime: undefined };
}

export const CrashlyticsRegressionAlertPayload: MessageFns<CrashlyticsRegressionAlertPayload> = {
  encode(message: CrashlyticsRegressionAlertPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.issue !== undefined) {
      CrashlyticsIssue.encode(message.issue, writer.uint32(18).fork()).join();
    }
    if (message.resolveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.resolveTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsRegressionAlertPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsRegressionAlertPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issue = CrashlyticsIssue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resolveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsRegressionAlertPayload {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      issue: isSet(object.issue) ? CrashlyticsIssue.fromJSON(object.issue) : undefined,
      resolveTime: isSet(object.resolveTime) ? fromJsonTimestamp(object.resolveTime) : undefined,
    };
  },

  toJSON(message: CrashlyticsRegressionAlertPayload): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.issue !== undefined) {
      obj.issue = CrashlyticsIssue.toJSON(message.issue);
    }
    if (message.resolveTime !== undefined) {
      obj.resolveTime = message.resolveTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsRegressionAlertPayload>, I>>(
    base?: I,
  ): CrashlyticsRegressionAlertPayload {
    return CrashlyticsRegressionAlertPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsRegressionAlertPayload>, I>>(
    object: I,
  ): CrashlyticsRegressionAlertPayload {
    const message = createBaseCrashlyticsRegressionAlertPayload();
    message.type = object.type ?? "";
    message.issue = (object.issue !== undefined && object.issue !== null)
      ? CrashlyticsIssue.fromPartial(object.issue)
      : undefined;
    message.resolveTime = object.resolveTime ?? undefined;
    return message;
  },
};

function createBaseCrashlyticsVelocityAlertPayload(): CrashlyticsVelocityAlertPayload {
  return { issue: undefined, createTime: undefined, crashCount: Long.ZERO, crashPercentage: 0, firstVersion: "" };
}

export const CrashlyticsVelocityAlertPayload: MessageFns<CrashlyticsVelocityAlertPayload> = {
  encode(message: CrashlyticsVelocityAlertPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issue !== undefined) {
      CrashlyticsIssue.encode(message.issue, writer.uint32(10).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (!message.crashCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.crashCount.toString());
    }
    if (message.crashPercentage !== 0) {
      writer.uint32(33).double(message.crashPercentage);
    }
    if (message.firstVersion !== "") {
      writer.uint32(42).string(message.firstVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsVelocityAlertPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsVelocityAlertPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issue = CrashlyticsIssue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.crashCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.crashPercentage = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.firstVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsVelocityAlertPayload {
    return {
      issue: isSet(object.issue) ? CrashlyticsIssue.fromJSON(object.issue) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      crashCount: isSet(object.crashCount) ? Long.fromValue(object.crashCount) : Long.ZERO,
      crashPercentage: isSet(object.crashPercentage) ? globalThis.Number(object.crashPercentage) : 0,
      firstVersion: isSet(object.firstVersion) ? globalThis.String(object.firstVersion) : "",
    };
  },

  toJSON(message: CrashlyticsVelocityAlertPayload): unknown {
    const obj: any = {};
    if (message.issue !== undefined) {
      obj.issue = CrashlyticsIssue.toJSON(message.issue);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (!message.crashCount.equals(Long.ZERO)) {
      obj.crashCount = (message.crashCount || Long.ZERO).toString();
    }
    if (message.crashPercentage !== 0) {
      obj.crashPercentage = message.crashPercentage;
    }
    if (message.firstVersion !== "") {
      obj.firstVersion = message.firstVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsVelocityAlertPayload>, I>>(base?: I): CrashlyticsVelocityAlertPayload {
    return CrashlyticsVelocityAlertPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsVelocityAlertPayload>, I>>(
    object: I,
  ): CrashlyticsVelocityAlertPayload {
    const message = createBaseCrashlyticsVelocityAlertPayload();
    message.issue = (object.issue !== undefined && object.issue !== null)
      ? CrashlyticsIssue.fromPartial(object.issue)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.crashCount = (object.crashCount !== undefined && object.crashCount !== null)
      ? Long.fromValue(object.crashCount)
      : Long.ZERO;
    message.crashPercentage = object.crashPercentage ?? 0;
    message.firstVersion = object.firstVersion ?? "";
    return message;
  },
};

function createBaseCrashlyticsStabilityDigestPayload(): CrashlyticsStabilityDigestPayload {
  return { digestDate: undefined, trendingIssues: [] };
}

export const CrashlyticsStabilityDigestPayload: MessageFns<CrashlyticsStabilityDigestPayload> = {
  encode(message: CrashlyticsStabilityDigestPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.digestDate !== undefined) {
      DateMessage.encode(message.digestDate, writer.uint32(42).fork()).join();
    }
    for (const v of message.trendingIssues) {
      CrashlyticsStabilityDigestPayload_TrendingIssueDetails.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsStabilityDigestPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsStabilityDigestPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.digestDate = DateMessage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trendingIssues.push(
            CrashlyticsStabilityDigestPayload_TrendingIssueDetails.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsStabilityDigestPayload {
    return {
      digestDate: isSet(object.digestDate) ? DateMessage.fromJSON(object.digestDate) : undefined,
      trendingIssues: globalThis.Array.isArray(object?.trendingIssues)
        ? object.trendingIssues.map((e: any) => CrashlyticsStabilityDigestPayload_TrendingIssueDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CrashlyticsStabilityDigestPayload): unknown {
    const obj: any = {};
    if (message.digestDate !== undefined) {
      obj.digestDate = DateMessage.toJSON(message.digestDate);
    }
    if (message.trendingIssues?.length) {
      obj.trendingIssues = message.trendingIssues.map((e) =>
        CrashlyticsStabilityDigestPayload_TrendingIssueDetails.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsStabilityDigestPayload>, I>>(
    base?: I,
  ): CrashlyticsStabilityDigestPayload {
    return CrashlyticsStabilityDigestPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsStabilityDigestPayload>, I>>(
    object: I,
  ): CrashlyticsStabilityDigestPayload {
    const message = createBaseCrashlyticsStabilityDigestPayload();
    message.digestDate = (object.digestDate !== undefined && object.digestDate !== null)
      ? DateMessage.fromPartial(object.digestDate)
      : undefined;
    message.trendingIssues =
      object.trendingIssues?.map((e) => CrashlyticsStabilityDigestPayload_TrendingIssueDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCrashlyticsStabilityDigestPayload_TrendingIssueDetails(): CrashlyticsStabilityDigestPayload_TrendingIssueDetails {
  return { type: "", issue: undefined, eventCount: Long.ZERO, userCount: Long.ZERO };
}

export const CrashlyticsStabilityDigestPayload_TrendingIssueDetails: MessageFns<
  CrashlyticsStabilityDigestPayload_TrendingIssueDetails
> = {
  encode(
    message: CrashlyticsStabilityDigestPayload_TrendingIssueDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.issue !== undefined) {
      CrashlyticsIssue.encode(message.issue, writer.uint32(18).fork()).join();
    }
    if (!message.eventCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.eventCount.toString());
    }
    if (!message.userCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.userCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsStabilityDigestPayload_TrendingIssueDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsStabilityDigestPayload_TrendingIssueDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issue = CrashlyticsIssue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eventCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userCount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsStabilityDigestPayload_TrendingIssueDetails {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      issue: isSet(object.issue) ? CrashlyticsIssue.fromJSON(object.issue) : undefined,
      eventCount: isSet(object.eventCount) ? Long.fromValue(object.eventCount) : Long.ZERO,
      userCount: isSet(object.userCount) ? Long.fromValue(object.userCount) : Long.ZERO,
    };
  },

  toJSON(message: CrashlyticsStabilityDigestPayload_TrendingIssueDetails): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.issue !== undefined) {
      obj.issue = CrashlyticsIssue.toJSON(message.issue);
    }
    if (!message.eventCount.equals(Long.ZERO)) {
      obj.eventCount = (message.eventCount || Long.ZERO).toString();
    }
    if (!message.userCount.equals(Long.ZERO)) {
      obj.userCount = (message.userCount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsStabilityDigestPayload_TrendingIssueDetails>, I>>(
    base?: I,
  ): CrashlyticsStabilityDigestPayload_TrendingIssueDetails {
    return CrashlyticsStabilityDigestPayload_TrendingIssueDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsStabilityDigestPayload_TrendingIssueDetails>, I>>(
    object: I,
  ): CrashlyticsStabilityDigestPayload_TrendingIssueDetails {
    const message = createBaseCrashlyticsStabilityDigestPayload_TrendingIssueDetails();
    message.type = object.type ?? "";
    message.issue = (object.issue !== undefined && object.issue !== null)
      ? CrashlyticsIssue.fromPartial(object.issue)
      : undefined;
    message.eventCount = (object.eventCount !== undefined && object.eventCount !== null)
      ? Long.fromValue(object.eventCount)
      : Long.ZERO;
    message.userCount = (object.userCount !== undefined && object.userCount !== null)
      ? Long.fromValue(object.userCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseCrashlyticsNewAnrIssuePayload(): CrashlyticsNewAnrIssuePayload {
  return { issue: undefined };
}

export const CrashlyticsNewAnrIssuePayload: MessageFns<CrashlyticsNewAnrIssuePayload> = {
  encode(message: CrashlyticsNewAnrIssuePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issue !== undefined) {
      CrashlyticsIssue.encode(message.issue, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsNewAnrIssuePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsNewAnrIssuePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issue = CrashlyticsIssue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsNewAnrIssuePayload {
    return { issue: isSet(object.issue) ? CrashlyticsIssue.fromJSON(object.issue) : undefined };
  },

  toJSON(message: CrashlyticsNewAnrIssuePayload): unknown {
    const obj: any = {};
    if (message.issue !== undefined) {
      obj.issue = CrashlyticsIssue.toJSON(message.issue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsNewAnrIssuePayload>, I>>(base?: I): CrashlyticsNewAnrIssuePayload {
    return CrashlyticsNewAnrIssuePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsNewAnrIssuePayload>, I>>(
    object: I,
  ): CrashlyticsNewAnrIssuePayload {
    const message = createBaseCrashlyticsNewAnrIssuePayload();
    message.issue = (object.issue !== undefined && object.issue !== null)
      ? CrashlyticsIssue.fromPartial(object.issue)
      : undefined;
    return message;
  },
};

function createBaseCrashlyticsMissingSymbolsPayload(): CrashlyticsMissingSymbolsPayload {
  return { appVersion: "", uuid: "" };
}

export const CrashlyticsMissingSymbolsPayload: MessageFns<CrashlyticsMissingSymbolsPayload> = {
  encode(message: CrashlyticsMissingSymbolsPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appVersion !== "") {
      writer.uint32(10).string(message.appVersion);
    }
    if (message.uuid !== "") {
      writer.uint32(18).string(message.uuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrashlyticsMissingSymbolsPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrashlyticsMissingSymbolsPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrashlyticsMissingSymbolsPayload {
    return {
      appVersion: isSet(object.appVersion) ? globalThis.String(object.appVersion) : "",
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
    };
  },

  toJSON(message: CrashlyticsMissingSymbolsPayload): unknown {
    const obj: any = {};
    if (message.appVersion !== "") {
      obj.appVersion = message.appVersion;
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrashlyticsMissingSymbolsPayload>, I>>(
    base?: I,
  ): CrashlyticsMissingSymbolsPayload {
    return CrashlyticsMissingSymbolsPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrashlyticsMissingSymbolsPayload>, I>>(
    object: I,
  ): CrashlyticsMissingSymbolsPayload {
    const message = createBaseCrashlyticsMissingSymbolsPayload();
    message.appVersion = object.appVersion ?? "";
    message.uuid = object.uuid ?? "";
    return message;
  },
};

function createBaseFireperfThresholdAlertPayload(): FireperfThresholdAlertPayload {
  return {
    eventName: "",
    eventType: "",
    metricType: "",
    numSamples: Long.ZERO,
    thresholdValue: 0,
    thresholdUnit: "",
    conditionPercentile: 0,
    appVersion: "",
    violationValue: 0,
    violationUnit: "",
    investigateUri: "",
  };
}

export const FireperfThresholdAlertPayload: MessageFns<FireperfThresholdAlertPayload> = {
  encode(message: FireperfThresholdAlertPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.metricType !== "") {
      writer.uint32(26).string(message.metricType);
    }
    if (!message.numSamples.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.numSamples.toString());
    }
    if (message.thresholdValue !== 0) {
      writer.uint32(45).float(message.thresholdValue);
    }
    if (message.thresholdUnit !== "") {
      writer.uint32(50).string(message.thresholdUnit);
    }
    if (message.conditionPercentile !== 0) {
      writer.uint32(56).int32(message.conditionPercentile);
    }
    if (message.appVersion !== "") {
      writer.uint32(66).string(message.appVersion);
    }
    if (message.violationValue !== 0) {
      writer.uint32(77).float(message.violationValue);
    }
    if (message.violationUnit !== "") {
      writer.uint32(82).string(message.violationUnit);
    }
    if (message.investigateUri !== "") {
      writer.uint32(90).string(message.investigateUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireperfThresholdAlertPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireperfThresholdAlertPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metricType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numSamples = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.thresholdValue = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.thresholdUnit = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.conditionPercentile = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.violationValue = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.violationUnit = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.investigateUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireperfThresholdAlertPayload {
    return {
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      metricType: isSet(object.metricType) ? globalThis.String(object.metricType) : "",
      numSamples: isSet(object.numSamples) ? Long.fromValue(object.numSamples) : Long.ZERO,
      thresholdValue: isSet(object.thresholdValue) ? globalThis.Number(object.thresholdValue) : 0,
      thresholdUnit: isSet(object.thresholdUnit) ? globalThis.String(object.thresholdUnit) : "",
      conditionPercentile: isSet(object.conditionPercentile) ? globalThis.Number(object.conditionPercentile) : 0,
      appVersion: isSet(object.appVersion) ? globalThis.String(object.appVersion) : "",
      violationValue: isSet(object.violationValue) ? globalThis.Number(object.violationValue) : 0,
      violationUnit: isSet(object.violationUnit) ? globalThis.String(object.violationUnit) : "",
      investigateUri: isSet(object.investigateUri) ? globalThis.String(object.investigateUri) : "",
    };
  },

  toJSON(message: FireperfThresholdAlertPayload): unknown {
    const obj: any = {};
    if (message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.metricType !== "") {
      obj.metricType = message.metricType;
    }
    if (!message.numSamples.equals(Long.ZERO)) {
      obj.numSamples = (message.numSamples || Long.ZERO).toString();
    }
    if (message.thresholdValue !== 0) {
      obj.thresholdValue = message.thresholdValue;
    }
    if (message.thresholdUnit !== "") {
      obj.thresholdUnit = message.thresholdUnit;
    }
    if (message.conditionPercentile !== 0) {
      obj.conditionPercentile = Math.round(message.conditionPercentile);
    }
    if (message.appVersion !== "") {
      obj.appVersion = message.appVersion;
    }
    if (message.violationValue !== 0) {
      obj.violationValue = message.violationValue;
    }
    if (message.violationUnit !== "") {
      obj.violationUnit = message.violationUnit;
    }
    if (message.investigateUri !== "") {
      obj.investigateUri = message.investigateUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireperfThresholdAlertPayload>, I>>(base?: I): FireperfThresholdAlertPayload {
    return FireperfThresholdAlertPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireperfThresholdAlertPayload>, I>>(
    object: I,
  ): FireperfThresholdAlertPayload {
    const message = createBaseFireperfThresholdAlertPayload();
    message.eventName = object.eventName ?? "";
    message.eventType = object.eventType ?? "";
    message.metricType = object.metricType ?? "";
    message.numSamples = (object.numSamples !== undefined && object.numSamples !== null)
      ? Long.fromValue(object.numSamples)
      : Long.ZERO;
    message.thresholdValue = object.thresholdValue ?? 0;
    message.thresholdUnit = object.thresholdUnit ?? "";
    message.conditionPercentile = object.conditionPercentile ?? 0;
    message.appVersion = object.appVersion ?? "";
    message.violationValue = object.violationValue ?? 0;
    message.violationUnit = object.violationUnit ?? "";
    message.investigateUri = object.investigateUri ?? "";
    return message;
  },
};

function createBaseAppDistroNewTesterIosDevicePayload(): AppDistroNewTesterIosDevicePayload {
  return { testerName: "", testerEmail: "", testerDeviceModelName: "", testerDeviceIdentifier: "" };
}

export const AppDistroNewTesterIosDevicePayload: MessageFns<AppDistroNewTesterIosDevicePayload> = {
  encode(message: AppDistroNewTesterIosDevicePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testerName !== "") {
      writer.uint32(10).string(message.testerName);
    }
    if (message.testerEmail !== "") {
      writer.uint32(18).string(message.testerEmail);
    }
    if (message.testerDeviceModelName !== "") {
      writer.uint32(26).string(message.testerDeviceModelName);
    }
    if (message.testerDeviceIdentifier !== "") {
      writer.uint32(34).string(message.testerDeviceIdentifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppDistroNewTesterIosDevicePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppDistroNewTesterIosDevicePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testerEmail = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testerDeviceModelName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.testerDeviceIdentifier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppDistroNewTesterIosDevicePayload {
    return {
      testerName: isSet(object.testerName) ? globalThis.String(object.testerName) : "",
      testerEmail: isSet(object.testerEmail) ? globalThis.String(object.testerEmail) : "",
      testerDeviceModelName: isSet(object.testerDeviceModelName) ? globalThis.String(object.testerDeviceModelName) : "",
      testerDeviceIdentifier: isSet(object.testerDeviceIdentifier)
        ? globalThis.String(object.testerDeviceIdentifier)
        : "",
    };
  },

  toJSON(message: AppDistroNewTesterIosDevicePayload): unknown {
    const obj: any = {};
    if (message.testerName !== "") {
      obj.testerName = message.testerName;
    }
    if (message.testerEmail !== "") {
      obj.testerEmail = message.testerEmail;
    }
    if (message.testerDeviceModelName !== "") {
      obj.testerDeviceModelName = message.testerDeviceModelName;
    }
    if (message.testerDeviceIdentifier !== "") {
      obj.testerDeviceIdentifier = message.testerDeviceIdentifier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppDistroNewTesterIosDevicePayload>, I>>(
    base?: I,
  ): AppDistroNewTesterIosDevicePayload {
    return AppDistroNewTesterIosDevicePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppDistroNewTesterIosDevicePayload>, I>>(
    object: I,
  ): AppDistroNewTesterIosDevicePayload {
    const message = createBaseAppDistroNewTesterIosDevicePayload();
    message.testerName = object.testerName ?? "";
    message.testerEmail = object.testerEmail ?? "";
    message.testerDeviceModelName = object.testerDeviceModelName ?? "";
    message.testerDeviceIdentifier = object.testerDeviceIdentifier ?? "";
    return message;
  },
};

function createBaseAppDistroInAppFeedbackPayload(): AppDistroInAppFeedbackPayload {
  return {
    feedbackReport: "",
    feedbackConsoleUri: "",
    testerName: "",
    testerEmail: "",
    appVersion: "",
    text: "",
    screenshotUri: "",
  };
}

export const AppDistroInAppFeedbackPayload: MessageFns<AppDistroInAppFeedbackPayload> = {
  encode(message: AppDistroInAppFeedbackPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feedbackReport !== "") {
      writer.uint32(10).string(message.feedbackReport);
    }
    if (message.feedbackConsoleUri !== "") {
      writer.uint32(66).string(message.feedbackConsoleUri);
    }
    if (message.testerName !== "") {
      writer.uint32(18).string(message.testerName);
    }
    if (message.testerEmail !== "") {
      writer.uint32(26).string(message.testerEmail);
    }
    if (message.appVersion !== "") {
      writer.uint32(74).string(message.appVersion);
    }
    if (message.text !== "") {
      writer.uint32(50).string(message.text);
    }
    if (message.screenshotUri !== "") {
      writer.uint32(58).string(message.screenshotUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppDistroInAppFeedbackPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppDistroInAppFeedbackPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feedbackReport = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.feedbackConsoleUri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testerEmail = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.screenshotUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppDistroInAppFeedbackPayload {
    return {
      feedbackReport: isSet(object.feedbackReport) ? globalThis.String(object.feedbackReport) : "",
      feedbackConsoleUri: isSet(object.feedbackConsoleUri) ? globalThis.String(object.feedbackConsoleUri) : "",
      testerName: isSet(object.testerName) ? globalThis.String(object.testerName) : "",
      testerEmail: isSet(object.testerEmail) ? globalThis.String(object.testerEmail) : "",
      appVersion: isSet(object.appVersion) ? globalThis.String(object.appVersion) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      screenshotUri: isSet(object.screenshotUri) ? globalThis.String(object.screenshotUri) : "",
    };
  },

  toJSON(message: AppDistroInAppFeedbackPayload): unknown {
    const obj: any = {};
    if (message.feedbackReport !== "") {
      obj.feedbackReport = message.feedbackReport;
    }
    if (message.feedbackConsoleUri !== "") {
      obj.feedbackConsoleUri = message.feedbackConsoleUri;
    }
    if (message.testerName !== "") {
      obj.testerName = message.testerName;
    }
    if (message.testerEmail !== "") {
      obj.testerEmail = message.testerEmail;
    }
    if (message.appVersion !== "") {
      obj.appVersion = message.appVersion;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.screenshotUri !== "") {
      obj.screenshotUri = message.screenshotUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppDistroInAppFeedbackPayload>, I>>(base?: I): AppDistroInAppFeedbackPayload {
    return AppDistroInAppFeedbackPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppDistroInAppFeedbackPayload>, I>>(
    object: I,
  ): AppDistroInAppFeedbackPayload {
    const message = createBaseAppDistroInAppFeedbackPayload();
    message.feedbackReport = object.feedbackReport ?? "";
    message.feedbackConsoleUri = object.feedbackConsoleUri ?? "";
    message.testerName = object.testerName ?? "";
    message.testerEmail = object.testerEmail ?? "";
    message.appVersion = object.appVersion ?? "";
    message.text = object.text ?? "";
    message.screenshotUri = object.screenshotUri ?? "";
    return message;
  },
};

function createBaseBillingPlanUpdatePayload(): BillingPlanUpdatePayload {
  return { billingPlan: "", principalEmail: "", notificationType: "" };
}

export const BillingPlanUpdatePayload: MessageFns<BillingPlanUpdatePayload> = {
  encode(message: BillingPlanUpdatePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.billingPlan !== "") {
      writer.uint32(10).string(message.billingPlan);
    }
    if (message.principalEmail !== "") {
      writer.uint32(18).string(message.principalEmail);
    }
    if (message.notificationType !== "") {
      writer.uint32(26).string(message.notificationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BillingPlanUpdatePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBillingPlanUpdatePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.billingPlan = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.principalEmail = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.notificationType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BillingPlanUpdatePayload {
    return {
      billingPlan: isSet(object.billingPlan) ? globalThis.String(object.billingPlan) : "",
      principalEmail: isSet(object.principalEmail) ? globalThis.String(object.principalEmail) : "",
      notificationType: isSet(object.notificationType) ? globalThis.String(object.notificationType) : "",
    };
  },

  toJSON(message: BillingPlanUpdatePayload): unknown {
    const obj: any = {};
    if (message.billingPlan !== "") {
      obj.billingPlan = message.billingPlan;
    }
    if (message.principalEmail !== "") {
      obj.principalEmail = message.principalEmail;
    }
    if (message.notificationType !== "") {
      obj.notificationType = message.notificationType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BillingPlanUpdatePayload>, I>>(base?: I): BillingPlanUpdatePayload {
    return BillingPlanUpdatePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BillingPlanUpdatePayload>, I>>(object: I): BillingPlanUpdatePayload {
    const message = createBaseBillingPlanUpdatePayload();
    message.billingPlan = object.billingPlan ?? "";
    message.principalEmail = object.principalEmail ?? "";
    message.notificationType = object.notificationType ?? "";
    return message;
  },
};

function createBaseBillingPlanAutomatedUpdatePayload(): BillingPlanAutomatedUpdatePayload {
  return { billingPlan: "", notificationType: "" };
}

export const BillingPlanAutomatedUpdatePayload: MessageFns<BillingPlanAutomatedUpdatePayload> = {
  encode(message: BillingPlanAutomatedUpdatePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.billingPlan !== "") {
      writer.uint32(10).string(message.billingPlan);
    }
    if (message.notificationType !== "") {
      writer.uint32(18).string(message.notificationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BillingPlanAutomatedUpdatePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBillingPlanAutomatedUpdatePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.billingPlan = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.notificationType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BillingPlanAutomatedUpdatePayload {
    return {
      billingPlan: isSet(object.billingPlan) ? globalThis.String(object.billingPlan) : "",
      notificationType: isSet(object.notificationType) ? globalThis.String(object.notificationType) : "",
    };
  },

  toJSON(message: BillingPlanAutomatedUpdatePayload): unknown {
    const obj: any = {};
    if (message.billingPlan !== "") {
      obj.billingPlan = message.billingPlan;
    }
    if (message.notificationType !== "") {
      obj.notificationType = message.notificationType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BillingPlanAutomatedUpdatePayload>, I>>(
    base?: I,
  ): BillingPlanAutomatedUpdatePayload {
    return BillingPlanAutomatedUpdatePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BillingPlanAutomatedUpdatePayload>, I>>(
    object: I,
  ): BillingPlanAutomatedUpdatePayload {
    const message = createBaseBillingPlanAutomatedUpdatePayload();
    message.billingPlan = object.billingPlan ?? "";
    message.notificationType = object.notificationType ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
